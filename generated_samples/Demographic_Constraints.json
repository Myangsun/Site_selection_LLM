[
  {
    "Query": "find parcels in areas where at least 30% of residents have advanced degrees",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define advanced degree percentage\nadvanced_degree_threshold = 0.30\n# Filter for parcels with residential use codes\nresidential_use_codes = [\n    '101', '1014', '102', '1028', '104', '109', '1094', '1095', '1098',\n    '942', '9420', '943', '9430', '950', '951', '952', '970', '971', '9714'\n]\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_use_codes)].copy()\n# Filter for census tracts with at least 30% advanced degree holders\ncensus_with_advanced_degrees = census_proj[census_proj['pct_adv_deg'] >= advanced_degree_threshold].copy()\n# Spatial join: assign each parcel to the tract it falls within\nparcels_with_census = gpd.sjoin(\n    residential_parcels,\n    census_with_advanced_degrees,\n    how='left',\n    predicate='within'\n)\n# Filter for parcels that match the advanced degree criteria\n# Since we've already filtered by tract, all these will meet the criteria\nresult_parcels = parcels_with_census.dropna(subset=['pct_adv_deg']).copy()\n# Sort by parcel ID (ml)\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Demographic_Constraints",
    "Subcategory": "Income Levels"
  },
  {
    "Query": "find parcels in areas where at least 40% of residents are aged 18-64",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define function to calculate resident age percentage\ndef calculate_age_percentage(ml, census_data):\n    # Get parcel location\n    parcel_geom = parcels_proj.loc[parcels_proj['ml'] == ml, 'geometry'].values[0]\n    # Find nearby census tracts (within 400m)\n    buffered_geom = parcel_geom.buffer(400)  # 400m buffer\n    nearby_census = census_data[census_data.geometry.intersects(buffered_geom)].copy()\n    # Calculate age percentage\n    if not nearby_census.empty:\n        # Use specific age data if available\n        if 'pct_age_18_64' in nearby_census.columns:\n            age_pct = nearby_census['pct_age_18_64'].mean()\n        else:\n            # Estimate using available age data\n            total_pop = nearby_census['total_population'].sum()\n            if total_pop > 0:\n                # Approximate 18-64 age group using available age brackets\n                # Assuming 18-34 and 35-64 are roughly 18-64\n                age_18_34 = nearby_census['pct_age_18_34'].fillna(0) * nearby_census['total_population'].fillna(0) / 100\n                age_35_64 = nearby_census['pct_age_35_64'].fillna(0) * nearby_census['total_population'].fillna(0) / 100\n                age_18_64 = age_18_34 + age_35_64\n                age_pct = age_18_64.sum() / total_pop\n            else:\n                age_pct = 0\n        return age_pct\n    return None\n# Calculate age percentage for each parcel\nml_values = parcels_proj['ml'].tolist()\nage_percentages = [calculate_age_percentage(ml, census_proj) for ml in ml_values]\n# Filter for parcels with at least 40% of residents aged 18-64\nresult_parcels = parcels_proj.loc[parcels_proj['ml'].isin(ml_values)].copy()\nresult_parcels['age_percentage'] = age_percentages\nfiltered_parcels = result_parcels[result_parcels['age_percentage'] >= 0.4]\n# Sort by parcel ID\nfiltered_parcels = filtered_parcels.sort_values('ml')\n# Output results\nresult_ids = filtered_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Demographic_Constraints",
    "Subcategory": "Income Levels"
  },
  {
    "Query": "find parcels in neighborhoods with the highest proportion of advanced degrees",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate distance calculation\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define advanced degree categories\nadvanced_degree_categories = [\n    'Master\\'s Degree',\n    'Professional Degree',\n    'Doctorate Degree'\n]\n# Filter for advanced degree holders in census data\ncensus_with_degrees = census_proj[census_proj['education'].isin(advanced_degree_categories)].copy()\n# Calculate advanced degree proportion\ncensus_with_degrees['num_degrees'] = census_with_degrees['education'].map({\n    'Master\\'s Degree': 1,\n    'Professional Degree': 1,\n    'Doctorate Degree': 1\n})\ncensus_with_degrees['num_people'] = census_with_degrees['total_population']\ncensus_with_degrees['degree_proportion'] = census_with_degrees['num_degrees'] / census_with_degrees['num_people']\n# Get top 20% of neighborhoods by advanced degree proportion\ntop_neighborhoods = census_with_degrees.nlargest(int(len(census_with_degrees) * 0.2), 'degree_proportion')\n# Filter parcels by neighborhood\nparcels_in_top_neighborhoods = parcels_proj[parcels_proj['neighborhood'].isin(top_neighborhoods['neighborhood'])]\n# Sort by ml (parcel ID)\nresult_parcels = parcels_in_top_neighborhoods.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Demographic_Constraints",
    "Subcategory": "Income Levels"
  },
  {
    "Query": "find parcels located in census tracts with at least 35% educational attainment",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define educational attainment\neducational_attainment = [\n    'Bachelors Degree', 'Masters Degree', 'Professional Degree', 'Doctorate Degree'\n]\n# Filter for parcels in census tracts with at least 35% educational attainment\n# Calculate educational attainment percentage\nfor edu in educational_attainment:\n    census_proj[edu] = census_proj['education'].apply(lambda x: x.get(edu, 0) if isinstance(x, dict) else 0)\ncensus_proj['total_grads'] = census_proj[educational_attainment].sum(axis=1)\ncensus_proj['educational_attainment_pct'] = census_proj['total_grads'] / census_proj['total']\n# Filter by educational attainment\ncensus_filtered = census_proj[census_proj['educational_attainment_pct'] >= 0.35]\n# Spatial join with parcels\nparcels_with_high_attainment = gpd.sjoin(\n    parcels_proj,\n    census_filtered,\n    how='inner',\n    predicate='within'\n)\n# Sort by parcel ID\nresult_parcels = parcels_with_high_attainment.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(result_ids)",
    "Answer": "[\"Error: 'education\"]",
    "Category": "Demographic_Constraints",
    "Subcategory": "Income Levels"
  },
  {
    "Query": "find parcels in areas where at least 25% of residents are aged 18-64",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define function to filter by age group\ndef filter_by_age_group(parcel_geom, parcels_proj, census_proj, age_range=(18, 64), tolerance=100):\n    # Buffer parcel geometry\n    buffered_geom = parcel_geom.buffer(tolerance)\n    \n    # Find nearby census tracts\n    nearby_census = census_proj[census_proj.geometry.intersects(buffered_geom)].copy()\n    \n    # Calculate age group percentage\n    if not nearby_census.empty:\n        # Calculate total population\n        total_pop = (nearby_census['pct_total'] * nearby_census['estimate_total']).sum() / 100\n        \n        # Calculate population in age group\n        age_group_col = f'pct_{age_range[0]}_{age_range[1]}'\n        if age_group_col in nearby_census:\n            age_group_pop = (nearby_census[age_group_col] * nearby_census['estimate_total']).sum() / 100\n        else:\n            # Estimate if specific age group percentage is not available\n            # Use general working-age percentage (approx. 65% of total)\n            working_age_pct = 0.65\n            age_group_pop = total_pop * working_age_pct\n        \n        # Calculate percentage of residents in age group\n        age_group_pct = (age_group_pop / total_pop) * 100 if total_pop > 0 else 0\n        \n        # Check if percentage meets criteria (at least 25%)\n        if age_group_pct >= 25:\n            return True\n    \n    return False\n# Filter parcels based on age group criteria\nfiltered_parcels = []\nfor idx, row in parcels_proj.iterrows():\n    if filter_by_age_group(row.geometry, parcels_proj, census_proj):\n        filtered_parcels.append(row['ml'])\n# Sort results by parcel ID\nfiltered_parcels.sort()\n# Convert to original CRS\nfiltered_parcels = [parcels_proj.loc[parcels_proj['ml'] == ml].to_crs(parcels.crs).iloc[0] for ml in filtered_parcels]\n# Print results\nresult_ids = [row['ml'] for row in filtered_parcels]\nprint(f",
    "Answer": null,
    "Category": "Demographic_Constraints",
    "Subcategory": "Income Levels"
  },
  {
    "Query": "find parcels in neighborhoods with above-average educational attainment",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define neighborhoods based on CAMBRIDGE_POLY\ncambridge_poly = cambridge_polygon.iloc[0]['geometry']\n# Filter for educational attainment\nedu_cols = ['pct_bachelors', 'pct_grads']\ncensus_proj['educational_attainment'] = census_proj[edu_cols].mean(axis=1)\n# Find neighborhoods with above-average educational attainment\naverage_attainment = census_proj['educational_attainment'].mean()\nhigh_edu_neighborhoods = census_proj[census_proj['educational_attainment'] > average_attainment]\n# Filter parcels by neighborhood\nparcels_in_high_edu_neighborhoods = []\nfor idx, neighborhood in high_edu_neighborhoods.iterrows():\n    # Select parcels within 100m of neighborhood centroid\n    centroid = neighborhood['geometry'].centroid\n    # Filter by proximity\n    nearby_parcels = parcels_proj[parcels_proj.geometry.distance(centroid) <= 100]\n    parcels_in_high_edu_neighborhoods.append(nearby_parcels)\n# Combine results\nresult_parcels = pd.concat(parcels_in_high_edu_neighborhoods)\n# Remove duplicates\nresult_parcels = result_parcels.drop_duplicates()\n# Sort by parcel ID\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Demographic_Constraints",
    "Subcategory": "Income Levels"
  },
  {
    "Query": "find parcels in areas with at least 32% of residents holding advanced degrees",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define advanced degree percentage\nadvanced_degree_threshold = 0.32\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Filter for parcels with residential use codes\nresidential_codes = [\n    '101', '1014', '102', '1024', '104', '109', '1094', '1095', '1098',\n    '942', '9424', '943', '9434', '950', '951', '952', '953', '954', \n    '956', '957', '970', '9700', '971', '9714', '972', '974', '975'\n]\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_codes)].copy()\n# Filter for census tracts with high educational attainment\nhigh_education_tracts = census_proj[census_proj['pct_adv_deg'] >= advanced_degree_threshold]['tract'].tolist()\n# Filter by location\nparcels_in_high_education_areas = residential_parcels[residential_parcels['tract'].isin(high_education_tracts)].copy()\n# Sort by parcel ID\nresult_ids = parcels_in_high_education_areas['ml'].tolist()\nresult_ids.sort()\n# Print results\nprint(f",
    "Answer": null,
    "Category": "Demographic_Constraints",
    "Subcategory": "Income Levels"
  },
  {
    "Query": "find parcels in tracts where at least 45% of the population is aged 18-64",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define age group for 18-64\nage_18_64 = [\n    '0018_001', '0018_002', '0018_003', '0018_004', '0018_005',\n    '0020_001', '0020_002', '0020_003', '0020_004', '0020_005',\n    '0021_001', '0021_002', '0021_003', '0021_004', '0021_005',\n    '0022_001', '0022_002', '0022_003', '0022_004', '0022_005',\n    '0302_001', '0302_002', '0302_003', '0302_004', '0302_005',\n    '0303_001', '0303_002', '0303_003', '0303_004', '0303_005',\n    '0401_001', '0401_002', '0401_003', '0401_004', '0401_005',\n    '0402_001', '0402_002', '0402_003', '0402_004', '0402_005',\n    '0410_001', '0410_002', '0410_003', '0410_004', '0410_005',\n    '0411_001', '0411_002', '0411_003', '0411_004', '0411_005',\n    '0420_001', '0420_002', '0420_003', '0420_004', '0420_005',\n    '0501_001', '0501_002', '0501_003', '0501_004', '0501_005',\n    '0502_001', '0502_002', '0502_003', '0502_004', '0502_005',\n    '0510_001', '0510_002', '0510_003', '0510_004', '0510_005',\n    '0511_001', '0511_002', '0511_003', '0511_004', '0511_005',\n    '0520_001', '0520_002', '0520_003', '0520_004', '0520_005',\n    '9999_001'\n]\n# Calculate total population and 18-64 population for each tract\ncensus_proj['total_pop'] = census_proj['pop']\ncensus_proj['pop_18_64'] = sum(census_proj[age] for age in age_18_64)\ncensus_proj['pct_18_64'] = census_proj['pop_18_64'] / census_proj['total_pop']\n# Filter for tracts with at least 45% of population aged 18-64\ntracts_45_pct_18_64 = census_proj[census_proj['pct_18_64'] >= 0.45]\n# Find eligible parcels in those tracts\neligible_parcels = parcels_proj[parcels_proj['tract'].isin(tracts_45_pct_18_64['tract'])]\n# Sort by parcel ID\nresult_ids = eligible_parcels['ml'].sort_values().tolist()\n# Convert back to original CRS\nresult_ids = sorted(result_ids)\n# Output results\nprint(f\"Found {len(eligible_parcels)} parcels in tracts with at least 45% of population aged 18-64\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: 'pop\"]",
    "Category": "Demographic_Constraints",
    "Subcategory": "Income Levels"
  },
  {
    "Query": "find parcels in areas consistently ranking high for educational attainment",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Convert to projected CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Filter for educational attainment in census data\n# Consistently high educational attainment: \n# - At least 50% with bachelor's degree or higher\n# - At least 80% with high school diploma\n# (Using 2016-2020 ACS data)\nhigh_education_census = census_proj[\n    (census_proj['pct_bachelors'] >= 50) & \n    (census_proj['pct_highschool'] >= 80)\n].copy()\n# Spatial join: \n# - Find all parcels in high educational attainment areas\n# - Use 5-minute walk buffer (approx. 400m)\nbuffer_distance = 400  # meters\nhigh_education_geom = high_education_census.geometry.unary_union\nparcels_near_high_education = parcels_proj[\n    parcels_proj.geometry.intersects(high_education_geom.buffer(buffer_distance))\n].copy()\n# Sort by proximity to high education areas\n# (Optional: could also sort by degree of 'high education' if multiple areas)\nparcels_near_high_education = parcels_near_high_education.sort_values('ml')\n# Convert back to original CRS\nparcels_near_high_education = parcels_near_high_education.to_crs(parcels.crs)\n# Output results\nresult_ids = parcels_near_high_education['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Demographic_Constraints",
    "Subcategory": "Income Levels"
  },
  {
    "Query": "find parcels in neighborhoods with the top 20% of advanced degree holders",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define advanced degree holders (master's, professional, doctoral) in ACS 2017 5-year estimates\nADVANCED_DEGREE_CODES = ['023', '024', '034']\n# Filter for advanced degree holders in the census data\ncensus_advanced = census_proj[census_proj['variable'].astype(str).isin(ADVANCED_DEGREE_CODES)]\n# Calculate top 20% neighborhoods by advanced degree rate\n# First, calculate the rate of advanced degree holders\ncensus_advanced = census_advanced.copy()\ncensus_advanced['advanced_degree_rate'] = census_advanced['estimate'] / census_advanced['total']\n# Get the top 20% of neighborhoods by advanced degree rate\ntop_20_pct_threshold = census_advanced['advanced_degree_rate'].quantile(0.8)\ntop_neighborhoods = census_advanced[census_advanced['advanced_degree_rate'] >= top_20_pct_threshold]\n# Filter parcels by location in top neighborhoods\nparcels_in_top_neighborhoods = parcels_proj[parcels_proj['neighborhood'].isin(top_neighborhoods['neighborhood'])]\n# Sort by parcel ID for consistency\nresult_ids = sorted(parcels_in_top_neighborhoods['ml'].tolist())\n# Convert back to original CRS\nparcels_in_top_neighborhoods = parcels_in_top_neighborhoods.to_crs(parcels.crs)\n# Output results\nprint(f",
    "Answer": null,
    "Category": "Demographic_Constraints",
    "Subcategory": "Income Levels"
  },
  {
    "Query": "find parcels in areas where at least 70% of residents are aged 18-64",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define function to calculate resident age distribution\ndef calculate_age_distribution(ml, parcels, census):\n    # Get parcel location\n    parcel_geom = parcels.loc[parcels['ml'] == ml, 'geometry'].values[0]\n    \n    # Find nearby residents (within 300ft)\n    buffer = parcel_geom.buffer(300)  # 300ft buffer\n    nearby_census = census[census.geometry.intersects(buffer)].copy()\n    \n    # Calculate age distribution\n    if not nearby_census.empty:\n        # Use weighted average of age groups\n        total_population = (nearby_census['estimate_total'] + \n                            nearby_census['estimate_total_moe']).sum() / 2\n        if total_population > 0:\n            age_18_64 = (nearby_census['estimate_age18to64'] + \n                         nearby_census['estimate_age18to64_moe']).sum() / 2\n            age_distribution = age_18_64 / total_population\n        else:\n            age_distribution = 0\n    else:\n        age_distribution = 0\n    \n    return age_distribution\n# Calculate age distribution for each parcel\nmls = parcels_proj['ml'].tolist()\nage_distributions = [calculate_age_distribution(ml, parcels_proj, census_proj) for ml in mls]\nparcels_proj['age_distribution'] = age_distributions\n# Filter for parcels in areas with at least 70% residents aged 18-64\nresult_parcels = parcels_proj[parcels_proj['age_distribution'] >= 0.7].copy()\n# Sort by parcel ID\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Demographic_Constraints",
    "Subcategory": "Target Demographic Match"
  },
  {
    "Query": "find parcels where percentage of residents with advanced degrees is above 40%",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define function to get residents with advanced degrees\ndef get_advanced_degree_pct(ml, parcels, census):\n    # Get parcel location\n    parcel = parcels.loc[parcels['ml'] == ml]\n    if parcel.empty:\n        return None\n    # Find relevant census tract\n    parcel_geom = parcel.geometry.values[0]\n    # Buffer for approx. 100m\n    buffered_geom = parcel_geom.buffer(100)  \n    # Get nearby census tracts\n    nearby_census = census[census.geometry.intersects(buffered_geom)].copy()\n    # Calculate advanced degree percentage\n    if 'pct_adv_deg' in nearby_census.columns:\n        pct_adv_deg = nearby_census['pct_adv_deg'].mean()\n        return pct_adv_deg\n    return None\n# Filter parcels based on advanced degree percentage\n# First, get all ml values\nml_values = parcels_proj['ml'].tolist()\n# Calculate advanced degree percentage for each parcel\npct_adv_degrees = [get_advanced_degree_pct(ml, parcels_proj, census_proj) for ml in ml_values]\n# Filter by advanced degree percentage\nresult_parcels = []\nfor i, pct in enumerate(pct_adv_degrees):\n    if pct is not None and pct > 40:\n        result_parcels.append(ml_values[i])\n# Sort by ml (parcel ID)\nresult_parcels.sort()\n# Print results\nprint(f",
    "Answer": null,
    "Category": "Demographic_Constraints",
    "Subcategory": "Target Demographic Match"
  },
  {
    "Query": "find parcels in neighborhoods with highest concentration of working-age adults",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate distance calculations\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define working-age adult criteria\nworking_age_adult_columns = [\n    'pct_18_24', 'pct_25_34', 'pct_35_44', \n    'pct_45_54', 'pct_55_64'\n]\n# Calculate working-age adult concentration\ncensus_proj['working_age_adult_pct'] = (\n    census_proj[working_age_adult_columns].sum(axis=1)\n)\n# Sort by concentration of working-age adults (higher is better)\ncensus_proj = census_proj.sort_values('working_age_adult_pct', ascending=False)\n# Define top 20% neighborhoods\ntop_neighborhoods = census_proj.head(int(len(census_proj) * 0.2))\n# Filter parcels by location in top neighborhoods\nparcels_in_top_neighborhoods = gpd.sjoin(\n    parcels_proj,\n    top_neighborhoods,\n    how='inner',\n    predicate='within'\n)\n# Sort by parcel ID for consistency\nresult_ids = sorted(parcels_in_top_neighborhoods['ml'].tolist())\n# Print results\nprint(result_ids)",
    "Answer": "[\"pct_18_24\", \"pct_25_34\", \"pct_35_44\", \"pct_45_54\", \"pct_55_64\"]",
    "Category": "Demographic_Constraints",
    "Subcategory": "Target Demographic Match"
  },
  {
    "Query": "find parcels in areas with at least 65% of residents aged 18-64",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define function to filter by age group\ndef filter_by_age_group(parcel_geom, census_data, age_range=(18, 64)):\n    # Get centroid of parcel\n    centroid = parcel_geom.centroid\n    # Buffer by 200m for local area\n    local_geom = centroid.buffer(200)\n    # Filter census data by location\n    local_census = census_data[census_data.geometry.intersects(local_geom)].copy()\n    # Calculate age group\n    if len(local_census) == 0:\n        return False\n    # Check if age group is present\n    if 'pct_18_64' in local_census.columns:\n        # Use directly if available\n        age_pct = local_census['pct_18_64'].values[0]\n    else:\n        # Estimate if not available\n        age_pct = local_census['pct_age_18_64'].values[0] if 'pct_age_18_64' in local_census.columns else 0\n    # Check if within range\n    return age_pct >= 65\n# Filter parcels by age group\nfiltered_parcels = []\nfor idx, row in parcels_proj.iterrows():\n    if filter_by_age_group(row.geometry, census_proj):\n        filtered_parcels.append(row['ml'])\n# Sort by parcel ID\nfiltered_parcels.sort()\n# Convert back to original CRS\nfiltered_parcels = [str(pid) for pid in filtered_parcels]\n# Print results\nprint(f\"Found {len(filtered_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {filtered_parcels}\")",
    "Answer": "[\"Found 0 parcels meeting criteria\", \"Parcel IDs:\"]",
    "Category": "Demographic_Constraints",
    "Subcategory": "Target Demographic Match"
  },
  {
    "Query": "find parcels where percentage of residents with advanced degrees is between 35% and 40%",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define function to calculate advanced degree percentage\ndef calculate_advanced_degree_percentage(educational_attainment):\n    if pd.isna(educational_attainment):\n        return 0\n    parts = educational_attainment.split(',')\n    advanced_degrees = 0\n    total_degrees = 0\n    for part in parts:\n        part = part.strip()\n        if 'Doctorate' in part or 'Master\\'s' in part:\n            advanced_degrees += int(part.split()[0])\n        elif 'Bachelor\\'s' in part:\n            total_degrees += int(part.split()[0])\n        elif 'Associate' in part:\n            total_degrees += int(part.split()[0])\n    total_degrees += advanced_degrees\n    return advanced_degrees / total_degrees if total_degrees > 0 else 0\n# Calculate advanced degree percentage for each census tract\ncensus_proj['advanced_degree_pct'] = census_proj['educational_attainment'].apply(calculate_advanced_degree_percentage)\n# Filter for advanced degree percentage between 35% and 40%\nfiltered_census = census_proj[(census_proj['advanced_degree_pct'] >= 0.35) & (census_proj['advanced_degree_pct'] <= 0.40)]\n# Convert back to original CRS\nfiltered_census = filtered_census.to_crs(parcels.crs)\n# Find matching parcels\nmatching_parcels = parcels[parcels['ml'].isin(filtered_census['tract'])]\n# Sort by parcel ID\nmatching_parcels = matching_parcels.sort_values('ml')\n# Output results\nresult_ids = matching_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Demographic_Constraints",
    "Subcategory": "Target Demographic Match"
  },
  {
    "Query": "find parcels in areas with at least 75% of residents aged 18-64",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define function to filter by age group\ndef filter_by_age_group(parcel_geom, census_geoms, target_pct, age_range, tolerance=100): \n    # Expand parcel geometry by tolerance\n    buffered_geom = parcel_geom.buffer(tolerance)\n    \n    # Find relevant census tracts within buffered area\n    relevant_census = census_geoms[census_geoms.geometry.intersects(buffered_geom)].copy()\n    \n    if relevant_census.empty:\n        return False  # No relevant census, can't meet criteria\n    \n    # Calculate age group percentage\n    total_population = ( \n        relevant_census['total_population'].sum() \n    ) \n    if total_population == 0: \n        return False  # Avoid division by zero\n    \n    age_group_population = ( \n        relevant_census['pct_age_18_64'].mean() * total_population / 100 \n    ) \n    age_group_pct = age_group_population / total_population * 100\n    \n    # Check if percentage meets target\n    return age_group_pct >= target_pct\n# Filter parcels based on age group criteria\ntarget_pct = 75\nage_range = (18, 64)\nfiltered_parcels = []\nfor idx, row in parcels_proj.iterrows():\n    if filter_by_age_group(row.geometry, census_proj.geometry, target_pct, age_range):\n        filtered_parcels.append(row['ml'])\n# Sort by parcel ID\nfiltered_parcels.sort()\n# Print results\nprint(f\"Found {len(filtered_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {filtered_parcels}\")",
    "Answer": "[\"Error: 'total_population\"]",
    "Category": "Demographic_Constraints",
    "Subcategory": "Target Demographic Match"
  },
  {
    "Query": "find parcels where percentage of residents with advanced degrees is above 30%",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define project CRS for Cambridge\ncambridge_crs = 26986\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Filter for ML (parcel ID) consistently\nparcels_ml = parcels_proj['ml'].astype(str)\ncensus_ml = census_proj['ml'].astype(str)\n# Combine data on ML\ncombined = (\n    census_proj[census_proj['ml'].astype(str).isin(parcels_ml)].copy()\n)\n# Filter by advanced degree percentage\nadvanced_degree_col = 'pct_adv_deg'\nif advanced_degree_col in combined.columns:\n    result = combined[combined[advanced_degree_col] > 30].copy()\nelse:\n    raise ValueError(\"Advanced degree percentage column not found in census data\")\n# Sort by parcel ID\nresult = result.sort_values('ml')\n# Convert back to original CRS\nresult = result.to_crs(parcels.crs)\n# Output results\nresult_ids = result['ml'].astype(str).tolist()\nprint(f\"Found {len(result)} parcels with >30% advanced degrees\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Demographic_Constraints",
    "Subcategory": "Target Demographic Match"
  },
  {
    "Query": "find parcels in neighborhoods with high concentration of working-age adults, defined as 60% or more aged 18-64",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define function to filter by working-age adult concentration\ndef has_high_working_age_adults(parcel_geom, census_geoms, threshold=0.6):\n    # Find nearby census tracts (within 400m)\n    buffered_geom = parcel_geom.buffer(400)\n    nearby_census = [geom for geom in census_geoms if buffered_geom.contains(geom)]\n    \n    if not nearby_census:\n        return False\n    \n    # Calculate working-age adult ratio for each nearby census tract\n    for geom in nearby_census:\n        # Extract relevant data\n        total_population = geom['total_population']\n        working_age_adults = geom['working_age_adults']\n        \n        if total_population > 0:\n            ratio = working_age_adults / total_population\n            if ratio >= threshold:\n                return True\n    return False\n# Calculate working-age adult concentration for each parcel\ncensus_geoms = census_proj.geometry.tolist()\nparcels_proj = parcels_proj.copy()\nparcels_proj['high_working_age'] = parcels_proj.geometry.apply(\n    lambda geom: has_high_working_age_adults(geom, census_geoms)\n)\n# Filter for parcels in areas with high working-age adult concentration\nresult_parcels = parcels_proj[parcels_proj['high_working_age']].copy()\n# Sort by parcel ID (ml column)\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Demographic_Constraints",
    "Subcategory": "Target Demographic Match"
  },
  {
    "Query": "find parcels in areas with at least 68% of residents aged 18-64",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define function to filter by age group\ndef filter_by_age_group(parcel_geom, census_geoms, target_pct, age_range, tolerance=0):\n    # Calculate age group key\n    if age_range == (18, 64):\n        age_key = 'pct_age_18_64'\n    else:\n        raise ValueError(\"Unsupported age range\")\n    \n    # Find nearby census tracts\n    if tolerance > 0:\n        buffered_geom = parcel_geom.buffer(tolerance)\n    else:\n        buffered_geom = parcel_geom\n    \n    # Filter census tracts by proximity\n    nearby_census = census_geoms[census_geoms.geometry.intersects(buffered_geom)].copy()\n    \n    # If no nearby census, return empty result\n    if nearby_census.empty:\n        return False\n    \n    # Check age group percentage\n    pct_age_group = nearby_census.iloc[0][age_key]\n    return pct_age_group >= target_pct\n# Filter parcels based on age group criteria\n# At least 68% of residents aged 18-64\ntarget_pct = 68\nage_range = (18, 64)\ntolerance = 100  # 100m tolerance\nfiltered_parcels = []\nfor idx, row in parcels_proj.iterrows():\n    if filter_by_age_group(row.geometry, census_proj, target_pct, age_range, tolerance):\n        filtered_parcels.append(row['ml'])\n# Sort by parcel ID\nfiltered_parcels.sort()\n# Convert to original CRS\nfiltered_parcels = [parcels.loc[parcels_proj['ml'] == ml].iloc[0] for ml in filtered_parcels]\nfiltered_parcels = gpd.GeoDataFrame(filtered_parcels, crs=parcels.crs)\n# Print results\nresult_ids = filtered_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Demographic_Constraints",
    "Subcategory": "Target Demographic Match"
  },
  {
    "Query": "find parcels where percentage of residents with advanced degrees is above 45%",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Filter for residential parcels\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith(('1', '2', '3', '4', '5'))]\n# Filter for advanced degree percentage\nhigh_education_census = census_proj[census_proj['pct_adv_deg'] > 45]\n# Spatial join: assign residents' education level to each parcel\nresidential_with_education = gpd.sjoin(\n    residential_parcels,\n    high_education_census,\n    how='left',\n    predicate='within'\n)\n# Filter for parcels that meet education criterion\neducated_parcels = residential_with_education[residential_with_education.index_right.notnull()]\n# Sort by parcel ID\nresult_parcels = educated_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Demographic_Constraints",
    "Subcategory": "Target Demographic Match"
  }
]