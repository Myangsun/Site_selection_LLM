[
  {
    "Query": "find parcels larger than 10000 square feet",
    "Code": "import geopandas as gpd\n\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\n\n# Filter by size: large parcels (>10,000 sq ft)\nlarge_parcels = parcels_proj[parcels_proj['land_area'] > 10000]\n\n# Sort by ml (parcel ID) for consistency\nlarge_parcels = large_parcels.sort_values('ml')\n\n# Convert back to original CRS\nlarge_parcels = large_parcels.to_crs(parcels.crs)\n\n# Extract parcel IDs\nlarge_parcel_ids = large_parcels['ml'].tolist()\n\n# Print results\nprint(large_parcel_ids)",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Hard Constraint"
  },
  {
    "Query": "find retail parcels (use_code starting with '32')",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Convert to projected CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\n# Define retail use codes\nretail_use_codes = [320, 321, 323, 324, 325, 326, 327, 328, 330]\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith('32')]\n# Sort by parcel ID\nretail_parcels = retail_parcels.sort_values('ml')\n# Convert back to original CRS\nretail_parcels = retail_parcels.to_crs(parcels.crs)\n# Output results\nretail_ids = retail_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Simple_Constraints",
    "Subcategory": "Single Hard Constraint"
  },
  {
    "Query": "find office parcels (use_code starting with '34')",
    "Code": "import geopandas as gpd\n\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n\n# Define office use codes\noffice_use_codes = [\n    '340', '3400', '341', '3410', '342', '3420', '343', '3430', \n    '344', '3440', '345', '3450', '346', '3460', '347', '3470',\n    '348', '3480', '34', '34000', '34100', '34200', '34300',\n    '34400', '34500', '34600', '34700', '34800'\n]\n\n# Filter for Cambridge, MA (specific location)\ncambridge_parcels = parcels[parcels['ml'].astype(str).str.startswith('34')].copy()\n\n# Sort by parcel ID\nresult_ids = cambridge_parcels['ml'].tolist()\nresult_ids.sort()\n\n# Output results\nprint(f\"Found {len(cambridge_parcels)} office parcels in Cambridge, MA\")\nprint(\"Parcel IDs:\", result_ids)",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Hard Constraint"
  },
  {
    "Query": "find residential parcels (use_code starting with '01')",
    "Code": "import geopandas as gpd\n\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspending = pd.read_csv('data/cambridge_spend_processed.csv')\n\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n\n# Define residential use codes\nresidential_use_codes = [str(code).zfill(6) for code in range(1, 200)]\n\n# Filter for residential parcels\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith('01')].copy()\n\n# Sort by parcel ID (ml)\nresult_ids = sorted(residential_parcels['ml'].tolist())\n\n# Print results\nprint(result_ids)",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Hard Constraint"
  },
  {
    "Query": "find mlmlarger than 3000 square feet within 500m of harvard square",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define Harvard Square location\nharvard_square = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy(-71.1189, 42.3736)],\n    crs=parcels.crs\n)\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\nharvard_square_proj = harvard_square.to_crs(epsg=26986)\n# Filter for large mlmlarger than 3000 sq ft\nlarge_parcels = parcels_proj[parcels_proj['ml'] > 3000].copy()\n# Create 500m buffer around Harvard Square\nharvard_buffer = harvard_square_proj.buffer(500)[0]\n# Filter large parcels by proximity to Harvard Square\nresult_parcels = large_parcels[large_parcels.geometry.intersects(harvard_buffer)].copy()\n# Sort by ml (parcel ID)\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels mlmlarger than 3000 sqft within 500m of Harvard Square\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: 'data' should be array of geometry objects. Use from_shapely, from_wkb, from_wkt functions to construct a GeometryArray.\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Hard Constraint"
  },
  {
    "Query": "find parcels zoned for educational uses (use_code '42')",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\n# Filter for educational use (use_code '42')\neducational_parcels = parcels_proj[parcels_proj['use_code'] == '42']\n# Sort by parcel ID (ml column)\nresult_ids = educational_parcels['ml'].sort_values().tolist()\n# Print results\nprint(result_ids)",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Hard Constraint"
  },
  {
    "Query": "find industrial parcels (use_code starting with '40')",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\n# Define industrial use codes\nindustrial_use_codes = [ '400', '404', '406', '410', '412', '413', '414', '415', '416', '417', '418', '419' ]\n# Filter for industrial parcels\nindustrial_parcels = parcels[parcels['use_code'].astype(str).str.startswith('40')]\n# Sort by parcel ID (ml)\nresult_ids = industrial_parcels['ml'].sort_values().tolist()\n# Print results\nprint(result_ids)",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Hard Constraint"
  },
  {
    "Query": "find parcels with land_area between 1500 and 4000 sq ft",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Convert to projected CRS for accurate analysis\nparcels_proj = parcels.to_crs(cambridge_crs)\n# Filter by land area\narea_filtered_parcels = parcels_proj[\n    (parcels_proj['land_area'] >= 1500) & (parcels_proj['land_area'] <= 4000)\n]\n# Sort by ml (parcel ID) for consistency\nresult_parcels = area_filtered_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels with land area between 1500 and 4000 sq ft\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Hard Constraint"
  },
  {
    "Query": "find large residential parcels (larger than 6000 sq ft)",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\n# Define residential use codes\nresidential_use_codes = [\n    '101', '1014', '102', '1028', '104', '109', '1094', '1095', '1098',\n    '121', '970', '942', '9420', '943', '9430', '946', '9460', '947',\n    '9470', '151', '152', '153', '840', '841', '3454'\n]\n# Filter for residential parcels\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_use_codes)].copy()\n# Filter large residential parcels (>6000 sq ft)\nlarge_residential = residential_parcels[residential_parcels['land_area'] > 6000].copy()\n# Sort by parcel ID (ml)\nresult_ids = large_residential['ml'].sort_values().tolist()\n# Print results\nprint(result_ids)",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Hard Constraint"
  },
  {
    "Query": "find mlmlarger than 8000 square feet",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\n# Filter for large parcels (>8000 sq ft)\nlarge_parcels = parcels_proj[parcels_proj['land_area'] > 8000]\n# Sort by parcel ID (ml)\nresult_ids = large_parcels['ml'].sort_values().tolist()\n# Print results\nprint(result_ids)",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Hard Constraint"
  },
  {
    "Query": "find retail parcels between 2500 and 4500 square feet",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Filter for retail parcels\nretail_parcels = parcels[parcels['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Filter by size\nsize_filtered_parcels = retail_parcels[\n    (retail_parcels['land_area'] >= 2500) & (retail_parcels['land_area'] <= 4500)\n].copy()\n# Sort by ml (parcel ID)\nresult_parcels = size_filtered_parcels.sort_values('ml')\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(result_ids)",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Hard Constraint"
  },
  {
    "Query": "find commercial parcels (use_code starting with '3') larger than 5000 sq ft",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 'EPSG:26986'\n# Convert to projected CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\n# Filter for commercial use codes (starting with '3')\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith('3')]\n# Filter for parcels larger than 5000 sq ft\nlarge_commercial_parcels = commercial_parcels[commercial_parcels['land_area'] > 5000]\n# Sort by parcel ID (ml)\nresult_parcels = large_commercial_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(result_ids)",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Hard Constraint"
  },
  {
    "Query": "find large office parcels (use_code starting with '34') larger than 6000 sq ft",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\n# Define large office use codes\nlarge_office_use_codes = ['340', '341', '343', '345', '346', '347', '348', '349']\n# Filter for large office parcels larger than 6000 sq ft\nlarge_office_parcels = parcels[\n    (parcels['use_code'].astype(str).str.startswith('34')) &\n    (parcels['land_area'] > 6000)\n].copy()\n# Sort by parcel ID (ml)\nresult_ids = large_office_parcels['ml'].tolist()\nresult_ids.sort()\n# Print results\nprint(result_ids)",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Hard Constraint"
  },
  {
    "Query": "find mlmlarger than 10000 sq ft near cambridge common",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define Cambridge Common location\ncambridge_common = poi[poi['name'].str.contains(\"Cambridge Common\", case=False)].iloc[0]\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\n# Filter for large parcels (>10000 sq ft)\nlarge_parcels = parcels_proj[parcels_proj['land_area'] > 10000].copy()\n# Calculate distance to Cambridge Common\nlarge_parcels['distance_to_common'] = large_parcels.geometry.distance(cambridge_common.geometry)\n# Sort by proximity to Cambridge Common\nresult_parcels = large_parcels.sort_values('distance_to_common')\n# Extract parcel IDs (ml) for final output\nresult_ids = result_parcels['ml'].tolist()\n# Print results\nprint(result_ids)",
    "Answer": "[\"Error: single positional indexer is out-of-bounds\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Hard Constraint"
  },
  {
    "Query": "find commercial parcels ideally located near popular retail areas, such as harvard square or kendall square.",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels[parcels['use_code'].astype(str).isin(commercial_use_codes)].copy()\n# Define Harvard Square and Kendall Square locations\nharvard_square = cambridge_location(42.373611, -71.118956)\nkendall_square = cambridge_location(42.362490, -71.086176)\n# Convert to projected CRS for accurate distance measurement\ncommercial_parcels_proj = commercial_parcels.to_crs(epsg=26986)\nharvard_square_proj = harvard_square.to_crs(epsg=26986)\nkendall_square_proj = kendall_square.to_crs(epsg=26986)\n# Calculate distance to Harvard Square and Kendall Square\ncommercial_parcels_proj['dist_to_harvard'] = commercial_parcels_proj.geometry.distance(harvard_square_proj.iloc[0])\ncommercial_parcels_proj['dist_to_kendall'] = commercial_parcels_proj.geometry.distance(kendall_square_proj.iloc[0])\n# Prioritize parcels that are closer to either location\n# Use a weighted approach: 70% weight on Harvard distance, 30% on Kendall distance\ncommercial_parcels_proj['distance_score'] = (\n    0.7 * commercial_parcels_proj['dist_to_harvard'] +\n    0.3 * commercial_parcels_proj['dist_to_kendall']\n)\n# Sort by proximity to retail areas (lower score is better)\nresult_parcels = commercial_parcels_proj.sort_values('distance_score')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Get top 10 results\ntop_parcels = result_parcels.head(10)\n# Output results\nresult_ids = top_parcels['ml'].tolist()\nprint(f\"Found {len(top_parcels)} parcels near retail areas\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: name 'cambridge_location' is not defined\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Soft Constraint"
  },
  {
    "Query": "locate office parcels with at least 4000 sq ft of land area, preferably in areas with high educational attainment.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Convert to projected CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Filter for office parcels (ml codes for office)\noffice_ml_codes = ['300', '302', '316', '323', '324', '325', '326', '327', '330', '332', '334', '340', '341', '343', '345', '346', '353', '362', '375']\noffice_parcels = parcels_proj[parcels_proj['ml'].astype(str).isin(office_ml_codes)].copy()\n# Filter by land area (at least 4000 sq ft)\nlarge_office_parcels = office_parcels[office_parcels['land_area'] >= 4000].copy()\n# Spatial join with census data for educational attainment\nparcels_with_census = gpd.sjoin_nearest(\n    large_office_parcels,\n    census_proj,\n    how='left',\n    distance_col='distance',\n    max_distance=100,  # 100 ft\n)\n# Prioritize areas with high educational attainment\n# Assuming 'pct_bachelors' is a measure of educational attainment\nif 'pct_bachelors' in parcels_with_census.columns:\n    # Sort by educational attainment (higher is better)\n    prioritized_parcels = parcels_with_census.sort_values('pct_bachelors', ascending=False)\nelif 'pct_degree' in parcels_with_census.columns:\n    # If 'pct_degree' exists, use it instead\n    prioritized_parcels = parcels_with_census.sort_values('pct_degree', ascending=False)\nelse:\n    # If no educational attainment metric is available, just take as-is\n    prioritized_parcels = parcels_with_census.copy()\n# Convert back to original CRS\nfinal_parcels = prioritized_parcels.to_crs(parcels.crs)\n# Sort by ml for consistent output\nfinal_parcels = final_parcels.sort_values('ml')\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} office parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Soft Constraint"
  },
  {
    "Query": "search for retail parcels that have been recently renovated, prioritizing those in areas with high foot traffic.",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Filter for retail parcels\nretail_parcels = parcels[parcels['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Filter for recently renovated parcels (within 5 years of 2023)\nrecent_renovation = (\n    (retail_parcels['last_renovation_date'].notnull()) &\n    (retail_parcels['last_renovation_date'] >= '2018-01-01')\n)\n# Filter for parcels that have been recently renovated\nretail_parcels = retail_parcels[recent_renovation].copy()\n# Set CRS for accurate distance measurement\nretail_parcels = retail_parcels.to_crs(epsg=26986)\n# Calculate foot traffic as a proxy using POI density\n# Buffer each retail parcel by 100 meters\nbuffers = retail_parcels.geometry.buffer(100)\n# Assign POI data to same CRS\npoi = poi.to_crs(epsg=26986)\n# Calculate foot traffic (POI count) within 100m of each parcel\ndef calculate_foot_traffic(buffer, poi):\n    return poi[poi.geometry.intersects(buffer)].shape[0]\nretail_parcels['foot_traffic'] = buffers.apply(lambda b: calculate_foot_traffic(b, poi))\n# Prioritize by foot traffic (higher is better)\nretail_parcels = retail_parcels.sort_values('foot_traffic', ascending=False)\n# Convert back to original CRS\nretail_parcels = retail_parcels.to_crs(parcels.crs)\n# Get parcel IDs\nresult_ids = retail_parcels['ml'].tolist()\n# Print results\nprint(f\"Found {len(retail_parcels)} recently renovated retail parcels\")\nprint(f\"Parcel IDs (sorted by foot traffic): {result_ids}\")",
    "Answer": "[\"Error: 'last_renovation_date\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Soft Constraint"
  },
  {
    "Query": "identify commercial parcels with unique architectural features, ideally situated on bustling streets like massachusetts avenue.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define unique architectural features\nunique_architectural_features = [\n    'Church', 'Cathedral', 'Museum', 'Theater', 'Historic Building',\n    'Landmark', 'Art Gallery', 'Library'\n]\n# Define bustling streets in Cambridge\nbustling_streets = [\n    'Massachusetts Avenue', 'Cambridge Street', 'Washington Street',\n    'Main Street', 'Harvard Street', 'Somerville Avenue', 'Dudley Street'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels[parcels['use_code'].astype(str).str.startswith(('3', '31', '32', '33'))]\n# Filter for unique architectural features\npoi_with_unique_features = poi[poi['feature_type'].isin(unique_architectural_features)]\n# Filter for bustling street locations\nbustling_street_poi = poi[poi['street_name'].isin(bustling_streets)]\n# Convert to projected CRS for accurate distance measurement\nparcels_proj = commercial_parcels.to_crs(epsg=26986)\npoi_proj = poi_with_unique_features.to_crs(epsg=26986)\nbustling_street_poi_proj = bustling_street_poi.to_crs(epsg=26986)\n# Prioritize parcels near bustling street POI\n# Calculate distance to bustling street POI\ndef calculate_distance_to_bustling_poi(parcel_geom, bustling_poi_geoms):\n    return min(parcel_geom.distance(geom) for geom in bustling_poi_geoms)\n# Get geometries of bustling street POI\nbustling_poi_geoms = bustling_street_poi_proj['geometry'].tolist()\n# Calculate distance to bustling street POI for each parcel\nparcels_proj = parcels_proj.copy()\nparcels_proj['distance_to_bustling_poi'] = parcels_proj.geometry.apply(\n    lambda geom: calculate_distance_to_bustling_poi(geom, bustling_poi_geoms)\n)\n# Sort by proximity to bustling street POI (lower is better)\nresult_parcels = parcels_proj.sort_values('distance_to_bustling_poi')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Get top 10 parcels\ntop_parcels = result_parcels.head(10)\n# Output results\nresult_ids = top_parcels['ml'].tolist()\nprint(f\"Found {len(top_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: 'feature_type\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Soft Constraint"
  },
  {
    "Query": "find mixed-use parcels that include residential units, preferably in neighborhoods with a strong sense of community.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define mixed-use codes that include residential units\nmixed_use_codes = ['323', '324', '325', '326', '327', '330', '332', '334', '340', '341', '343', '345', '346', '353']\n# Filter for mixed-use parcels\nmixed_use_parcels = parcels[parcels['use_code'].astype(str).isin(mixed_use_codes)].copy()\n# Set CRS for accurate distance measurement\nmixed_use_parcels = mixed_use_parcels.to_crs(epsg=26986)\n# Define community-oriented business types\ncommunity_business_types = ['restaurant', 'cafe', 'grocery', 'bakery', 'pharmacy', 'retail']\n# Filter POI for community-oriented businesses\ncommunity_poi = poi[poi['business_type'].isin(community_business_types)].copy()\n# Function to calculate community score\ndef calculate_community_score(parcel_geom, poi_geoms, buffer_distance=200):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    # Count community POI within buffer\n    count = sum(1 for geom in poi_geoms if geom is not None and buffered_geom.contains(geom))\n    return count\n# Get POI geometries\ncommunity_poi_geoms = community_poi['geometry'].tolist()\n# Calculate community score for each parcel\nmixed_use_parcels['community_score'] = mixed_use_parcels.geometry.apply(\n    lambda geom: calculate_community_score(geom, community_poi_geoms)\n)\n# Sort by community score (higher is better)\nresult_parcels = mixed_use_parcels.sort_values('community_score', ascending=False)\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Get parcel IDs\nresult_ids = result_parcels['ml'].tolist()\n# Print results\nprint(f\"Found {len(result_parcels)} mixed-use parcels with residential units\")\nprint(f\"Parcel IDs (sorted by community score): {result_ids}\")",
    "Answer": "[\"1A-70\", \"168-64\", \"108-80\", \"83-80\", \"265A-31\", \"262-116\", \"196-153\", \"24-133\", \"41-36\", \"46-12\", \"1A-209\", \"1A-201\", \"168-41\", \"230-71\", \"128-72\", \"121-2\", \"169-68\", \"84-101\", \"85-66\", \"267D-299\", \"189-88\", \"134-33\", \"160-71\", \"268C-32\", \"129-55\", \"133-12\", \"166-106\", \"268B-8\", \"117-56\", \"23-146\", \"169-46\", \"252-158\", \"178-118\", \"228-33\", \"174-33\", \"267F-301\", \"267D-305\", \"84-97\", \"156-60\", \"27-34\", \"68-19\", \"162-68\", \"23-149\", \"90-127\", \"93-80\", \"199-31\", \"42-13\", \"35-34\", \"116-117\", \"11-40\", \"133-51\", \"36-137\", \"254-78\", \"184-191\", \"160-11\", \"169-42\", \"7-37\", \"122-12\", \"28-23\", \"175-37\", \"84-12\", \"100-62\", \"44-99\", \"21-121\", \"14-58\", \"169-67\", \"176-64\", \"181-80\", \"83-92\", \"150-114\", \"17-84\", \"83-98\", \"109-50\", \"183-119\", \"84-85\", \"69-161\", \"261-186\", \"133-52\", \"43-73\", \"120-74\", \"20-31\", \"234-193\", \"118-34\", \"80-51\", \"273-40\", \"133-27\", \"162-17\", \"118-1\", \"181-88\", \"90-20\", \"121-13\", \"265A-46\", \"96-110\", \"265A-40\", \"192-74\", \"169-98\", \"17-10\", \"261-77\", \"162-19\", \"160-77\", \"154-101\", \"77-41\", \"44-100\", \"254-82\", \"236-84\", \"83-1\", \"68-50\", \"159-2\", \"82-31\", \"39-88\", \"162-54\", \"41-38\", \"108-54\", \"90-52\", \"81-100\", \"271-32\", \"21-124\", \"110-91\", \"133-49\", \"191-85\", \"119-95\", \"82-57\", \"107-117\", \"15-31\", \"8-88\", \"83-15\", \"125-73\", \"91-191\", \"168-13\", \"169-7\", \"17-74\", \"267.4-305\", \"260-76\", \"125-80\", \"133-48\", \"107-136\", \"160-84\", \"229-117\", \"267D-329\", \"16-11\", \"162-64\", \"178-133\", \"129-11\", \"265C-25\", \"106-123\", \"233-175\", \"133-20\", \"162-18\", \"91-87\", \"182-88\", \"93-99\", \"267F-283\", \"47-94\", \"229-131\", \"14-47\", \"178-117\", \"230-41\", \"168-25\", \"190-33\", \"169-50\", \"265B-61\", \"96-124\", \"14-26\", \"70-74\", \"42-70\", \"1A-189\", \"168-22\", \"21-120\", \"85-76\", \"8-75\", \"236-148\", \"182-90\", \"133-14\", \"93-79\", \"18-64\", \"83-7\", \"152-25\", \"166-33\", \"102-25\", \"234-178\", \"196-123\", \"20-92\", \"267D-319\", \"160-63\", \"174-73\", \"118-79\", \"169-93\", \"93-72\", \"186-14\", \"81-103\", \"90-185\", \"254-86\", \"42-97\", \"114A-120\", \"134-59\", \"133-30\", \"268B-15\", \"191-65\", \"87-153\", \"200-22\", \"105-89\", \"105-77\", \"169-102\", \"267D-325\", \"267D-311\", \"233-147\", \"105-53\", \"1A-200\", \"226-46\", \"21-115\", \"189-4\", \"43-70\", \"152-52\", \"105-74\", \"19-23\", \"154-64\", \"70-22\", \"267E-279\", \"169-47\", \"110-90\", \"184-193\", \"260-46\", \"172-29\", \"133-33\", \"91-64\", \"192-177\", \"20-103\", \"195-59\", \"179-87\", \"156-55\", \"156-25\", \"267E-282\", \"174-27\", \"273-29\", \"191-112\", \"160-85\", \"179-42\", \"139-83\", \"70-86\", \"179-75\", \"96-152\", \"160-48\", \"39-173\", \"169-81\", \"178-43\", \"1A-105\", \"265D-53\", \"20-82\", \"106-124\", \"200-79\", \"267F-281\", \"168-60\", \"74-8\", \"160-57\", \"13-23\", \"162-67\", \"165-57\", \"105-58\", \"154-65\", \"169-99\", \"28-31\", \"162-65\", \"86-84\", \"90-161\", \"267E-234\", \"90-125\", \"43A-21\", \"93-74\", \"265A-7\", \"166-52\", \"248-82\", \"92-88\", \"178-91\", \"229-135\", \"90-133\", \"168-21\", \"96-98\", \"260-32\", \"154-89\", \"42-81\", \"13-16\", \"230-42\", \"55-18\", \"84-67\", \"166-13\", \"184-159\", \"192-75\", \"228-55\", \"10-38\", \"180-57\", \"42-87\", \"242B-998\", \"91-208\", \"75-44\", \"165-53\", \"184-109\", \"236-146\", \"110-63\", \"90-155\", \"83-90\", \"107-9\", \"74-1\", \"175-68\", \"119-90\", \"184-155\", \"9-41\", \"230-116\", \"128-63\", \"97-111\", \"162-73\", \"23-90\", \"267D-259\", \"117-1\", \"265A-35\", \"178-1\", \"268C-35\", \"192-121\", \"169-82\", \"182-98\", \"267F-391\", \"254-76\", \"184-168\", \"69-162\", \"84-91\", \"90-170\", \"181-65\", \"91-118\", \"183-100\", \"182-8\", \"157-26\", \"154-111\", \"252-172\", \"229-150\", \"81-50\", \"236-95\", \"178-79\", \"15-3\", \"34-8\", \"166-37\", \"160-14\", \"273-51\", \"251-221\", \"273-35\", \"160-59\", \"168-36\", \"186-96\", \"40-153\", \"44-104\", \"166-77\", \"20-75\", \"18-73\", \"18-74\", \"23-156\", \"128-70\", \"203B-52\", \"95-76\", \"140-148\", \"120-17\", \"174-37\", \"252-147\", \"110-21\", \"102-46\", \"1A-190\", \"165-55\", \"70-91\", \"160-64\", \"175-84\", \"168-59\", \"107-135\", \"1A-211\", \"196-154\", \"110-18\", \"1A-172\", \"34-116\", \"80-172\", \"182-84\", \"74-6\", \"265B-28\", \"116-94\", \"105-81\", \"267D-282\", \"162-29\", \"267.4-288\", \"199-90\", \"114A-66\", \"90-14\", \"216-7\", \"251-9\", \"80-175\", \"80-3\", \"261-6\", \"109-51\", \"192-73\", \"226-67\", \"267F-293\", \"252-160\", \"15-30\", \"183-97\", \"42-94\", \"160-58\", \"175-75\", \"267.2-267\", \"186-85\", \"267F-279\", \"182-89\", \"233-89\", \"110-16\", \"36-248\", \"106-109\", \"267E-280\", \"100-86\", \"12-19\", \"109-22\", \"43-78\", \"21-16\", \"160-67\", \"261-7\", \"91-52\", \"174-30\", \"120-48\", \"260-74\", \"168-20\", \"166-24\", \"79-22\", \"20-83\", \"273-2\", \"95-79\", \"168-33\", \"199-67\", \"160-69\", \"10-39\", \"255-21\", \"90-70\", \"27-82\", \"162-36\", \"184-31\", \"91-81\", \"267.3-253\", \"133-28\", \"267F-296\", \"116-100\", \"199-30\", \"84-1\", \"154-97\", \"119-93\", \"160-66\", \"265A-29\", \"93-48\", \"88-53\", \"18-65\", \"36-189\", \"126-27\", \"267D-300\", \"136-15\", \"19-10\", \"252-114\", \"173-65\", \"175-77\", \"93-78\", \"110-55\", \"42-91\", \"141-80\", \"176-15\", \"267C-70\", \"106-117\", \"70-92\", \"8-76\", \"121-94\", \"42-99\", \"261-112\", \"44-105\", \"265B-59\", \"116-12\", \"189-72\", \"93-75\", \"178-106\", \"174-36\", \"189-57\", \"93-76\", \"16-23\", \"230-97\", \"54-25\", \"75-128\", \"18-76\", \"174-31\", \"14-36\", \"94-6\", \"91-63\", \"267D-316\", \"31-20\", \"273-20\", \"29-50\", \"10-31\", \"90-162\", \"117-25\", \"166-35\", \"96-109\", \"93-73\", \"192-39\", \"162-26\", \"168-49\", \"88-48\", \"133-23\", \"160-72\", \"260-73\", \"160-76\", \"154-73\", \"133-15\", \"117-29\", \"105-82\", \"174-26\", \"231-27\", \"90-169\", \"168-48\", \"69-159\", \"90-13\", \"42-86\", \"267F-274\", \"105-68\", \"105-123\", \"169-86\", \"160-83\", \"155-42\", \"267D-310\", \"267D-285\", \"83-99\", \"265B-26\", \"169-84\", \"1A-192\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Soft Constraint"
  },
  {
    "Query": "search for retail spaces designed for boutique shops, prioritizing locations near art galleries or cultural centers.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(epsg=cambridge_crs)\npoi_proj = poi.to_crs(epsg=cambridge_crs)\n# Define boutique retail use codes\nboutique_retail_codes = ['323', '3241', '3242', '325', '326']\n# Filter for boutique retail spaces\nboutique_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(boutique_retail_codes)].copy()\n# Define art galleries and cultural centers POI types\nart_gallery_types = ['art_gallery', 'museum', 'cultural_center']\n# Filter for art galleries and cultural centers\nart_gallery_poi = poi_proj[poi_proj['poi_type'].isin(art_gallery_types)].copy()\n# Ensure there's at least one art gallery/cultural center\nif art_gallery_poi.empty:\n    print(\"No art galleries or cultural centers found.\")\n    # If none found, return empty result\n    print(\"Parcel IDs matching criteria:\", [])\n    exit()\n# Create 500ft buffer around art galleries/cultural centers\nbuffer_distance = 500 * 0.3048  # 500ft in meters\nart_gallery_buffers = [geom.buffer(buffer_distance) for geom in art_gallery_poi.geometry]\n# Combine buffers into a single geometry\nunion_buffer = gpd.GeoSeries(art_gallery_buffers).unary_union\n# Filter boutique parcels by proximity to art galleries/cultural centers\nnear_boutique_parcels = boutique_parcels[boutique_parcels.geometry.intersects(union_buffer)].copy()\n# Sort by distance to art galleries/cultural centers\n# Calculate distance to nearest art gallery/cultural center\ndef calculate_distance_to_nearest_gallery(parcel_geom, gallery_geoms):\n    if not gallery_geoms:\n        return float('inf')\n    return min(parcel_geom.distance(geom) for geom in gallery_geoms)\n# Get gallery geometries\ngallery_geoms = art_gallery_poi.geometry.tolist()\n# Calculate distances\nnear_boutique_parcels.loc[:, 'distance_to_gallery'] = near_boutique_parcels.geometry.apply(\n    lambda geom: calculate_distance_to_nearest_gallery(geom, gallery_geoms)\n)\n# Sort by distance (closer first)\nnear_boutique_parcels = near_boutique_parcels.sort_values('distance_to_gallery')\n# Convert back to original CRS\nnear_boutique_parcels = near_boutique_parcels.to_crs(parcels.crs)\n# Get parcel IDs\nresult_ids = near_boutique_parcels['ml'].tolist()\n# Print results\nprint(\"Parcel IDs matching criteria:\", result_ids)",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Soft Constraint"
  },
  {
    "Query": "find office spaces that offer flexible layouts for co-working, ideally in areas with a young professional demographic.",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define project CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Define flexible office use codes\nflex_office_use_codes = [\n    '340', '343', '345', '346', '362', '400', '404', '406', '0340', '0343',\n    '0345', '0346', '0362', '0400', '0404', '0406'\n]\n# Filter for flexible office spaces\nflex_office_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(flex_office_use_codes)]\n# Define young professional demographic criteria\nyoung_professional_age_range = (25, 40)\n# Filter for areas with high young professional population\n# Estimate young professional percentage from census data\ncensus_young_prof = (\n    census_proj['pct_young_professional'].fillna(0) / 100\n)\n# Calculate young professional population in each area\ncensus_proj = census_proj.assign(\n    young_professional_pop=census_proj['total_population'] * census_young_prof\n)\n# Sort by young professional population (descending)\ncensus_proj = census_proj.sort_values('young_professional_pop', ascending=False)\n# Get top 30% of areas with high young professional population\ntop_young_prof_areas = census_proj.head(int(len(census_proj) * 0.3))\n# Filter flexible office parcels by location in young professional areas\nflex_office_in_young_prof_areas = gpd.sjoin(\n    flex_office_parcels,\n    top_young_prof_areas,\n    how='inner',\n    predicate='within'\n)\n# Sort by parcel ID for consistency\nresult_parcels = flex_office_in_young_prof_areas.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Simple_Constraints",
    "Subcategory": "Single Soft Constraint"
  },
  {
    "Query": "identify restaurants with outdoor seating, preferably located in tourist-heavy areas for increased foot traffic.",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define restaurant POI codes\nrestaurant_poi_codes = ['0112', '0113', '0114', '0115', '0116', '0119', '0128']\n# Define outdoor seating restaurant POI codes\noutdoor_seating_codes = ['0112', '0113', '0116', '0128']\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Filter for restaurants\nrestaurants = poi_proj[poi_proj['poi_code'].astype(str).isin(restaurant_poi_codes)].copy()\n# Filter for restaurants with outdoor seating\noutdoor_restaurants = restaurants[restaurants['poi_code'].astype(str).isin(outdoor_seating_codes)].copy()\n# Filter parcels in tourist-heavy areas\n# Use spending data as a proxy for tourist-heavy areas\n# Merge with cambridge POI data to get location of each business\nspend_with_location = spend.merge(\n    poi,\n    left_on='business_id',\n    right_on='business_id',\n    how='left'\n)\n# Drop rows where POI location is NaN\nspend_with_location = spend_with_location.dropna(subset=['location'])\n# Convert to GeoDataFrame\nspend_gdf = gpd.GeoDataFrame(\n    spend_with_location,\n    geometry=gpd.points_from_xy(\n        spend_with_location['location'].apply(lambda x: x[0]),\n        spend_with_location['location'].apply(lambda x: x[1])\n    ),\n    crs=poi.crs\n)\n# Project to metric CRS\nspend_gdf_proj = spend_gdf.to_crs(epsg=26986)\n# Get top tourist-heavy areas based on spending\ntop_tourist_areas = spend_gdf_proj.nlargest(50, 'total_spent')['business_id'].tolist()\n# Filter for restaurants in tourist-heavy areas\ntourist_restaurants = outdoor_restaurants[outdoor_restaurants['business_id'].isin(top_tourist_areas)].copy()\n# Sort by exact location (to ensure consistency)\ntourist_restaurants = tourist_restaurants.sort_values('business_id')\n# Convert back to original CRS\ntourist_restaurants = tourist_restaurants.to_crs(parcels.crs)\n# Get parcel IDs\nresult_parcels = tourist_restaurants['ml'].tolist()\n# Print results\nprint(f\"Found {len(tourist_restaurants)} outdoor seating restaurants in tourist-heavy areas\")\nprint(f\"Parcel IDs: {result_parcels}\")",
    "Answer": "[\"Error: 'poi_code\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Soft Constraint"
  },
  {
    "Query": "locate retail stores focusing on sustainable products, prioritizing areas with environmentally-conscious communities.",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define retail store types focusing on sustainable products\nsustainable_retail_types = [\n    'health_food_store', 'organic_grocery', 'clothing_store', \n    'shoe_store', 'furniture_store', 'department_store'\n]\n# Define environmentally-conscious spending categories\neco_conscious_spend_categories = [\n    'organic', 'sustainable', 'eco_friendly', 'green', 'natural'\n]\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Filter for sustainable retail stores\nsustainable_stores = poi_proj[poi_proj['poi_type'].isin(sustainable_retail_types)].copy()\n# Filter for environmentally-conscious communities using spending data\n# Merge spending data with census data on geographic identifier\ncensus_with_spend = census_proj.merge(\n    spend,\n    left_on='geoid',\n    right_on='geoid',\n    how='left'\n)\n# Fill NaN values in spending columns with 0\nfor category in eco_conscious_spend_categories:\n    if category in census_with_spend.columns:\n        census_with_spend[category] = census_with_spend[category].fillna(0)\n# Calculate total eco-conscious spending\nif all(category in census_with_spend.columns for category in eco_conscious_spend_categories):\n    census_with_spend['total_eco_conscious_spend'] = (\n        census_with_spend[eco_conscious_spend_categories].sum(axis=1)\n    )\nelse:\n    census_with_spend['total_eco_conscious_spend'] = 0\n# Prioritize areas with high eco-conscious spending\n# Sort by spending (higher is better)\ncensus_with_spend = census_with_spend.sort_values('total_eco_conscious_spend', ascending=False)\n# Filter for sustainable stores within each high-spending area\ndef filter_stores_near_high_spend_areas(stores, sorted_census, parcels, buffer=200): \n    # Get top 3 areas with highest eco-conscious spending\n    top_areas = sorted_census.head(3)\n    # Create buffer around each area\n    buffers = [geom.buffer(buffer) for geom in top_areas.geometry]\n    combined_buffer = gpd.GeoSeries(buffers).unary_union\n    # Filter stores within buffer\n    filtered_stores = stores[stores.geometry.intersects(combined_buffer)].copy()\n    return filtered_stores\n# Filter for stores near high-spend areas\nsustainable_stores_near_ecoconscious = filter_stores_near_high_spend_areas(\n    sustainable_stores, \n    census_with_spend, \n    parcels_proj\n)\n# Sort by proximity to eco-conscious areas (optional)\n# Convert to original CRS\nsustainable_stores_near_ecoconscious = sustainable_stores_near_ecoconscious.to_crs(parcels.crs)\n# Get parcel IDs\nresult_ids = sustainable_stores_near_ecoconscious['ml'].tolist()\n# Print results\nprint(f\"Found {len(result_ids)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Soft Constraint"
  },
  {
    "Query": "search for event venues with historic charm, ideally located near universities for easy access to students.",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define CAMBRIDGE_UNIVERSITIES\nCAMBRIDGE_UNIVERSITIES = [\n    (-71.11895, 42.373611),  # Harvard University\n    (-71.1032, 42.3656),    # Massachusetts Institute of Technology (MIT)\n    (-71.1219, 42.3782)     # Lesley University\n]\n# Convert to projected CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\n# Filter for event venues (hotels, large restaurants) with historic charm\n# Hotels: Use POI data for accurate classification\nhotels = poi[poi['business_type'] == 'hotel'].copy()\n# Large restaurants: Typically have a seating capacity of 100 or more\nlarge_restaurants = poi[(poi['business_type'] == 'restaurant') & (poi['seating_capacity'] >= 100)].copy()\n# Combine hotels and large restaurants\nvenues = pd.concat([hotels, large_restaurants])\n# Filter for historic charm: \n# 1. Look for venues in historic districts\nhistoric_districts = [\n    # Cambridgeport Historic District\n    (-71.103, 42.365), \n    (-71.103, 42.367), \n    (-71.099, 42.365), \n    (-71.099, 42.367),\n    # Harvard Historic District\n    (-71.118, 42.374), \n    (-71.118, 42.376), \n    (-71.114, 42.374), \n    (-71.114, 42.376),\n    # MIT Historic District\n    (-71.103, 42.362), \n    (-71.103, 42.364), \n    (-71.099, 42.362), \n    (-71.099, 42.364)\n]\nhistoric_polygons = [gpd.points_from_xy(*zip(*[pt]))[0].buffer(0.0005) for pt in historic_districts]\nhistoric_union = gpd.GeoSeries(historic_polygons).unary_union\n# Convert venues to same CRS\nvenues_proj = venues.to_crs(epsg=26986)\n# Filter venues in historic districts\nhistoric_venues = venues_proj[venues_proj.geometry.intersects(historic_union)].copy()\n# Filter for venues near universities\n# Convert universities to GeoDataFrame\nuniversity_points = gpd.GeoDataFrame(geometry=gpd.points_from_xy(*zip(*CAMBRIDGE_UNIVERSITIES)), crs=parcels.crs)\nuniversity_points_proj = university_points.to_crs(epsg=26986)\n# Find venues within 500m of any university\nnear_universities = []\nfor uni_geom in university_points_proj.geometry:\n    # Buffer for 500m\n    buffered = uni_geom.buffer(500)\n    # Check if venue is near this university\n    near = historic_venues[historic_venues.geometry.intersects(buffered)]\n    near_universities.append(near)\n# Combine results\nnear_universities = pd.concat(near_universities)\n# Sort by proximity to universities (optional)\n# Convert back to original CRS\nfinal_venues = near_universities.to_crs(parcels.crs)\n# Sort by ml (parcel ID)\nfinal_venues = final_venues.sort_values('ml')\n# Output results\nresult_ids = final_venues['ml'].tolist()\nprint(result_ids)",
    "Answer": null,
    "Category": "Simple_Constraints",
    "Subcategory": "Single Soft Constraint"
  },
  {
    "Query": "find fitness studios with unique class offerings, prioritizing areas with a strong health-conscious demographic.",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Convert to projected CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Define fitness studio POI codes\nfitness_studio_codes = ['2000', '2026', '1240', '1253', '1260', '1276', '1289', '1490']\n# Filter for fitness studios\nfitness_studios = poi_proj[poi_proj['business_code'].astype(str).isin(fitness_studio_codes)].copy()\n# Function to calculate unique class offerings\ndef calculate_unique_class_offerings(studio_id, poi_data):\n    # Placeholder for actual class offering data\n    # In reality, this would involve more complex data retrieval and analysis\n    return np.random.randint(5, 20)  # Random value for demonstration\n# Add unique class offerings to fitness studios\nfitness_studios.loc[:, 'unique_class_offerings'] = fitness_studios['ml'].apply(\n    lambda x: calculate_unique_class_offerings(x, poi_proj)\n)\n# Prioritize areas with health-conscious demographics\n# Merge with census data\nfitness_with_census = fitness_studios.merge(\n    census_proj,\n    left_on='cambridge_ml',\n    right_on='ml',\n    how='left'\n)\n# Define health-conscious demographic metrics\nhealth_metrics = [\n    'pct_health_insurance', 'pct_bachelor_degree', 'pct_income_above_median',\n    'pct_fitness_center_membership', 'pct_healthy_weight'\n]\n# Calculate health score\nfitness_with_census['health_score'] = fitness_with_census[health_metrics].mean(axis=1)\n# Sort by unique class offerings (descending) and health score (descending)\nresult_studios = fitness_with_census.sort_values(\n    ['unique_class_offerings', 'health_score'],\n    ascending=False\n)\n# Convert back to original CRS\nresult_studios = result_studios.to_crs(parcels.crs)\n# Get parcel IDs\nresult_ids = result_studios['ml'].tolist()\n# Print results\nprint(f\"Found {len(result_studios)} fitness studios meeting criteria\")\nprint(f\"Parcel IDs (sorted by unique class offerings and health score): {result_ids}\")",
    "Answer": "[\"Error: 'business_code\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Soft Constraint"
  },
  {
    "Query": "identify commercial spaces with ample natural light, ideally in converted warehouses or loft buildings.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_use_codes)].copy()\n# Define POI categories for restaurants and cafes\nrestaurant_categories = [\n    'restaurant', 'cafe', 'coffee_shop', 'bakery', 'brunch', 'diner', \n    'fast_food', 'pancake_house', 'soup', 'sandwich'\n]\n# Filter POI for restaurants and cafes\nrestaurant_poi = poi[poi['category'].isin(restaurant_categories)].copy()\n# Project POI to the same CRS\nrestaurant_poi_proj = restaurant_poi.to_crs(parcels_proj.crs)\n# Define warehouse/loft building characteristics\nwarehouse_keywords = ['warehouse', 'loft', 'converted warehouse', 'converted loft']\n# Filter for parcels that are likely converted warehouses or lofts\n# This is a heuristic approach since we don't have explicit building type data\n# Use large commercial parcels as a proxy\nlarge_warehouse_parcels = commercial_parcels[commercial_parcels['land_area'] > 10000].copy()\n# Combine criteria: ample natural light + converted warehouse/loft\n# For this heuristic, we'll assume that large commercial spaces have more natural light\n# Filter for parcels near restaurants (for lunch crowd)\n# Create 100m buffer around restaurant POI\nrestaurant_buffers = [geom.buffer(100) for geom in restaurant_poi_proj.geometry]\nunion_buffer = gpd.GeoSeries(restaurant_buffers).unary_union\n# Filter for parcels within 100m of restaurants\nlight_parcels = large_warehouse_parcels[large_warehouse_parcels.geometry.intersects(union_buffer)].copy()\n# Sort by proximity to restaurants (closer = more likely to have lunch crowd)\n# Calculate distance to nearest restaurant\ndef calculate_nearby_restaurant_score(parcel_geom, restaurant_geoms):\n    distances = [parcel_geom.distance(geom) for geom in restaurant_geoms]\n    return min(distances)  # Closer = better\n# Get restaurant geometries\nrestaurant_geoms = restaurant_poi_proj.geometry.tolist()\n# Calculate score\nlight_parcels.loc[:, 'restaurant_score'] = light_parcels.geometry.apply(\n    lambda geom: calculate_nearby_restaurant_score(geom, restaurant_geoms)\n)\n# Sort by score (lower is better)\nresult_parcels = light_parcels.sort_values('restaurant_score').copy()\n# Return parcel IDs\nresult_ids = result_parcels['ml'].tolist()\n# Print results\nprint(f",
    "Answer": null,
    "Category": "Simple_Constraints",
    "Subcategory": "Single Soft Constraint"
  },
  {
    "Query": "locate art galleries with exhibition space, preferably in neighborhoods known for their vibrant arts scene.",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Convert to projected CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Define art gallery use codes\nart_gallery_use_codes = ['323', '3231']  # General and specific codes for art galleries\n# Filter for art galleries with exhibition space\ngallery_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(art_gallery_use_codes)].copy()\n# Define vibrant arts scene neighborhoods (approximate)\nvibrant_neighborhoods = [\n    'Cambridgeport', 'Central Square', 'Harvard Square', \n    'Inman Square', 'Porter Square', 'Lesley University area'\n]\n# Filter POI for arts-related businesses\narts_business_types = ['art_gallery', 'museum', 'performing_arts']\narts_poi = poi_proj[poi_proj['business_type'].isin(arts_business_types)].copy()\n# Get neighborhood information from POI\narts_poi_with_neighborhood = arts_poi.copy()\n# Spatial join to get neighborhood data\narts_poi_with_neighborhood = gpd.sjoin(\n    arts_poi,\n    census_proj,\n    how='left',\n    predicate='within'\n)\n# Filter for vibrant arts scene neighborhoods\nif vibrant_neighborhoods:\n    arts_poi_with_neighborhood = arts_poi_with_neighborhood[\n        arts_poi_with_neighborhood['neighborhood'].isin(vibrant_neighborhoods)\n    ]\n# Get gallery parcels in vibrant arts neighborhoods\ngallery_ids = gallery_parcels['ml'].tolist()\n# Filter by neighborhood\nresult_parcels = arts_poi_with_neighborhood[\n    arts_poi_with_neighborhood['ml'].isin(gallery_ids)\n].copy()\n# Sort by proximity to arts businesses (closer = better)\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} gallery parcels in vibrant arts neighborhoods\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: 'neighborhood\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Soft Constraint"
  },
  {
    "Query": "find pet-friendly retail spaces, prioritizing locations near parks or pet-friendly communities.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Convert to projected CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Define pet-friendly retail use codes\npet_friendly_retail_codes = ['323', '324', '325', '326', '327', '330']\n# Filter for pet-friendly retail spaces\npet_friendly_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(pet_friendly_retail_codes)].copy()\n# Define park locations (from POI data)\npark_poi_ids = ['4bda1c5ef964a520c4e022e3', '4bda1c5ef964a520c4e022e3', '4bda1c5ef964a520c4e022e3']\nparks = poi_proj[poi_proj['poi_id'].isin(park_poi_ids)].copy()\n# Define pet-friendly community locations (from POI data)\npet_friendly_community_ids = ['4b8c4f2ef964a520c1e032e3', '4b8c4f2ef964a520c1e032e3']\npet_friendly_communities = poi_proj[poi_proj['poi_id'].isin(pet_friendly_community_ids)].copy()\n# Calculate park proximity (within 2 blocks)\nbuffer_distance = 2 * 100  # 2 blocks in feet\nparks_buffer = [p.geometry.buffer(buffer_distance) for p in parks.geometry]\nunion_park_area = gpd.GeoSeries(parks_buffer).unary_union\n# Filter by proximity to parks\nparcels_near_parks = pet_friendly_parcels[pet_friendly_parcels.geometry.intersects(union_park_area)].copy()\n# Calculate pet-friendly community proximity (within 2 blocks)\npet_friendly_communities_buffer = [p.geometry.buffer(buffer_distance) for p in pet_friendly_communities.geometry]\nunion_community_area = gpd.GeoSeries(pet_friendly_communities_buffer).unary_union\n# Filter by proximity to pet-friendly communities\nparcels_near_communities = pet_friendly_parcels[pet_friendly_parcels.geometry.intersects(union_community_area)].copy()\n# Combine filters (prioritize by park proximity first)\nfinal_parcels = pd.concat([parcels_near_parks, parcels_near_communities]).drop_duplicates()\n# Sort by proximity to parks (if needed, can add distance calculation here)\nfinal_parcels = final_parcels.sort_values('ml')\n# Convert back to original CRS\nfinal_parcels = final_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} pet-friendly retail spaces near parks/communities\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Single Soft Constraint"
  },
  {
    "Query": "find commercial parcels larger than 5000 square feet AND within 400 meters of harvard square",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define Harvard Square location\nharvard_square = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy([-71.1189, 42.3736])],\n    crs=parcels.crs\n)\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\nharvard_square_proj = harvard_square.to_crs(epsg=26986)\n# Filter for commercial parcels larger than 5000 sq ft\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\nlarge_commercial_parcels = parcels_proj[\n    (parcels_proj['use_code'].astype(str).str.startswith(('3', '4'))) & \n    (parcels_proj['land_area'] > 5000) \n].copy()\n# Filter for parcels within 400m of Harvard Square\nharvard_buffer = harvard_square_proj.buffer(400) \nparcels_near_harvard = large_commercial_parcels[large_commercial_parcels.geometry.intersects(harvard_buffer.iloc[0])].copy()\n# Sort by parcel ID (ml)\nresult_ids = parcels_near_harvard['ml'].sort_values().tolist()\n# Convert back to original CRS\nparcels_near_harvard = parcels_near_harvard.to_crs(parcels.crs)\n# Output results\nprint(f\"Found {len(parcels_near_harvard)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: points_from_xy() missing 1 required positional argument: 'y\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Two Hard Constraints"
  },
  {
    "Query": "find retail parcels zoned for restaurant use AND within 500 meters of a major highway",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define restaurant use codes consistently\nrestaurant_use_codes = ['323', '3241', '3243', '3244', '3245']\n# Filter for restaurant parcels\nrestaurant_parcels = parcels[parcels['use_code'].astype(str).isin(restaurant_use_codes)].copy()\n# Define major highway geometries\nhighways = [\n    # Mass Ave\n    gpd.GeoSeries([gpd.points_from_xy([-71.1056, -71.1056], [42.3625, 42.3601]).iloc[0],\n                   gpd.points_from_xy([-71.1056, -71.1056], [42.3625, 42.3601]).iloc[1]]).unary_union,\n    # I-90\n    gpd.GeoSeries([gpd.points_from_xy([-71.1169, -71.1169], [42.3627, 42.3585]).iloc[0],\n                   gpd.points_from_xy([-71.1169, -71.1169], [42.3627, 42.3585]).iloc[1]]).unary_union,\n    # I-93\n    gpd.GeoSeries([gpd.points_from_xy([-71.0654, -71.0654], [42.3676, 42.3641]).iloc[0],\n                   gpd.points_from_xy([-71.0654, -71.0654], [42.3676, 42.3641]).iloc[1]]).unary_union,\n    # Memorial Drive\n    gpd.GeoSeries([gpd.points_from_xy([-71.1215, -71.1215], [42.3736, 42.3702]).iloc[0],\n                   gpd.points_from_xy([-71.1215, -71.1215], [42.3736, 42.3702]).iloc[1]]).unary_union,\n    # Storrow Drive\n    gpd.GeoSeries([gpd.points_from_xy([-71.1189, -71.1189], [42.3671, 42.3635]).iloc[0],\n                   gpd.points_from_xy([-71.1189, -71.1189], [42.3671, 42.3635]).iloc[1]]).unary_union\n]\nhighway_geoms = gpd.GeoSeries(highways)\nhighway_gdf = gpd.GeoDataFrame(geometry=highway_geoms)\n# Project to metric CRS for accurate buffering\nrestaurant_parcels_proj = restaurant_parcels.to_crs(epsg=26986)\nhighway_gdf_proj = highway_gdf.to_crs(epsg=26986)\n# Create 500m buffer around highways\nhighway_buffers = [geom.buffer(500) for geom in highway_gdf_proj.geometry]\n# Filter for parcels within 500m of any major highway\nnear_highway_parcels = restaurant_parcels_proj[\n    restaurant_parcels_proj.geometry.intersects(pd.concat([gpd.GeoSeries(b).unary_union for b in highway_buffers]).iloc[0])\n].copy()\n# Convert back to original CRS\nnear_highway_parcels = near_highway_parcels.to_crs(parcels.crs)\n# Sort by ml (parcel ID)\nresult_parcels = near_highway_parcels.sort_values('ml')\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Simple_Constraints",
    "Subcategory": "Two Hard Constraints"
  },
  {
    "Query": "find industrial parcels larger than 10000 square feet AND within 300 meters of alewife station",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Convert to projected CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Define Alewife Station location (approximate)\nalewife_station = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy([-71.1429, 42.3954])],\n    crs=parcels.crs\n).to_crs(cambridge_crs)\n# Filter for industrial parcels larger than 10000 sq ft\nlarge_industrial = parcels_proj[\n    (parcels_proj['use_code'].astype(str).str.startswith('3')) & \n    (parcels_proj['land_area'] > 10000)\n].copy()\n# Filter for parcels within 300m of Alewife Station\nalewife_buffer = alewife_station.buffer(300)  # 300m buffer\nnear_alewife = large_industrial[large_industrial.geometry.intersects(alewife_buffer.iloc[0])].copy()\n# Sort by parcel ID (ml)\nresult_ids = near_alewife['ml'].sort_values().tolist()\n# Convert back to original CRS\nnear_alewife = near_alewife.to_crs(parcels.crs)\n# Print results\nprint(f\"Found {len(near_alewife)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: points_from_xy() missing 1 required positional argument: 'y\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Two Hard Constraints"
  },
  {
    "Query": "find mixed-use parcels with residential units AND within 250 meters of a public park",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(epsg=cambridge_crs)\npoi_proj = poi.to_crs(epsg=cambridge_crs)\n# Define mixed-use codes that include residential units\nmixed_use_codes = [\n    '323', '324', '325', '326', '327', '330', '332', '334', '340', \n    '341', '343', '345', '346', '353', '362', '375', '404', '406'\n]\n# Filter for mixed-use parcels with residential units\nresidential_units_condition = (\n    (parcels_proj['ml'].astype(str).str.startswith('0')) | \n    (parcels_proj['ml'].astype(str).str.startswith('8'))\n)\nmixed_use_with_residential = parcels_proj[\n    parcels_proj['use_code'].astype(str).isin(mixed_use_codes) & \n    residential_units_condition\n].copy()\n# Filter parks from POI data\npark_types = ['park', 'national_park', 'state_park', 'local_park']\nparks = poi_proj[poi_proj['business_type'].isin(park_types)].copy()\n# Ensure we have parks to work with\nif parks.empty:\n    print(\"No parks found in POI data.\")\n    exit()\n# Create 250m buffer around parks\npark_buffers = [geom.buffer(250) for geom in parks.geometry]\npark_union_buffer = gpd.GeoSeries(park_buffers).unary_union\n# Filter for mixed-use parcels within 250m of a park\nnear_parks = mixed_use_with_residential[mixed_use_with_residential.geometry.intersects(park_union_buffer)].copy()\n# Sort by parcel ID (ml)\nresult_ids = near_parks['ml'].astype(str).tolist()\nresult_ids.sort(key=int)\n# Print results\nprint(f\"Found {len(near_parks)} mixed-use parcels with residential units within 250m of a park\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Two Hard Constraints"
  },
  {
    "Query": "find retail parcels with at least 3000 square feet of land area AND within 600 meters of public transportation",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Filter by land area (at least 3000 sq ft)\nlarge_retail = retail_parcels[retail_parcels['land_area'] >= 3000].copy()\n# Get all transit stops from POI data\ntransit_types = ['subway', 'bus', 'train', 'trolley']\ntransit_stops = poi[poi['poi_type'].isin(transit_types)].copy()\n# Ensure transit stops have geometry\ntransit_stops = transit_stops[transit_stops.geometry.notnull()]\n# Convert to same CRS\ntransit_stops_proj = transit_stops.to_crs(parcels_proj.crs)\n# Create 600m buffer around transit stops\ntransit_buffers = [geom.buffer(600) for geom in transit_stops_proj.geometry]\ntransit_union_buffer = gpd.GeoSeries(transit_buffers).unary_union\n# Filter retail parcels by proximity to transit (within 600m)\nfinal_parcels = large_retail[large_retail.geometry.intersects(transit_union_buffer)].copy()\n# Sort by parcel ID (ml)\nfinal_parcels = final_parcels.sort_values('ml')\n# Convert back to original CRS\nfinal_parcels = final_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Simple_Constraints",
    "Subcategory": "Two Hard Constraints"
  },
  {
    "Query": "find commercial parcels zoned for office use AND within 800 meters of a major hospital",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Define office use codes\noffice_use_codes = ['340', '343', '345', '346', '0340', '404', '406', '0406']\n# Filter for office parcels\noffice_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(office_use_codes)].copy()\n# Define major hospitals in Cambridge\nhospitals = [\n    (42.3676, -71.1056),  # Massachusetts General Hospital\n    (42.3625, -71.1189),  # Cambridge Health Alliance\n    (42.3782, -71.1185)   # Mount Auburn Hospital\n]\n# Convert hospital locations to GeoDataFrame\nhospital_geom = [gpd.points_from_xy([h[1]], [h[0]]) for h in hospitals]\nhospital_gdf = gpd.GeoDataFrame(geometry=hospital_geom, crs=parcels.crs)\nhospital_gdf_proj = hospital_gdf.to_crs(cambridge_crs)\n# Create 800m buffer around hospitals\nhospital_buffers = [geom.buffer(800) for geom in hospital_gdf_proj.geometry]\nhospital_union_buffer = gpd.GeoSeries(hospital_buffers).unary_union\n# Filter office parcels within 800m of hospitals\noffice_near_hospitals = office_parcels[office_parcels.geometry.intersects(hospital_union_buffer)].copy()\n# Sort by parcel ID (ml)\nresult_parcels = office_near_hospitals.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Two Hard Constraints"
  },
  {
    "Query": "find parcels with high foot traffic business types AND within 400 meters of mit",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define MIT location\nmit_location = (-71.09416, 42.3601)\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\n# Define high foot traffic business types\nhigh_foot_traffic_types = [\n    'restaurant', 'cafe', 'fast_food', 'clothing_store', 'department_store',\n    'grocery_store', 'convenience_store', 'shoe_store', 'bar', 'pub'\n]\n# Filter POI for high foot traffic business types\npoi_filtered = poi[poi['business_type'].isin(high_foot_traffic_types)].copy()\n# Project filtered POI to the same CRS\npoi_filtered_proj = poi_filtered.to_crs(epsg=26986)\n# Filter parcels that are within 400m of MIT\nmit_geom = gpd.GeoSeries([gpd.points_from_xy([mit_location[0]], [mit_location[1]])[0]], crs=parcels.crs)\nmit_geom_proj = mit_geom.to_crs(epsg=26986)\n# Create 400m buffer around MIT\nmit_buffer = mit_geom_proj.buffer(400)[0]\n# Filter for high foot traffic business type POI within 400m of MIT\n# Use spatial join to find which POI are within 400m of MIT\npoi_near_mit = poi_filtered_proj[poi_filtered_proj.geometry.intersects(mit_buffer)].copy()\n# Get parcel IDs for these POI\n# Use spatial join to find which parcels contain these POI\npoi_parcels = gpd.sjoin(poi_near_mit, parcels_proj, how='inner', predicate='within')\n# Sort by parcel ID\nresult_ids = poi_parcels['ml'].sort_values().tolist()\n# Convert back to original CRS\nparcels_proj = parcels_proj.to_crs(parcels.crs)\n# Print results\nprint(f",
    "Answer": null,
    "Category": "Simple_Constraints",
    "Subcategory": "Two Hard Constraints"
  },
  {
    "Query": "find retail parcels with at least 500 square feet of frontage AND within 500 meters of a popular tourist attraction",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Filter by frontage\n# Frontage is typically represented by 'ml' (master deed line) in cambridge data\n# Assuming 'ml' is a numeric value representing frontage in feet\n# For retail, we can estimate frontage by dividing 'land_area' by depth (usually around 1.5-2x the width)\n# For simplicity, we'll use a direct filter on 'ml' if it's available\nif 'ml' in retail_parcels.columns:\n    # Filter for parcels with at least 500 sq ft of frontage\n    # 500 sq ft of frontage = 500 ft width, so ml should be >= 500\n    retail_with_frontage = retail_parcels[retail_parcels['ml'] >= 500].copy()\nelse:\n    # If 'ml' is not available, estimate frontage from land area\n    # Assuming average retail depth is 150 ft, so frontage = land_area / depth\n    # Filter for parcels with at least 500 sq ft of frontage\n    # 500 sq ft of frontage = 500 ft width, so ml should be >= 500\n    estimated_frontage = retail_parcels['land_area'] / 2  # rough estimate\n    retail_with_frontage = retail_parcels[estimated_frontage >= 500].copy()\n# Filter by proximity to tourist attractions\n# Define tourist attractions (museums, historical sites, etc.)\ntourist_attractions = [\n    (42.373611, -71.109733),  # Harvard University\n    (42.378226, -71.118956),  # MIT\n    (42.395428, -71.142483),  # Fenway Park\n    (42.362490, -71.086176),  # Boston Common\n    (42.365558, -71.062194)   # Freedom Trail\n]\n# Convert to GeoDataFrame\nattraction_geom = gpd.GeoSeries([gpd.points_from_xy([lon], [lat])[0] for lat, lon in tourist_attractions])\nattractions_gdf = gpd.GeoDataFrame(geometry=attraction_geom, crs=parcels.crs)\n# Project attractions to same CRS\nattractions_proj = attractions_gdf.to_crs(epsg=26986)\n# Create 500m buffer around attractions\nattraction_buffers = [geom.buffer(500) for geom in attractions_proj.geometry]\nunion_buffer = gpd.GeoSeries(attraction_buffers).unary_union\n# Filter retail parcels by proximity to attractions\nretail_near_attractions = retail_with_frontage[retail_with_frontage.geometry.intersects(union_buffer)].copy()\n# Sort by parcel ID (ml)\nresult_ids = retail_near_attractions['ml'].tolist()\nresult_ids.sort()\n# Print results\nprint(f\"Found {len(retail_near_attractions)} parcels matching criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Two Hard Constraints"
  },
  {
    "Query": "find commercial parcels with at least 10% lot coverage AND within 300 meters of harvard university",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define Harvard University location\nharvard_coords = (-71.1189, 42.3770)\nharvard_point = gpd.GeoDataFrame(geometry=[gpd.points_from_xy([harvard_coords[0]], [harvard_coords[1]])], crs=parcels.crs)\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\nharvard_proj = harvard_point.to_crs(epsg=26986)\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith(('3', '4'))].copy()\n# Define lot coverage threshold\nlot_coverage_threshold = 0.10\n# Calculate lot coverage\ncommercial_parcels['calculated_lot_coverage'] = (\n    commercial_parcels['bldg_area'] / commercial_parcels['land_area']\n)\n# Filter by lot coverage\nparcels_with_coverage = commercial_parcels[commercial_parcels['calculated_lot_coverage'] >= lot_coverage_threshold].copy()\n# Create 300m buffer around Harvard\nharvard_buffer = harvard_proj.buffer(300).iloc[0]\n# Filter by proximity to Harvard\nfinal_parcels = parcels_with_coverage[parcels_with_coverage.geometry.intersects(harvard_buffer)].copy()\n# Sort by ml (parcel ID)\nfinal_parcels = final_parcels.sort_values('ml')\n# Convert back to original CRS\nfinal_parcels = final_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: Input must be valid geometry objects: <GeometryArray>\", \"<POINT (-71.119 42.377)>\", \"Length: 1, dtype: geometry\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Two Hard Constraints"
  },
  {
    "Query": "find restaurant parcels with outdoor seating AND within 200 meters of a major shopping area",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define restaurant use codes\nrestaurant_use_codes = ['323', '3241', '3243', '3244', '326']\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n# Filter for restaurant parcels\nrestaurant_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(restaurant_use_codes)].copy()\n# Define outdoor seating condition\n# For this dataset, we'll assume restaurants with 'ml' ending in '0' have outdoor seating\n# This is a heuristic and may not be accurate for all restaurants\nrestaurant_ids_with_outdoor_seating = restaurant_parcels[restaurant_parcels['ml'].astype(str).str.endswith('0')]['ml']\n# Filter for restaurants with outdoor seating\nrestaurants_with_outdoor_seating = restaurant_parcels[restaurant_parcels['ml'].isin(restaurant_ids_with_outdoor_seating)].copy()\n# Define major shopping areas (e.g., Central Square, Harvard Square, Kendall Square)\n# Approximate polygons for these areas\ncentral_square = gpd.GeoSeries([gpd.points_from_xy([-71.0995, -71.0992, -71.0992, -71.0995], [42.3656, 42.3658, 42.3661, 42.3661]).unary_union])\nharvard_square = gpd.GeoSeries([gpd.points_from_xy([-71.1189, -71.1186, -71.1186, -71.1189], [42.3736, 42.3738, 42.3741, 42.3741]).unary_union])\nkendall_square = gpd.GeoSeries([gpd.points_from_xy([-71.0846, -71.0843, -71.0843, -71.0846], [42.3625, 42.3627, 42.3630, 42.3630]).unary_union])\nmajor_shopping_areas = gpd.GeoDataFrame(geometry=central_square.append(harvard_square).append(kendall_square), crs=parcels.crs)\nmajor_shopping_areas_proj = major_shopping_areas.to_crs(epsg=26986)\n# Filter for restaurants within 200m of major shopping areas\n# Create 200m buffer around shopping areas\nshopping_buffers = [geom.buffer(200) for geom in major_shopping_areas_proj.geometry]\ncombined_buffer = gpd.GeoSeries(shopping_buffers).unary_union\n# Find restaurants within 200m of shopping areas\nrestaurants_near_shopping = restaurants_with_outdoor_seating[restaurants_with_outdoor_seating.geometry.intersects(combined_buffer)].copy()\n# Sort by parcel ID\nresult_ids = sorted(restaurants_near_shopping['ml'].astype(str).tolist())\n# Print results\nprint(f",
    "Answer": null,
    "Category": "Simple_Constraints",
    "Subcategory": "Two Hard Constraints"
  },
  {
    "Query": "find retail parcels with delivery zones AND within 600 meters of public transit stops",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Define delivery zones (zoning codes for retail)\ndelivery_zones = ['323', '324', '325', '326', '327', '330']\n# Filter POI for retail businesses\nretail_poi = poi[poi['business_type'].astype(str).str.startswith(('retail', 'restaurant'))].copy()\n# Filter for retail parcels with delivery zones\nretail_with_zones = retail_parcels[retail_parcels['ml'].astype(str).isin(retail_poi['parcel'].astype(str))].copy()\n# Create transit stop geometries\ntransit_stops = [\n    (-71.1189, 42.3736),  # Harvard Square\n    (-71.1032, 42.3656), # Central Square\n    (-71.0865, 42.3625), # Kendall/MIT\n    (-71.1226, 42.3782), # Porter Square\n    (-71.1429, 42.3954)  # Alewife\n]\ntransit_gdf = gpd.GeoDataFrame(geometry=gpd.points_from_xy(*zip(*transit_stops)), crs=parcels.crs)\ntransit_gdf_proj = transit_gdf.to_crs(epsg=26986)\n# Create 600m buffer around transit stops\ntransit_buffers = [geom.buffer(600) for geom in transit_gdf_proj.geometry]\ntransit_union_buffer = gpd.GeoSeries(transit_buffers).unary_union\n# Filter for retail parcels within 600m of transit stops\nfinal_parcels = retail_with_zones[retail_with_zones.geometry.intersects(transit_union_buffer)].copy()\n# Sort by parcel ID\nfinal_parcels = final_parcels.sort_values('ml')\n# Convert back to original CRS\nfinal_parcels = final_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} retail parcels with delivery zones within 600m of transit stops\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Two Hard Constraints"
  },
  {
    "Query": "find parcels with historical landmark status AND within 400 meters of a major university",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define historical landmark status codes\nhistoric_codes = ['323', '324', '325', '326', '327', '330', '332', '334', '340', '341', \n                  '343', '345', '346', '353', '362', '404', '406', '409', '415', '416', \n                  '417', '418', '419', '1022', '1026', '1030', '1031', '1044', '1090']\n# Filter for parcels with historic landmark status\nhistoric_parcels = parcels[parcels['building']astype(str).str.startswith('4')]\n# Define major universities in Cambridge\nuniversities = ['Harvard University', 'Massachusetts Institute of Technology']\n# Filter POI for university locations\nuniversity_poi = poi[poi['name'].isin(universities)].copy()\n# Convert to projected CRS for accurate distance measurement\nhistoric_parcels_proj = historic_parcels.to_crs(epsg=26986)\nuniversity_poi_proj = university_poi.to_crs(epsg=26986)\n# Create 400m buffer around each university\nuniversity_buffers = [geom.buffer(400) for geom in university_poi_proj.geometry]\n# Combine buffers into a single geometry\ncombined_buffer = gpd.GeoSeries(university_buffers).unary_union\n# Find historic parcels within 400m of any university\nresult_parcels = historic_parcels_proj[historic_parcels_proj.geometry.intersects(combined_buffer)]\n# Sort by parcel ID (ml)\nresult_ids = result_parcels['ml'].astype(int).sort_values().tolist()\n# Print results\nprint(result_ids)",
    "Answer": null,
    "Category": "Simple_Constraints",
    "Subcategory": "Two Hard Constraints"
  },
  {
    "Query": "find commercial parcels with substantial recent renovations AND within 500 meters of central square",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define project CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_use_codes)].copy()\n# Filter for recent renovations (within last 2 years)\nrecent_renovations = parcels_proj[parcels_proj['last_renovation_year'] >= 2021].copy()\n# Filter for substantial renovations (more than $100k)\nsubstantial_renovations = recent_renovations[recent_renovations['renovation_cost'] > 100000].copy()\n# Combine commercial and renovation filters\nrenovated_commercial = pd.concat([ \n    # If there's a direct renovation cost, use that\n    substantial_renovations,\n    # Otherwise, use the general renovation filter\n    recent_renovations[~recent_renovations['ml'].isin(substantial_renovations['ml'])]\n]).drop_duplicates()\n# Define Central Square location\ncentral_square_point = gpd.GeoSeries([gpd.points_from_xy(-71.0865, 42.3656)], crs=parcels.crs)\ncentral_square = central_square_point.to_crs(epsg=26986)\n# Filter for parcels within 500m of Central Square\nrenovated_commercial_near_central = renovated_commercial[renovated_commercial.geometry.distance(central_square.iloc[0]) <= 500].copy()\n# Sort by parcel ID\nresult_ids = renovated_commercial_near_central['ml'].tolist()\nresult_ids.sort()\n# Output results\nprint(result_ids)",
    "Answer": "[\"Error: 'last_renovation_year\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "Two Hard Constraints"
  },
  {
    "Query": "find retail pods or kiosks in high foot traffic areas AND within 250 meters of a subway station",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define retail pod/kiosk POI codes\nretail_pod_codes = ['POI_1000070', 'POI_1000071', 'POI_1000072', 'POI_1000073']\n# Define subway station locations\nsubway_stations = [\n    (-71.1189, 42.3736),  # Harvard Square\n    (-71.1031, 42.3656),  # Central Square\n    (-71.0865, 42.3625),  # Kendall/MIT\n    (-71.1226, 42.3782),  # Porter Square\n    (-71.1429, 42.3954)   # Alewife\n]\nsubway_gdf = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy([lon], [lat])[0] for lon, lat in subway_stations],\n    crs=parcels.crs\n)\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\nsubway_proj = subway_gdf.to_crs(epsg=26986)\n# Filter for retail pods/kiosks\nretail_pods = poi_proj[poi_proj['poi_code'].astype(str).isin(retail_pod_codes)].copy()\n# Find high foot traffic retail pods/kiosks (top 20 by spend)\npod_spend = spend[spend['poi_id'].isin(retail_pods['poi_id'])]\ntop_pods = pod_spend.nlargest(20, 'total_spend')['poi_id'].tolist()\nhigh_traffic_pods = retail_pods[retail_pods['poi_id'].isin(top_pods)].copy()\n# Filter for pods within 250m of subway stations\n# Create 250m buffer around subway stations\nsubway_buffers = [geom.buffer(250) for geom in subway_proj.geometry]\nunion_buffer = gpd.GeoSeries(subway_buffers).unary_union\n# Find pods within 250m of subway stations\nhigh_traffic_near_subway = high_traffic_pods[high_traffic_pods.geometry.intersects(union_buffer)].copy()\n# Convert back to original CRS\nresult_parcels = high_traffic_near_subway.to_crs(parcels.crs)\n# Sort by parcel ID (ml column)\nresult_ids = result_parcels['ml'].tolist()\nresult_ids.sort()\n# Print results\nprint(f",
    "Answer": null,
    "Category": "Simple_Constraints",
    "Subcategory": "Two Hard Constraints"
  },
  {
    "Query": "vacant commercial parcels larger than 3000 sq ft, preferably in areas with high consumer spending",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend_data = pd.read_csv('data/cambridge_spend_processed.csv')\n# Convert to projected CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Filter for vacant commercial parcels larger than 3000 sq ft\nvacant_commercial = parcels_proj[\n    (parcels_proj['use_code'].astype(str).str.startswith('3')) &  # Commercial use codes\n    (parcels_proj['vacant'] == 1) &  # Vacant\n    (parcels_proj['land_area'] > 3000)  # Larger than 3000 sq ft\n].copy()\n# Filter POI data for retail businesses\nretail_types = ['restaurant', 'clothing_store', 'department_store', 'grocery_store', \n                'convenience_store', 'furniture_store', 'hardware_store', 'electronics_store']\nretail_poi = poi_proj[poi_proj['business_type'].isin(retail_types)].copy()\n# Calculate consumer spending near each parcel\ndef calculate_spending(parcel_geom, poi_geoms, spend_data, buffer_distance=200):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    # Find relevant retail POI within buffer\n    relevant_poi = poi_geoms[poi_geoms.geometry.intersects(buffered_geom)].copy()\n    \n    if relevant_poi.empty:\n        return 0  # No POI, no spending\n    \n    # Calculate spending based on POI type\n    total_spending = 0\n    for idx, row in relevant_poi.iterrows():\n        poi_type = row['business_type']\n        if poi_type in ['restaurant', 'clothing_store', 'department_store', 'grocery_store']:\n            # Use average spending for these types\n            avg_spend = spend_data.loc[spend_data['business_type'] == poi_type, 'average_spending'].values\n            if avg_spend.size > 0:\n                total_spending += avg_spend[0]\n        elif poi_type in ['convenience_store', 'furniture_store', 'hardware_store', 'electronics_store']:\n            # Use a different average for these types\n            avg_spend = spend_data.loc[spend_data['business_type'] == poi_type, 'average_spending'].values\n            if avg_spend.size > 0:\n                total_spending += avg_spend[0]\n    \n    return total_spending\n# Calculate spending for each parcel with retail POI\nvacant_commercial.loc[:, 'predicted_spending'] = vacant_commercial.geometry.apply(\n    lambda geom: calculate_spending(geom, retail_poi, spend_data)\n)\n# Sort by predicted spending (higher is better)\nresult_parcels = vacant_commercial.sort_values('predicted_spending', ascending=False)\n# Convert back to original CRS\nresult_ids = result_parcels['ml'].tolist()\n# Output results\nprint(f\"Found {len(result_parcels)} parcels matching criteria\")\nprint(f\"Parcel IDs (sorted by predicted spending): {result_ids}\")",
    "Answer": "[\"Error: 'vacant\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "One Hard + One Soft Constraint"
  },
  {
    "Query": "parcels for office use larger than 10000 sq ft, prioritizing locations with a high percentage of residents aged 18-64",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Filter for office-use codes\noffice_use_codes = ['340', '343', '345', '346', '0340', '404', '406']\noffice_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(office_use_codes)].copy()\n# Filter by size (>10,000 sq ft)\nlarge_office_parcels = office_parcels[office_parcels['land_area'] > 10000].copy()\n# Prioritize by proximity to areas with high proportion of residents aged 18-64\n# Define high proportion threshold (e.g., >50%)\nhigh_age_pct = 50\n# Filter for areas with high proportion of 18-64\nhigh_age_areas = census_proj[census_proj['pct_18_64'] > high_age_pct].copy()\n# Sort by proximity to high age areas\ndef prioritize_by_age_proximity(parcel_geom, high_age_geoms, buffer_distance=200):\n    buffered_geoms = [geom.buffer(buffer_distance) for geom in high_age_geoms]\n    if not buffered_geoms:\n        return float('inf')  # No high age areas, assign low priority\n    return min(geom.distance(parcel_geom) for geom in buffered_geoms)\n# Get high age area geometries\nhigh_age_geoms = high_age_areas['geometry'].tolist()\n# Calculate priority score (lower is better)\nlarge_office_parcels.loc[:, 'age_priority'] = large_office_parcels.geometry.apply(\n    lambda geom: prioritize_by_age_proximity(geom, high_age_geoms)\n)\n# Sort by priority (closest to high age areas first)\nresult_parcels = large_office_parcels.sort_values('age_priority').copy()\n# Get parcel IDs (ml) for final result\nresult_ids = result_parcels['ml'].tolist()\n# Print results\nprint(f\"Found {len(result_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs (prioritized by age area proximity): {result_ids}\")",
    "Answer": "[\"1A-70\", \"11-146\", \"267F-301\", \"14-58\", \"44-99\", \"28-23\", \"267.2-272\", \"169-42\", \"160-11\", \"30-42\", \"67-66\", \"133-51\", \"267E-285\", \"11-40\", \"54-19\", \"110-87\", \"63-132\", \"23-149\", \"267D-305\", \"267.4-305\", \"14-45\", \"30-41\", \"267D-286\", \"133-33\", \"172-29\", \"116-117\", \"267.4-322\", \"265A-31\", \"41-36\", \"183-119\", \"17-84\", \"267.3-285\", \"69-179\", \"17-74\", \"168-13\", \"66-153\", \"68-77\", \"95-72\", \"119-95\", \"43-76\", \"10-16\", \"41-38\", \"44-100\", \"267D-315\", \"267.4-313\", \"268C-32\", \"267D-299\", \"15-28\", \"121-2\", \"168-41\", \"1A-201\", \"1A-209\", \"46-12\", \"39-88\", \"1A-213\", \"267E-279\", \"19-23\", \"96-124\", \"190-33\", \"14-47\", \"47-94\", \"267F-283\", \"30-35\", \"93-99\", \"19-22\", \"106-123\", \"129-11\", \"178-133\", \"69-183\", \"267D-329\", \"42-70\", \"71-55\", \"128-71\", \"134-59\", \"42-97\", \"43A-28\", \"81-103\", \"14-64\", \"267D-319\", \"68-76\", \"8-75\", \"107-136\", \"70-22\", \"70-74\", \"267.4-307\", \"152-52\", \"43-70\", \"1A-200\", \"267D-311\", \"169-102\", \"43A-16\", \"67-47\", \"267E-282\", \"169-99\", \"68-47\", \"165-57\", \"168-22\", \"13-23\", \"168-60\", \"267F-281\", \"95-75\", \"41-29\", \"265D-53\", \"1A-105\", \"39-173\", \"160-48\", \"70-86\", \"63-135\", \"191-112\", \"160-57\", \"43-73\", \"69-148\", \"181-88\", \"267.1-278\", \"14-44\", \"165-53\", \"91-208\", \"42-87\", \"95-71\", \"43A-21\", \"13-16\", \"41-26\", \"32-53\", \"90-133\", \"267.2-273\", \"14-39\", \"90-170\", \"184-168\", \"267F-391\", \"182-98\", \"268C-35\", \"31-15\", \"23-90\", \"9-41\", \"269-138\", \"175-68\", \"43-77\", \"30-40\", \"15-30\", \"1A-172\", \"105-81\", \"1A-190\", \"95-76\", \"203B-52\", \"128-70\", \"18-74\", \"44-104\", \"168-36\", \"63-128\", \"273-51\", \"160-14\", \"203A-76\", \"182-84\", \"15-3\", \"252-160\", \"267F-293\", \"226-67\", \"30-38\", \"43A-24\", \"80-175\", \"90-14\", \"114A-66\", \"129-58\", \"267.4-288\", \"267D-282\", \"165-55\", \"29-50\", \"67-67\", \"31-20\", \"168-33\", \"95-79\", \"64-6\", \"16-32\", \"43-78\", \"12-19\", \"267E-280\", \"267E-284\", \"267F-279\", \"267.2-267\", \"160-69\", \"267.4-319\", \"47-97\", \"88-53\", \"265A-29\", \"267F-296\", \"267.3-253\", \"92-127\", \"27-82\", \"55-18\", \"267.4-323\", \"261-77\", \"169-98\", \"67-48\", \"15-29\", \"267C-70\", \"93-73\", \"18-77\", \"14-36\", \"69-173\", \"54-25\", \"8-91\", \"16-23\", \"189-57\", \"267C-71\", \"265B-59\", \"44-105\", \"67-14\", \"95-78\", \"121-94\", \"69-165\", \"8-76\", \"96-109\", \"169-84\", \"267D-285\", \"267D-310\", \"267F-274\", \"42-86\", \"69-159\", \"90-169\", \"69-182\", \"95-74\", \"133-23\", \"41-37\", \"85-76\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "One Hard + One Soft Constraint"
  },
  {
    "Query": "retail parcels larger than 5000 sq ft, ideally in areas with a diverse mix of nearby businesses",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n# Filter for retail parcels larger than 5000 sq ft\nlarge_retail = parcels_proj[\n    (parcels_proj['use_code'].astype(str).isin(retail_use_codes)) &\n    (parcels_proj['land_area'] > 5000)\n].copy()\n# Calculate POI density\ndef calculate_poi_density(parcel_geom, poi_geoms, buffer_distance=100):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    poi_count = sum(1 for geom in poi_geoms if geom is not None and buffered_geom.contains(geom))\n    return poi_count / (buffer_distance ** 2)\n# Get POI geometries\npoi_geoms = poi['geometry'].tolist()\n# Calculate POI density for each retail parcel\nlarge_retail['poi_density'] = large_retail['geometry'].apply(\n    lambda geom: calculate_poi_density(geom, poi_geoms)\n)\n# Sort by POI density (higher is better)\nresult_parcels = large_retail.sort_values('poi_density', ascending=False)\n# Convert back to original CRS\nresult_ids = result_parcels['ml'].tolist()\n# Output results\nprint(f\"Found {len(result_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs (sorted by POI density): {result_ids}\")",
    "Answer": "[\"174-37\", \"140-148\", \"93-80\", \"199-31\", \"175-37\", \"84-12\", \"100-62\", \"21-121\", \"83-80\", \"230-71\", \"128-72\", \"85-66\", \"134-33\", \"169-46\", \"176-64\", \"254-82\", \"236-84\", \"162-54\", \"81-100\", \"110-91\", \"191-85\", \"107-117\", \"8-88\", \"125-73\", \"109-50\", \"260-76\", \"200-22\", \"179-87\", \"191-65\", \"18-64\", \"152-25\", \"234-178\", \"268B-15\", \"1A-189\", \"229-117\", \"16-11\", \"265C-25\", \"182-88\", \"265B-61\", \"174-27\", \"195-59\", \"160-85\", \"179-75\", \"20-82\", \"106-124\", \"156-25\", \"226-46\", \"169-47\", \"184-193\", \"260-46\", \"192-177\", \"84-101\", \"267E-234\", \"199-30\", \"184-159\", \"128-63\", \"267D-259\", \"192-121\", \"84-91\", \"183-100\", \"157-26\", \"107-9\", \"90-155\", \"92-88\", \"166-13\", \"180-57\", \"74-1\", \"252-172\", \"1A-211\", \"196-154\", \"265B-28\", \"199-90\", \"175-84\", \"70-91\", \"236-95\", \"34-8\", \"20-75\", \"119-90\", \"90-162\", \"154-97\", \"176-15\", \"18-65\", \"136-15\", \"93-78\", \"42-91\", \"141-80\", \"175-75\", \"21-16\", \"120-48\", \"273-2\", \"199-67\", \"162-26\", \"273-20\", \"88-48\", \"105-82\", \"105-68\", \"169-86\", \"155-42\", \"265B-26\", \"70-92\", \"116-12\", \"189-72\", \"174-36\", \"1A-192\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "One Hard + One Soft Constraint"
  },
  {
    "Query": "restaurant parcels larger than 2500 sq ft, preferably in locations with a high percentage of advanced degree holders",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define CRS\nparcels = parcels.to_crs(epsg=26986)\npoi = poi.to_crs(epsg=26986)\ncensus = census.to_crs(epsg=26986)\n# Filter for restaurant parcels (use specific restaurant use codes)\nrestaurant_use_codes = ['0140', '0141', '0142', '0146', '0123']\nrestaurant_parcels = parcels[parcels['use_code'].astype(str).isin(restaurant_use_codes)].copy()\n# Filter for large restaurant parcels (>2500 sq ft)\nlarge_restaurant_parcels = restaurant_parcels[restaurant_parcels['land_area'] > 2500].copy()\n# Spatial join with census data\n# First, ensure both datasets have same CRS\nlarge_restaurant_parcels = large_restaurant_parcels.to_crs(census.crs)\n# Perform spatial join\nparcels_with_census = gpd.sjoin(\n    large_restaurant_parcels,\n    census,\n    how='left',\n    predicate='within'\n)\n# Filter out any parcels that didn't match with census data\nparcels_with_census = parcels_with_census[parcels_with_census['pct_adv_deg'].notna()]\n# Sort by percentage of advanced degree holders (higher is better)\nresult_parcels = parcels_with_census.sort_values('pct_adv_deg', ascending=False)\n# Get parcel IDs (ml column)\nresult_ids = result_parcels['ml'].tolist()\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Print results\nprint(f\"Found {len(result_parcels)} large restaurant parcels with high educational attainment\")\nprint(f\"Parcel IDs (ml): {result_ids}\")",
    "Answer": "[\"Error: 'business_type\", \"\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "One Hard + One Soft Constraint"
  },
  {
    "Query": "commercial parcels larger than 4000 sq ft, prioritizing areas within 300m of busy retail streets",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define retail business codes\nretail_business_codes = ['101', '1011', '1014', '102', '1021', '1026', '103', '104', \n                         '1040', '105', '106', '107', '108', '109', '591', '592', \n                         '593', '594', '595', '596', '597', '598', '599']\n# Convert POI to same CRS as parcels\npoi = poi.to_crs(parcels.crs)\n# Filter for retail POI\nretail_poi = poi[poi['business_code'].astype(str).isin(retail_business_codes)].copy()\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\nretail_poi_proj = retail_poi.to_crs(epsg=26986)\n# Filter for commercial parcels larger than 4000 sq ft\ncommercial_codes = ['300', '302', '316', '323', '324', '325', '326', '327', '330', \n                   '332', '334', '340', '341', '343', '345', '346', '353', '362', \n                   '375', '404', '406', '0340', '0406']\nlarge_commercial = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_codes) & \n                                 (parcels_proj['land_area'] > 4000)].copy()\n# Create 300m buffer around retail POI\nretail_buffers = [geom.buffer(300) for geom in retail_poi_proj.geometry]\nunion_buffer = gpd.GeoSeries(retail_buffers).unary_union\n# Find large commercial parcels within 300m of retail POI\nresult_parcels = large_commercial[large_commercial.geometry.intersects(union_buffer)].copy()\n# Sort by proximity to retail POI (optional) - not implemented for brevity\n# Convert back to original CRS\nresult_ids = result_parcels['ml'].tolist()\n# Output results\nprint(result_ids)",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "One Hard + One Soft Constraint"
  },
  {
    "Query": "vacant parcels greater than 5000 sq ft, ideally located near popular dining spots",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=cambridge_crs)\npoi_proj = poi.to_crs(epsg=cambridge_crs)\n# Filter for dining POIs (restaurants, cafes, etc.)\ndining_types = ['restaurant', 'cafe', 'diner', 'bakery', 'brunch', 'bistro']\ndining_poi = poi_proj[poi_proj['business_type'].isin(dining_types)].copy()\n# Filter for vacant parcels (ml starts with '3')\nvacant_parcels = parcels_proj[parcels_proj['ml'].astype(str).str.startswith('3')].copy()\n# Filter for large vacant parcels (>5000 sq ft)\nlarge_vacant = vacant_parcels[vacant_parcels['land_area'] > 5000].copy()\n# Calculate spending for each dining POI\n# Merge dining POI with spending data\ndining_with_spend = dining_poi.merge(\n    spend,\n    left_on='business_id',\n    right_on='business_id',\n    how='left'\n)\n# Fill NaN values in spending with 0\ndining_with_spend['total_spend'] = dining_with_spend['total_spend'].fillna(0)\n# Define popular dining spots as top 20% in spending\ntop_20_percent_threshold = dining_with_spend['total_spend'].quantile(0.8)\npopular_dining = dining_with_spend[dining_with_spend['total_spend'] >= top_20_percent_threshold].copy()\n# Find large vacant parcels near popular dining spots\n# Create 5-minute walk buffer (approx. 0.25 miles) around popular dining spots\nbuffer_distance = 0.25 * 1609.34  # 0.25 miles in meters\npopular_dining['buffer'] = popular_dining.geometry.buffer(buffer_distance)\n# Combine buffers into a single geometry for union\nall_buffers = gpd.GeoSeries(popular_dining['buffer']).unary_union\n# Find large vacant parcels within 5-minute walk of popular dining spots\nlarge_near_popular = large_vacant[large_vacant.geometry.intersects(all_buffers)].copy()\n# Sort by proximity to popular dining spots\n# Calculate distance to nearest popular dining spot\ndef calculate_distance_to_nearest_dining(parcel_geom, popular_dining_geoms):\n    distances = [parcel_geom.distance(geom) for geom in popular_dining_geoms]\n    return min(distances)\n# Get geometries of popular dining spots\npopular_dining_geoms = popular_dining.geometry.tolist()\n# Calculate distance to nearest popular dining spot for each large vacant parcel\nlarge_near_popular.loc[:, 'distance_to_nearest_dining'] = large_near_popular.geometry.apply(\n    lambda geom: calculate_distance_to_nearest_dining(geom, popular_dining_geoms)\n)\n# Sort by distance (closer to popular dining spots first)\nresult_parcels = large_near_popular.sort_values('distance_to_nearest_dining').copy()\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} large vacant parcels near popular dining spots\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "One Hard + One Soft Constraint"
  },
  {
    "Query": "office parcels larger than 8000 sq ft, prioritizing areas with substantial foot traffic",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Filter for office parcels larger than 8000 sq ft\nlarge_office_parcels = parcels_proj[\n    (parcels_proj['use_code'].astype(str).str.startswith('34')) & \n    (parcels_proj['land_area'] > 8000)\n].copy()\n# Define foot traffic as POI count within 200m\ndef calculate_foot_traffic(parcel_geom, poi_geoms, buffer_distance=200):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    count = sum(1 for geom in poi_geoms if geom is not None and buffered_geom.contains(geom))\n    return count\n# Calculate foot traffic for each parcel\npoi_geoms = poi_proj['geometry'].tolist()\nlarge_office_parcels.loc[:, 'foot_traffic'] = large_office_parcels.geometry.apply(\n    lambda geom: calculate_foot_traffic(geom, poi_geoms)\n)\n# Sort by foot traffic (higher is better)\nresult_parcels = large_office_parcels.sort_values('foot_traffic', ascending=False)\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Simple_Constraints",
    "Subcategory": "One Hard + One Soft Constraint"
  },
  {
    "Query": "retail spaces greater than 2000 sq ft, ideally in neighborhoods with high educational attainment",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define retail use codes consistently\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Filter for retail parcels\nretail_parcels = parcels[parcels['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Filter by size (>2000 sq ft)\nlarge_retail_parcels = retail_parcels[retail_parcels['land_area'] > 2000].copy()\n# Project to metric CRS for accurate distance measurement\nlarge_retail_parcels_proj = large_retail_parcels.to_crs(epsg=26986)\n# Combine POI with retail type for more accurate educational attainment measure\npoi_with_type = poi.copy()\n# Filter for educational institutions\nedu_types = ['college', 'university', 'school', 'educational_institution']\nedu_poi = poi_with_type[poi_with_type['poi_type'].isin(edu_types)].copy()\n# Project POI to same CRS\nedu_poi_proj = edu_poi.to_crs(epsg=26986)\n# Calculate educational attainment for each retail parcel\ndef calculate_educational_attainment(parcel_geom, poi_geoms, buffer_distance=200):  # 200m buffer\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    # Count educational POI within buffer\n    count = sum(1 for geom in poi_geoms if geom is not None and buffered_geom.contains(geom))\n    return count\n# Get educational POI geometries\nedu_poi_geoms = edu_poi_proj['geometry'].tolist()\n# Calculate educational attainment for each parcel\nlarge_retail_parcels_proj['educational_attainment'] = large_retail_parcels_proj['geometry'].apply(\n    lambda geom: calculate_educational_attainment(geom, edu_poi_geoms)\n)\n# Sort by educational attainment (higher is better)\nresult_parcels = large_retail_parcels_proj.sort_values('educational_attainment', ascending=False)\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Get parcel IDs\nresult_ids = result_parcels['ml'].tolist()\n# Print results\nprint(f",
    "Answer": null,
    "Category": "Simple_Constraints",
    "Subcategory": "One Hard + One Soft Constraint"
  },
  {
    "Query": "parcels for personal services larger than 1500 sq ft, preferably close to busy shopping areas",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Convert to projected CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Filter for personal services (use POI data for accurate business type)\npersonal_service_poi = [\n    '8111', '8112', '812', '813', '814', '323', '3241', '3244'\n]\n# Filter POI for personal services\npersonal_service_locations = poi_proj[poi_proj['poi_type'].astype(str).isin(personal_service_poi)].copy()\n# Filter parcels larger than 1500 sq ft\nlarge_parcels = parcels_proj[parcels_proj['land_area'] > 1500].copy()\n# Filter personal service POI by proximity to large parcels\n# Calculate 500 ft buffer around each large parcel\nbuffer_distance = 500 * 0.3048  # 500 ft in meters\nlarge_parcel_buffers = [geom.buffer(buffer_distance) for geom in large_parcels.geometry]\n# Find personal service locations within 500 ft of large parcels\nnearby_services = []\nfor i, buffer in enumerate(large_parcel_buffers):\n    # Find POI within buffer\n    poi_nearby = personal_service_locations[personal_service_locations.geometry.intersects(buffer)]\n    nearby_services.append(poi_nearby)\n# Combine results\nnearby_services = pd.concat(nearby_services)\n# Sort by distance to each large parcel (optional)\n# Convert back to original CRS\nnearby_services = nearby_services.to_crs(parcels.crs)\n# Filter for valid results\nvalid_parcels = large_parcels[large_parcels['ml'].isin(nearby_services['ml'])]\n# Sort by parcel ID\nresult_ids = valid_parcels['ml'].tolist()\nresult_ids.sort()\n# Print results\nprint(f\"Found {len(valid_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "One Hard + One Soft Constraint"
  },
  {
    "Query": "large commercial parcels (greater than 10000 sq ft), prioritizing areas known for vibrant street life",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define large commercial use codes\nlarge_commercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for large commercial parcels\nlarge_commercial_parcels = parcels_proj[\n    (parcels_proj['use_code'].astype(str).str.startswith(('3', '4'))) & \n    (parcels_proj['land_area'] > 10000)\n].copy()\n# Define vibrant area criteria\n# 1. High density of restaurants (POI type 'restaurant')\n# 2. High spending in nearby areas\n# 3. Areas with high population density (from census data)\n# Criterion 1: High restaurant density\n# Calculate restaurant density around each parcel\ndef calculate_restaurant_density(parcel_geom, poi_geoms, radius=200):\n    buffered_geom = parcel_geom.buffer(radius)\n    restaurant_count = sum(1 for geom in poi_geoms if geom and buffered_geom.contains(geom))\n    return restaurant_count\n# Get restaurant POI geometries\nrestaurant_poi_geoms = poi_proj[poi_proj['type'] == 'restaurant']['geometry'].tolist()\n# Calculate restaurant density for each large commercial parcel\nlarge_commercial_parcels.loc[:, 'restaurant_density'] = large_commercial_parcels.geometry.apply(\n    lambda geom: calculate_restaurant_density(geom, restaurant_poi_geoms)\n)\n# Criterion 2: High spending in nearby areas\n# Merge spend data with parcels\nparcels_with_spend = large_commercial_parcels.merge(\n    spend,\n    left_on='ml',\n    right_on='parcel_id',\n    how='left'\n)\n# Fill NaN values in spending with 0\nparcels_with_spend['total_spend'] = parcels_with_spend['total_spend'].fillna(0)\n# Criterion 3: High population density\n# Spatial join with census data\nparcels_with_census = gpd.sjoin(\n    parcels_with_spend,\n    census_proj,\n    how='left',\n    predicate='within'\n)\n# Calculate population density\nparcels_with_census['pop_density'] = (\n    parcels_with_census['total_population'] / \n    (parcels_with_census['land_area'] / 43560)  # Convert land area from sq ft to acres\n)\n# Combine criteria with weights\n# Adjust weights as needed to prioritize certain criteria\ndensity_weight = 0.4\nspend_weight = 0.4\ncensus_weight = 0.2\nparcels_with_census['vibrancy_score'] = (\n    (parcels_with_census['restaurant_density'] / parcels_with_census['restaurant_density'].max()) * density_weight +\n    (parcels_with_census['total_spend'] / parcels_with_census['total_spend'].max()) * spend_weight +\n    (parcels_with_census['pop_density'] / parcels_with_census['pop_density'].max()) * census_weight\n)\n# Sort by vibrancy score (higher is better)\nresult_parcels = parcels_with_census.sort_values('vibrancy_score', ascending=False)\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Get parcel IDs\nresult_ids = result_parcels['ml'].tolist()\n# Print results\nprint(f\"Found {len(result_parcels)} large commercial parcels\")\nprint(f\"Parcel IDs (vibrancy score): {result_ids}\")",
    "Answer": "[\"Error: 'parcel_id\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "One Hard + One Soft Constraint"
  },
  {
    "Query": "restaurant spaces over 2000 sq ft, ideally located in areas with strong local spending",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend_data = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define restaurant POI types\nrestaurant_types = [\n    'restaurant', 'cafe', 'fast_food', 'diner', 'pizzeria', \n    'food_court', 'sandwich_shop', 'tavern', 'brasserie', \n    'buffet', 'coffee_shop', 'tea_house', 'bakery'\n]\n# Project to appropriate CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Filter for large restaurant spaces (over 2000 sq ft)\nlarge_restaurant_ids = []\nfor restaurant_type in restaurant_types:\n    restaurant_poi = poi_proj[poi_proj['business_type'] == restaurant_type].copy()\n    if restaurant_poi.empty:\n        continue\n    # Find nearby parcels\n    restaurant_geom = restaurant_poi['geometry'].values[0]\n    restaurant_location = gpd.GeoDataFrame(\n        geometry=[restaurant_geom],\n        crs=poi_proj.crs\n    ).to_crs(epsg=26986)\n    \n    # Filter for restaurant use codes that indicate large spaces\n    large_space_codes = ['323', '3241', '3243', '3244']  # Common codes for large restaurants\n    nearby_parcels = parcels_proj[parcels_proj['ml'].astype(str).str.startswith(restaurant_location['ml'].values[0][:6])].copy()\n    \n    # Calculate spending for each nearby parcel\n    if not nearby_parcels.empty:\n        # Get census tract for each parcel\n        nearby_parcels = nearby_parcels.to_crs(epsg=26986)\n        parcel_tracts = gpd.sjoin(nearby_parcels, census_proj, how='left', predicate='within')\n        \n        # Calculate average spending for each parcel based on tract\n        if not parcel_tracts.empty:\n            # Merge with spending data\n            parcel_spend = parcel_tracts.merge(\n                spend_data,\n                left_on='census_tract',\n                right_on='tract',\n                how='left'\n            )\n            # Use total_spend if available, otherwise use avg_spend\n            if 'total_spend' in parcel_spend.columns:\n                parcel_spend['spend'] = parcel_spend['total_spend']\n            elif 'avg_spend' in parcel_spend.columns:\n                parcel_spend['spend'] = parcel_spend['avg_spend']\n            else:\n                parcel_spend['spend'] = 0\n            \n            # Filter for parcels with spending data\n            parcel_spend = parcel_spend[parcel_spend['spend'].notnull()]\n            if not parcel_spend.empty:\n                # Sort by spending (higher is better)\n                parcel_spend = parcel_spend.sort_values('spend', ascending=False)\n                \n                # Take top 3 parcels with highest spending\n                top_spend_parcels = parcel_spend.head(3)\n                large_restaurant_ids.extend(top_spend_parcels['ml'].tolist())\n# Remove duplicates and sort by ID\nlarge_restaurant_ids = sorted(set(large_restaurant_ids))\n# Print results\nprint(f\"Found {len(large_restaurant_ids)} large restaurant spaces in high-spending areas\")\nprint(f\"Parcel IDs: {large_restaurant_ids}\")",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "One Hard + One Soft Constraint"
  },
  {
    "Query": "office parcels larger than 6000 sq ft, prioritizing those near educational institutions",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define CONCORD_CIRCLE_CAMBRIDGE boundary\nconcord_circle = gpd.GeoDataFrame(geometry=[gpd.points_from_xy([-71.3945], [42.3676]).buffer(0.0025)[0]], crs=parcels.crs)\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\nconcord_circle_proj = concord_circle.to_crs(epsg=26986)\n# Filter for office parcels larger than 6000 sq ft\noffice_use_codes = ['340', '341', '343', '345', '346', '353', '362', '375']\nlarge_office_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(office_use_codes) & (parcels_proj['land_area'] > 6000)]\n# Filter by location within CONCORD_CIRCLE_CAMBRIDGE\nlarge_office_near_concord = large_office_parcels[large_office_parcels.geometry.distance(concord_circle_proj.iloc[0]) < 1000]\n# Prioritize by proximity to educational institutions\n# Define educational institution POI types\nedu_poi_types = ['school', 'university', 'college', 'educational_institution']\n# Filter for educational institution POIs\nedu_poi = poi[poi['poi_type'].isin(edu_poi_types)].copy()\n# Calculate distance to educational institutions\ndef calculate_edu_distance(parcel_geom, edu_poi_geoms):\n    return min(parcel_geom.distance(geom) for geom in edu_poi_geoms)\n# Get educational institution geometries\nedu_poi_geoms = edu_poi['geometry'].tolist()\n# Calculate distance to educational institutions for each parcel\nlarge_office_near_concord.loc[:, 'edu_distance'] = large_office_near_concord.geometry.apply(lambda geom: calculate_edu_distance(geom, edu_poi_geoms))\n# Sort by proximity to educational institutions (smaller distance = higher priority)\nresult_parcels = large_office_near_concord.sort_values('edu_distance')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(result_ids)",
    "Answer": "[\"Error: (<class 'geopandas.geoseries.GeoSeries'>, <class 'pandas.core.series.Series'>\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "One Hard + One Soft Constraint"
  },
  {
    "Query": "retail parcels over 3000 sq ft, ideally in areas with a mix of young professionals and families",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define retail use codes consistently\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Filter for retail parcels over 3000 sq ft\nlarge_retail_parcels = parcels[\n    (parcels['use_code'].astype(str).isin(retail_use_codes)) & \n    (parcels['land_area'] > 3000)\n].copy()\n# Project to metric CRS for accurate distance measurement\nlarge_retail_parcels_proj = large_retail_parcels.to_crs(epsg=26986)\n# Define young professional and family areas\nyoung_professional_tracts = ['350600', '350700', '350800']\nfamily_tracts = ['350400', '350500', '351000']\n# Filter POI for residential types\nresidential_poi = poi[poi['poi_type'].isin(['rentals', 'real_estate', 'homes'])].copy()\n# Function to score area around a parcel\ndef area_score(parcel_geom, proj_census, young_tracts, family_tracts, buffer=200):\n    buffered_geom = parcel_geom.buffer(buffer)\n    # Filter for relevant tracts\n    young_geom = proj_census[proj_census['tract'].isin(young_tracts)].geometry.unary_union\n    family_geom = proj_census[proj_census['tract'].isin(family_tracts)].geometry.unary_union\n    # Calculate scores\n    young_score = 1 if buffered_geom.intersects(young_geom) else 0\n    family_score = 1 if buffered_geom.intersects(family_geom) else 0\n    return young_score + family_score\n# Convert census to projected CRS\ncensus_proj = census.to_crs(epsg=26986)\n# Calculate area score for each parcel\nlarge_retail_parcels_proj['area_score'] = large_retail_parcels_proj.geometry.apply(\n    lambda geom: area_score(geom, census_proj, young_professional_tracts, family_tracts)\n)\n# Sort by score (higher is better)\nresult_parcels = large_retail_parcels_proj.sort_values('area_score', ascending=False)\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(result_ids)",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Simple_Constraints",
    "Subcategory": "One Hard + One Soft Constraint"
  }
]