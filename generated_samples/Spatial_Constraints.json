[
  {
    "Query": "find parcels that are within 200 meters of a coffee shop.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Convert to projected CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Define coffee shop POI type codes\ncoffee_shop_codes = ['8121', '8133']  # Standardized codes for coffee shops\n# Filter for coffee shops\ncoffee_shops = poi_proj[poi_proj['poi_type'].astype(str).isin(coffee_shop_codes)]\n# Ensure there are coffee shops to avoid empty GeoDataFrame issues\nif coffee_shops.empty:\n    print(\"No coffee shops found in POI data.\")\n    # If no coffee shops, return all parcels\n    result_parcels = parcels_proj\nelse:\n    # Find parcels within 200m of any coffee shop\n    # Use buffered geometry for efficient spatial query\n    coffee_buffers = coffee_shops.geometry.buffer(200)  # 200m buffer\n    coffee_union_buffer = gpd.GeoSeries(coffee_buffers).unary_union\n    # Find nearby parcels\n    nearby_parcels = parcels_proj[parcels_proj.geometry.intersects(coffee_union_buffer)]\n# Sort by parcel ID (ml column)\nresult_ids = nearby_parcels['ml'].sort_values().tolist()\n# Convert back to original CRS\nnearby_parcels = nearby_parcels.to_crs(parcels.crs)\n# Print results\nprint(f\"Found {len(nearby_parcels)} parcels within 200m of coffee shops\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Simple Buffer Queries"
  },
  {
    "Query": "find parcels that are within 500 meters of central square.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define Central Square location (approximate)\ncentral_square = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy([-71.0865, 42.3656])],\n    crs=parcels.crs\n)\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\ncentral_square_proj = central_square.to_crs(epsg=26986)\n# Define 500m buffer around Central Square\ncentral_buffer = central_square_proj.buffer(500)[0]\n# Filter parcels within 500m of Central Square\nparcels_near_central = parcels_proj[parcels_proj.geometry.intersects(central_buffer)]\n# Sort by parcel ID (ml column)\nresult_ids = sorted(parcels_near_central['ml'].tolist())\n# Print results\nprint(result_ids)",
    "Answer": "[\"Error: points_from_xy() missing 1 required positional argument: 'y\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Simple Buffer Queries"
  },
  {
    "Query": "find retail parcels that are within 300 meters of a subway station.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define subway station locations in Cambridge, MA\nsubway_stations = [\n    (-71.1189, 42.3736),  # Harvard Square\n    (-71.1032, 42.3656),  # Central Square\n    (-71.0865, 42.3625),  # Kendall/MIT\n    (-71.1226, 42.3782),  # Porter Square\n    (-71.1429, 42.3954)   # Alewife\n]\n# Create GeoDataFrame for subway stations\nsubway_gdf = gpd.GeoDataFrame(\n    subway_stations,\n    columns=['longitude', 'latitude'],\n    geometry=gpd.points_from_xy([pt[0] for pt in subway_stations], [pt[1] for pt in subway_stations]),\n    crs='EPSG:4326'\n)\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\nsubway_gdf_proj = subway_gdf.to_crs(epsg=26986)\n# Define retail use codes consistently\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Calculate 300m buffer around subway stations\nsubway_buffers = [geom.buffer(300) for geom in subway_gdf_proj.geometry]\nunion_buffer = gpd.GeoSeries(subway_buffers).unary_union\n# Find retail parcels within 300m of subway stations\nresult_parcels = retail_parcels[retail_parcels.geometry.intersects(union_buffer)].copy()\n# Sort by parcel ID (ml)\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(result_ids)",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Simple Buffer Queries"
  },
  {
    "Query": "find parcels that are at least 100 meters away from any restaurant.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\n# Define restaurant POI types\nrestaurant_types = ['restaurant', 'cafe', 'fast_food', 'diner', 'pizzeria', 'bakery']\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Filter for restaurants\nrestaurants = poi_proj[poi_proj['business_type'].isin(restaurant_types)].copy()\n# Calculate 100m buffer around restaurants\nrestaurant_buffers = [geom.buffer(100) for geom in restaurants.geometry]\n# Combine buffers into a single geometry\nunion_buffer = gpd.GeoSeries(restaurant_buffers).unary_union\n# Find parcels at least 100m away from any restaurant\n# This is equivalent to finding parcels whose geometries do not intersect the buffer\nparcels_away_from_restaurants = parcels_proj[~parcels_proj.geometry.intersects(union_buffer)].copy()\n# Sort by parcel ID (ml column)\nresult_ids = sorted(parcels_away_from_restaurants['ml'].tolist())\n# Convert back to original CRS\nparcels_away_from_restaurants = parcels_away_from_restaurants.to_crs(parcels.crs)\n# Print results\nprint(f",
    "Answer": null,
    "Category": "Spatial_Constraints",
    "Subcategory": "Simple Buffer Queries"
  },
  {
    "Query": "find parcels that are within 800 meters of harvard university.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define Harvard University location (approximate)\nharvard_location = (-71.1189, 42.3770)\n# Create GeoDataFrame for Harvard location\nharvard_gdf = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy([harvard_location[0]], [harvard_location[1]])],\n    crs=parcels.crs\n)\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\nharvard_gdf_proj = harvard_gdf.to_crs(epsg=26986)\n# Create 800m buffer around Harvard\nharvard_buffer = harvard_gdf_proj.buffer(800)[0]\n# Find parcels within 800m of Harvard\nnear_harvard_parcels = parcels_proj[parcels_proj.geometry.intersects(harvard_buffer)].copy()\n# Sort by parcel ID (ml)\nnear_harvard_parcels = near_harvard_parcels.sort_values('ml')\n# Convert back to original CRS\nnear_harvard_parcels = near_harvard_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = near_harvard_parcels['ml'].tolist()\nprint(result_ids)",
    "Answer": "[\"Error: Input must be valid geometry objects: <GeometryArray>\", \"<POINT (-71.119 42.377)>\", \"Length: 1, dtype: geometry\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Simple Buffer Queries"
  },
  {
    "Query": "find commercial parcels that are within 400 meters of a gym.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Convert to projected CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Define gym POI types\ngym_types = ['gym', 'fitness_center']\n# Filter for gyms\ngyms = poi_proj[poi_proj['poi_type'].isin(gym_types)].copy()\n# Filter for commercial parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith(('3', '31', '32', '33', '34', '340', '341', '342', '343', '345', '346', '353'))].copy()\n# Find gyms within 400m of commercial parcels\n# Sort gyms by ID for consistent results\ngyms = gyms.sort_values('ml')\n# Use spatial join with buffer for efficient querying\ngym_buffers = [geom.buffer(400) for geom in gyms.geometry]\ngym_union_buffer = gpd.GeoSeries(gym_buffers).unary_union\n# Filter commercial parcels by proximity to gyms\nnearby_parcels = commercial_parcels[commercial_parcels.geometry.intersects(gym_union_buffer)].copy()\n# Sort by parcel ID\nnearby_parcels = nearby_parcels.sort_values('ml')\n# Convert back to original CRS\nnearby_parcels = nearby_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = nearby_parcels['ml'].tolist()\nprint(result_ids)",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Simple Buffer Queries"
  },
  {
    "Query": "find parcels that are within 250 meters of a bank.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Define bank POI type codes\nbank_types = ['bank', 'credit_union', 'atm']\n# Filter for banks\nbanks = poi_proj[poi_proj['poi_type'].isin(bank_types)].copy()\n# Ensure there are banks to query against\nif banks.empty:\n    print(\"No bank POI found.\")\n    # Sort by ml if no banks (arbitrary decision)\n    result_ids = parcels_proj['ml'].tolist()\n    result_ids.sort()\n    print(f\"Parcel IDs: {result_ids}\")\n    exit()\n# Create 250m buffer around banks\nbank_buffers = [geom.buffer(250) for geom in banks.geometry]\nunion_buffer = gpd.GeoSeries(bank_buffers).unary_union\n# Find parcels within 250m of any bank\nnear_banks = parcels_proj[parcels_proj.geometry.intersects(union_buffer)].copy()\n# Sort by ml (parcel ID)\nresult_ids = near_banks['ml'].tolist()\nresult_ids.sort()\n# Print results\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Simple Buffer Queries"
  },
  {
    "Query": "find parcels that are at least 150 meters away from any clothing store.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define clothing store POI codes\nclothing_store_codes = ['723','725','726','727','728']\n# Filter for clothing stores\nclothing_stores = poi[poi['poi_code'].astype(str).isin(clothing_store_codes)].copy()\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\nclothing_stores_proj = clothing_stores.to_crs(epsg=26986)\n# Calculate 150m buffer around clothing stores\nclothing_buffers = [geom.buffer(150) for geom in clothing_stores_proj.geometry]\nclothing_union_buffer = gpd.GeoSeries(clothing_buffers).unary_union\n# Find parcels at least 150m away from any clothing store\n# This is equivalent to finding parcels whose geometry does not intersect the buffer\n# Use spatial index for efficiency\ndef is_far_from_clothing(parcel_geom, buffer_geom):\n    return not parcel_geom.intersects(buffer_geom)\n# Filter parcels\n# For large datasets, consider using spatial index for efficiency\n# For smaller datasets, this approach is simpler and easier to understand\n# Calculate buffers\n# For each parcel, check if it's far from clothing stores\n# Use .loc to avoid SettingWithCopyWarning\n# Sort by ml (parcel ID) for consistent output\nresult_parcels = parcels_proj[parcels_proj.geometry.apply(lambda geom: is_far_from_clothing(geom, clothing_union_buffer))]\nresult_ids = result_parcels['ml'].tolist()\nresult_ids.sort()\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nprint(f",
    "Answer": null,
    "Category": "Spatial_Constraints",
    "Subcategory": "Simple Buffer Queries"
  },
  {
    "Query": "find parcels that are within 350 meters of \u05d8\u05d9\u05d9\u05dc\u05d5\u05e8 \u05d1\u05d5\u05e8\u05d2\u05e8 \u05e1\u05e0\u05d3\u05d5\u05d5\u05d9\u05e5' \u05e7\u05e4\u05d4.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\n# Define projection for Cambridge, MA\ncambridge_crs = 'EPSG:26986'\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Define target POI: \u05d8\u05d9\u05d9\u05dc\u05d5\u05e8 \u05d1\u05d5\u05e8\u05d2\u05e8 \u05e1\u05e0\u05d3\u05d5\u05d5\u05d9\u05e5' \u05e7\u05e4\u05d4\ntarget_poi_name = '\u05d8\u05d9\u05d9\u05dc\u05d5\u05e8 \u05d1\u05d5\u05e8\u05d2\u05e8 \u05e1\u05e0\u05d3\u05d5\u05d5\u05d9\u05e5\\' \u05e7\u05e4\u05d4'\n# Find exact match for POI\ntarget_poi = poi_proj[poi_proj['name'] == target_poi_name]\n# If POI not found, return empty result\nif target_poi.empty:\n    print(\"Target POI not found\")\n    print([])\n    exit()\n# Get location of target POI\ntarget_poi_geom = target_poi.geometry.values[0]\n# Create 350m buffer around POI\nbuffer_distance = 350\ntarget_buffer = target_poi_proj.buffer(buffer_distance)\n# Find parcels within 350m of POI\nparcels_nearby = parcels_proj[parcels_proj.geometry.intersects(target_buffer)]\n# Sort by parcel ID (ml column)\nresult_ids = sorted(parcels_nearby['ml'].tolist())\n# Print results\nprint(result_ids)",
    "Answer": "[\"Target POI not found\", \"\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Simple Buffer Queries"
  },
  {
    "Query": "find parcels that are within 600 meters of kendall square.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\n# Define Kendall Square location (approximate)\nkendall_square = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy([-71.0822, 42.3625])],\n    crs=parcels.crs\n)\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\nkendall_square_proj = kendall_square.to_crs(epsg=26986)\n# Define 600m buffer around Kendall Square\nkendall_buffer = kendall_square_proj.buffer(600)[0]\n# Filter parcels within 600m of Kendall Square\nnear_kendall = parcels_proj[parcels_proj.geometry.intersects(kendall_buffer)]\n# Sort by proximity to Kendall Square (optional)\nnear_kendall = near_kendall.sort_values(\n    by=near_kendall.geometry.apply(lambda geom: geom.distance(kendall_buffer))\n)\n# Convert back to original CRS\nnear_kendall = near_kendall.to_crs(parcels.crs)\n# Output results\nresult_ids = near_kendall['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Spatial_Constraints",
    "Subcategory": "Simple Buffer Queries"
  },
  {
    "Query": "find parcels that are within 300 meters of a major library.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Convert to projected CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Define major libraries in Cambridge, MA\nlibraries = [\n    'Cambridge Public Library - Main Library',\n    'Cambridge Public Library - Central Square Branch',\n    'Cambridge Public Library - East Cambridge Branch',\n    'Cambridge Public Library - Porter Square Branch',\n    'Cambridge Public Library - Riverside Branch',\n    'Cambridge Public Library - West Cambridge Branch'\n]\n# Filter for library POIs\nlibrary_poi = poi_proj[poi_proj['name'].isin(libraries)].copy()\n# Find library locations\nlibrary_locations = library_poi.geometry.tolist()\n# Create union of library geometries\nif library_locations:\n    library_union = gpd.GeoSeries(library_locations).unary_union\nelse:\n    library_union = None\n# If no libraries found, return empty result\nif library_union is None:\n    print(\"No major libraries found.\")\n    print([])\n    exit()\n# Create GeoDataFrame for library union\nlibrary_gdf = gpd.GeoDataFrame(geometry=[library_union], crs=poi_proj.crs)\nlibrary_gdf_proj = library_gdf.to_crs(cambridge_crs)\n# Calculate 300m buffer around libraries\nlibrary_buffers = [geom.buffer(300) for geom in library_gdf_proj.geometry]\n# Find parcels within 300m of any library\nresult_parcels = []\nfor buffer in library_buffers:\n    # Use spatial index for efficiency\n    parcs_within_buffer = (\n        parcels_proj[parcels_proj.geometry.intersects(buffer)]\n        .copy()\n    )\n    result_parcels.append(parcs_within_buffer)\n# Combine results\nresult_parcels = pd.concat(result_parcels)\n# Remove duplicates\nresult_parcels = result_parcels.drop_duplicates()\n# Sort by parcel ID (ml)\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(result_ids)",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Simple Buffer Queries"
  },
  {
    "Query": "find restaurant parcels that are within 200 meters of a subway station.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define subway station locations (Harvard, Central, Kendall, Porter, Alewife)\nsubway_stations = [\n    (-71.1189, 42.3736),  # Harvard\n    (-71.1031, 42.3656),  # Central\n    (-71.0865, 42.3625),  # Kendall\n    (-71.1226, 42.3954),  # Porter\n    (-71.1429, 42.3956)   # Alewife\n]\n# Convert subway station coordinates to GeoDataFrame\nstation_geom = [Point(lon, lat) for lon, lat in subway_stations]\nsubway_gdf = gpd.GeoDataFrame(geometry=station_geom, crs=parcels.crs)\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\nsubway_proj = subway_gdf.to_crs(epsg=26986)\n# Define restaurant POI types\nrestaurant_types = [\n    'restaurant', 'cafe', 'fast_food', 'diner', 'pizzeria', \n    'food_court', 'bakery', 'brunch', 'bistro', 'coffee_shop'\n]\n# Filter for restaurant POIs\nrestaurant_poi = poi[poi['business_type'].isin(restaurant_types)].copy()\n# Project restaurant POIs to metric CRS\nrestaurant_poi_proj = restaurant_poi.to_crs(epsg=26986)\n# Find restaurant parcels that are within 200m of a subway station\n# Step 1: Find restaurant parcels\nrestaurant_parcels = parcels_proj[parcels_proj['ml'].isin(restaurant_poi_proj['ml'])].copy()\n# Step 2: Filter by proximity to subway stations\n# Create 200m buffer around subway stations\nsubway_buffers = [geom.buffer(200) for geom in subway_proj.geometry]\nunion_buffer = unary_union(subway_buffers)\n# Find restaurant parcels within 200m of subway stations\nresult_parcels = restaurant_parcels[restaurant_parcels.geometry.intersects(union_buffer)].copy()\n# Sort by parcel ID\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Spatial_Constraints",
    "Subcategory": "Simple Buffer Queries"
  },
  {
    "Query": "find parcels that are within 500 meters of cambridge city hall.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define Cambridge City Hall location (approximate)\ncity_hall_location = (-71.0822, 42.3736)  # (longitude, latitude)\n# Create GeoDataFrame for City Hall\ncity_hall_gdf = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy([city_hall_location[0]], [city_hall_location[1]])],\n    crs=parcels.crs\n)\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\ncity_hall_proj = city_hall_gdf.to_crs(epsg=26986)\n# Define 500m buffer around City Hall\ncity_hall_buffer = city_hall_proj.buffer(500).iloc[0]\n# Find parcels within 500m of City Hall\nnear_parcels = parcels_proj[parcels_proj.geometry.intersects(city_hall_buffer)].copy()\n# Sort by proximity to City Hall (optional)\nnear_parcels = near_parcels.sort_values(by='ml')\n# Convert back to original CRS\nnear_parcels = near_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = near_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Spatial_Constraints",
    "Subcategory": "Simple Buffer Queries"
  },
  {
    "Query": "find retail parcels that are at least 100 meters away from a competitor store.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\n# Define retail business codes\nretail_business_codes = ['101', '1010', '1011', '1012', '1013', '1014', '1015', \n                         '1016', '1017', '102', '1020', '103', '104', '105', \n                         '109', '201', '202', '203', '204', '205', '206', \n                         '207', '208', '1226']\n# Filter for retail parcels\nretail_parcels = parcels[parcels['business_code'].astype(str).isin(retail_business_codes)].copy()\n# Set CRS to projected for accurate distance measurement\nretail_parcels = retail_parcels.to_crs(epsg=26986)\n# Filter POI for competitor stores (retail businesses)\ncompetitor_stores = poi[poi['business_code'].astype(str).isin(retail_business_codes)].copy()\n# Set CRS to projected for accurate distance measurement\ncompetitor_stores = competitor_stores.to_crs(epsg=26986)\n# Find retail parcels that are at least 100m away from any competitor store\n# Calculate 100m buffer around competitor stores\ncompetitor_buffers = [geom.buffer(100) for geom in competitor_stores.geometry]\n# Combine buffers into a single geometry\nunion_buffer = gpd.GeoSeries(competitor_buffers).unary_union\n# Filter for parcels outside of buffer\n# Use spatial join with inverted predicate for efficiency\nparcels_outside_buffer = retail_parcels[~retail_parcels.geometry.intersects(union_buffer)].copy()\n# Sort by parcel ID (ml column)\nresult_ids = parcels_outside_buffer['ml'].tolist()\nresult_ids.sort()\n# Print results\nprint(result_ids)",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Simple Buffer Queries"
  },
  {
    "Query": "find parcels that are within 100 meters of a major intersection.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define major intersection locations in Cambridge, MA\nmajor_intersections = [\n    (-71.1189, 42.3736),  # Harvard Square\n    (-71.1031, 42.3656),  # Central Square\n    (-71.0865, 42.3625),  # Kendall Square\n    (-71.1226, 42.3782),  # Porter Square\n    (-71.1429, 42.3954)   # Alewife Square\n]\n# Convert to GeoDataFrame\nintersection_geom = [gpd.points_from_xy([lon], [lat]) for lon, lat in major_intersections]\nintersection_gdf = gpd.GeoDataFrame(geometry=intersection_geom, crs=parcels.crs)\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\nintersection_gdf_proj = intersection_gdf.to_crs(epsg=26986)\n# Create 100m buffer around intersections\nintersection_buffers = [geom.buffer(100) for geom in intersection_gdf_proj.geometry]\nunion_buffer = gpd.GeoSeries(intersection_buffers).unary_union\n# Find parcels within 100m of any major intersection\nparcels_near_intersections = parcels_proj[parcels_proj.geometry.intersects(union_buffer)]\n# Sort by parcel ID (ml column)\nresult_ids = sorted(parcels_near_intersections['ml'].tolist())\n# Print results\nprint(result_ids)",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Simple Buffer Queries"
  },
  {
    "Query": "find parcels within 300 meters of harvard university AND outside 200 meters of major roads",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define Harvard University location\nharvard_coords = (-71.1189, 42.3770)\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n# Create Harvard point\nharvard_point = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy([harvard_coords[0]], [harvard_coords[1]])[0]],\n    crs=parcels.crs\n).to_crs(epsg=26986)\n# CONSTRAINT 1: Within 300m of Harvard\nharvard_buffer_300m = harvard_point.buffer(300) \nparcels_near_harvard = parcels_proj[parcels_proj.geometry.intersects(harvard_buffer_300m.iloc[0])]\n# Load road data\n# Major roads in Cambridge, MA (approximate)\nmajor_road_ids = [\n    '3230', '3231', '3234', '3235', '3240', '3241', '3243', '3246', \n    '3250', '3251', '3260', '3261', '3262', '3263', '3270', '3271', \n    '3300', '3301', '3302', '3306', '3310', '3320', '3321', '3326',\n    '3340', '3400', '3401', '3406', '3410', '3426', '3430', '3431',\n    '3450', '3456', '3460', '3530', '3536', '3620', '3621', '3626',\n    '3650', '3660', '3670', '3680', '3700', '3706', '3710', '3720',\n    '3750', '3760', '3780', '3800', '3806', '3820', '3920', '3930',\n    '4046', '4060', '4080', '4100', '4110', '4120', '4140', '4150',\n    '4160', '4180', '4200', '4220', '4240', '4260', '4280', '4300',\n    '4320', '4340', '4360', '4400', '4420', '4440', '4460', '4480',\n    '4500', '4520', '4540', '4560', '4580', '4600', '4620', '4640',\n    '4660', '4680', '4700', '4720', '4740', '4760', '4780', '4800',\n    '4820', '4840', '4860', '4900', '4920', '4940', '4960', '5000',\n    '5020', '5040', '5060', '5080', '5100', '5120', '5140', '5160',\n    '5180', '5200', '5220', '5240', '5260', '5280', '5300', '5320',\n    '5340', '5360', '5380', '5400', '5420', '5440', '5460', '5480',\n    '5500', '5520', '5540', '5560', '5580', '5600', '5620', '5640',\n    '5660', '5680', '5700', '5720', '5740', '5760', '5780', '5800',\n    '5820', '5840', '5860', '5900', '5920', '5940', '5960', '6000',\n    '6020', '6040', '6060', '6080', '6100', '6120', '6140', '6160',\n    '6180', '6200', '6220', '6240', '6260', '6280', '6300', '6320',\n    '6340', '6360', '6400', '6420', '6440', '6460', '6480', '6500',\n    '6520', '6540', '6560', '6580', '6600', '6620', '6640', '6660',\n    '6680', '6700', '6720', '6740', '6760', '6780', '6800', '6820',\n    '6840', '6860', '6900', '6920', '6940', '6960', '7000', '7020',\n    '7040', '7060', '7080', '7100', '7120', '7140', '7160', '7180',\n    '7200', '7220', '7240', '7260', '7280', '7300', '7320', '7340',\n    '7360', '7400', '7420', '7440', '7460', '7480', '7500', '7520',\n    '7540', '7560', '7580', '7600', '7620', '7640', '7660', '7680',\n    '7700', '7720', '7740', '7760', '7780', '7800', '7820', '7840',\n    '7860', '7900', '7920', '7940', '7960', '8000', '8020', '8040',\n    '8060', '8080', '8100', '8120', '8140', '8160', '8180', '8200',\n    '8220', '8240', '8260', '8280', '8300', '8320', '8340', '8360',\n    '8400', '8420', '8440', '8460', '8480', '8500', '8520', '8540',\n    '8560', '8580', '8600', '8620', '8640', '8660', '8680', '8700',\n    '8720', '8740', '8760', '8780', '8800', '8820', '8840', '8860',\n    '8880', '8900', '8920', '8940', '8960', '9000', '9020', '9040',\n    '9060', '9080', '9100', '9120', '9140', '9160', '9180', '9200',\n    '9220', '9240', '9260', '9280', '9300', '9320', '9340', '9360',\n    '9400', '9420', '9440', '9460', '9480', '9500', '9520', '9540',\n    '9560', '9580', '9600', '9620', '9640', '9660', '9680', '9700',\n    '9720', '9740', '9760', '9780', '9800', '9820', '9840', '9860',\n    '9880', '9900', '9920', '9940', '9960'\n]\n# Filter for major roads\nmajor_roads = parcels_proj[parcels_proj['ml'].astype(str).isin(major_road_ids)]\n# CONSTRAINT 2: Outside 200m of major roads\nroad_buffer_200m = major_roads.buffer(200)\nparcels_far_from_roads = parcels_near_harvard[~parcels_near_harvard.geometry.intersects(road_buffer_200m.unary_union)]\n# Convert back to original CRS\nfinal_parcels = parcels_far_from_roads.to_crs(parcels.crs)\n# Sort by parcel ID\nfinal_parcels = final_parcels.sort_values('ml')\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Nested Spatial Relationships"
  },
  {
    "Query": "find commercial parcels within 400 meters of central square AND at least 150 meters from any industrial land",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\n# Define Central Square location (approximate)\ncentral_square = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy([-71.0865], [42.3656])],\n    crs=parcels.crs\n).to_crs(cambridge_crs)\n# Define industrial use codes\nindustrial_use_codes = ['300', '302', '316', '323', '324', '325', '326', '327', '330', '332', '334', '340', '341', '343', '345', '346', '353', '362', '375']\n# Filter for commercial parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith(('3', '4', '5'))].copy()\n# Filter for POI near Central Square (within 400m)\ncentral_square_buffer = central_square.buffer(400)  # 400m buffer\npoi_near_central = poi[poi.geometry.apply(lambda x: any(b.contains(x) for b in central_square_buffer))].copy()\n# Filter for industrial parcels\nindustrial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(industrial_use_codes)].copy()\n# Filter for parcels at least 150m from any industrial land\ndef is_far_from_industrial(parcel_geom, industrial_geoms, min_distance=150):\n    return all(parcel_geom.distance(geom) >= min_distance for geom in industrial_geoms)\n# Get industrial geometries\nindustrial_geoms = industrial_parcels.geometry.tolist()\n# Filter commercial parcels by POI near Central Square\ncommercial_near_poi = commercial_parcels[commercial_parcels['ml'].isin(poi_near_central['ml'])].copy()\n# Filter by distance from industrial land\nfinal_parcels = []\nfor idx, row in commercial_near_poi.iterrows():\n    if is_far_from_industrial(row.geometry, industrial_geoms):\n        final_parcels.append(row['ml'])\n# Sort by parcel ID\nfinal_parcels.sort()\n# Convert back to original CRS\nfinal_parcels = [p for p in final_parcels if p in commercial_near_poi['ml'].values]\n# Print results\nprint(f\"Found {len(final_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {final_parcels}\")",
    "Answer": "[\"Error: Input must be valid geometry objects: <GeometryArray>\", \"<POINT (-71.086 42.366)>\", \"Length: 1, dtype: geometry\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Nested Spatial Relationships"
  },
  {
    "Query": "find retail parcels within 500 meters of mit AND within 300 meters of high foot traffic area (restaurants, cafes)",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Filter for retail parcels\nretail_parcels = parcels[parcels['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Define MIT location (approximate centroid)\nmit_location = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy(-71.09416, 42.3601)],\n    crs=parcels.crs\n)\n# Project to metric CRS for accurate buffering\nretail_parcels_proj = retail_parcels.to_crs(epsg=26986)\nmit_location_proj = mit_location.to_crs(epsg=26986)\n# Create 500m buffer around MIT\nmit_buffer = mit_location_proj.buffer(500).iloc[0]\n# Filter for retail parcels within 500m of MIT\nparcels_near_mit = retail_parcels_proj[retail_parcels_proj.geometry.intersects(mit_buffer)].copy()\n# Define foot traffic POI types (restaurants and cafes)\nrestaurant_types = ['restaurant', 'cafe']\n# Filter POI for restaurants and cafes\nfoot_traffic_poi = poi[poi['business_type'].isin(restaurant_types)].copy()\n# Project to metric CRS\nfoot_traffic_poi_proj = foot_traffic_poi.to_crs(epsg=26986)\n# Create 300m buffer around foot traffic POIs\nfoot_traffic_buffers = [geom.buffer(300) for geom in foot_traffic_poi_proj.geometry]\n# Combine foot traffic POI buffers into a single geometry\ncombined_foot_traffic_buffer = gpd.GeoSeries(foot_traffic_buffers).unary_union\n# Filter for retail parcels near high foot traffic areas\nparcels_near_foot_traffic = parcels_near_mit[parcels_near_mit.geometry.intersects(combined_foot_traffic_buffer)].copy()\n# Convert back to original CRS\nparcels_near_foot_traffic = parcels_near_foot_traffic.to_crs(parcels.crs)\n# Sort by parcel ID (ml column)\nresult_ids = sorted(parcels_near_foot_traffic['ml'].tolist())\n# Print results\nprint(f\"Found {len(parcels_near_foot_traffic)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Nested Spatial Relationships"
  },
  {
    "Query": "find parcels within 250 meters of cambridge public library AND at least 100 meters from residential areas",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Define Cambridge Public Library location\ncambridge_library_location = (-71.1033, 42.3736)\n# Create library point\nlibrary_point = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy([cambridge_library_location[0]], [cambridge_library_location[1]])[0]],\n    crs=parcels.crs\n).to_crs(cambridge_crs)\n# Filter for library POI\nlibrary_poi = poi_proj[poi_proj['name'].str.contains('cambridge public library', case=False)].iloc[0]\n# Create 250m buffer around library\nlibrary_buffer_250m = library_poi.geometry.buffer(250)\n# Filter parcels within 250m of library\nparcels_near_library = parcels_proj[parcels_proj.geometry.intersects(library_buffer_250m)]\n# Define residential use codes\nresidential_use_codes = [\n    '101', '1014', '102', '1024', '104', '109', '1094', '1095', '1099', \n    '121', '970', '9700', '942', '9420', '943', '9430', '946', '9460'\n]\n# Filter for residential parcels\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_use_codes)]\n# Create 100m buffer around residential areas\nresidential_buffers_100m = [geom.buffer(100) for geom in residential_parcels.geometry]\n# Combine residential buffers into a single geometry\ncombined_residential_buffer_100m = gpd.GeoSeries(residential_buffers_100m).unary_union\n# Filter out parcels that are too close to residential areas (at least 100m away)\nparcels_away_from_residential = parcels_near_library[~parcels_near_library.geometry.intersects(combined_residential_buffer_100m)]\n# Convert back to original CRS\nparcels_away_from_residential = parcels_away_from_residential.to_crs(parcels.crs)\n# Sort by ml (parcel ID)\nresult_ids = sorted(parcels_away_from_residential['ml'].tolist())\n# Print results\nprint(result_ids)",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Nested Spatial Relationships"
  },
  {
    "Query": "find parcels within 300 meters of alewife station AND outside 150 meters of heavy traffic roads",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define heavy traffic road types\nheavy_traffic_road_types = ['Highway', 'Major Road', 'Minor Road']\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n# Define Alewife Station location (approximate)\nalewife_station = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy([-71.1429, 42.3954])],\n    crs=parcels.crs\n).to_crs(epsg=26986)\n# CONSTRAINT 1: Within 300m of Alewife Station\nalewife_buffer = alewife_station.buffer(300)\n# Filter by proximity to Alewife Station\nparcels_near_alewife = parcels_proj[parcels_proj.geometry.intersects(alewife_buffer.iloc[0])]\n# Define heavy traffic roads\nheavy_traffic_roads = poi[poi['business_type'].isin(['gas_station', 'car_repair', 'car_dealer', 'toll_booth'])]\n# PROJECT HEAVY TRAFFIC ROADS\nheavy_traffic_roads_proj = heavy_traffic_roads.to_crs(epsg=26986)\n# CONSTRAINT 2: Outside 150m of heavy traffic roads\n# Create 150m buffer around heavy traffic roads\nheavy_traffic_buffers = [geom.buffer(150) for geom in heavy_traffic_roads_proj.geometry]\n# Filter out parcels within 150m of heavy traffic roads\nparcels_safe_from_traffic = parcels_near_alewife[\n    ~parcels_near_alewife.geometry.intersects(heavy_traffic_buffers[0])\n]\n# Sort by parcel ID (ml) for consistency\nresult_ids = sorted(parcels_safe_from_traffic['ml'].tolist())\n# Print results\nprint(f\"Found {len(parcels_safe_from_traffic)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: points_from_xy() missing 1 required positional argument: 'y\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Nested Spatial Relationships"
  },
  {
    "Query": "find commercial parcels within 400 meters of harvard square AND at least 200 meters from any large retail store",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Convert to projected CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Define Harvard Square location\nharvard_square = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy(-71.1189, 42.3736)],\n    crs=parcels.crs\n).to_crs(cambridge_crs)\n# Filter for commercial parcels\ncommercial_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith(('3', '32', '34'))]\n# Filter for large retail stores (e.g., department stores, big box stores)\nlarge_retail_codes = ['323', '324', '325', '326', '327', '330', '332', '334']\nlarge_retail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith(('32', '33'))]\n# Condition 1: Within 400m of Harvard Square\nharvard_buffer = harvard_square.buffer(400)\nparcels_near_harvard = commercial_parcels[commercial_parcels.geometry.intersects(harvard_buffer.iloc[0])]\n# Condition 2: At least 200m from any large retail store\n# For each parcel near Harvard, check distance to large retail stores\ndef is_far_from_large_retail(parcel_geom, large_retail_geoms, min_distance=200):\n    # Calculate distances to all large retail stores\n    distances = [parcel_geom.distance(geom) for geom in large_retail_geoms]\n    # Check if at least one distance is greater than min_distance\n    return any(d >= min_distance for d in distances)\n# Get large retail store geometries\nlarge_retail_geoms = large_retail_parcels.geometry.tolist()\n# Filter by second condition\nparcels_meeting_both_conditions = []\nfor idx, row in parcels_near_harvard.iterrows():\n    if is_far_from_large_retail(row.geometry, large_retail_geoms):\n        parcels_meeting_both_conditions.append(row)\n# Convert back to original CRS\nfinal_parcels = pd.DataFrame(parcels_meeting_both_conditions).copy()\nfinal_parcels = final_parcels.to_crs(parcels.crs)\n# Sort by parcel ID (ml)\nfinal_parcels = final_parcels.sort_values('ml')\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} parcels meeting both conditions\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: 'data' should be array of geometry objects. Use from_shapely, from_wkb, from_wkt functions to construct a GeometryArray.\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Nested Spatial Relationships"
  },
  {
    "Query": "find parcels within 500 meters of boston university AND at least 100 meters from any hospital or medical center",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define Boston University location\nbu_location = (-71.1054, 42.3365)\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n# Create BU point and buffer\nbu_point = gpd.GeoDataFrame(geometry=[gpd.points_from_xy([bu_location[0]], [bu_location[1]])[0]], \n                                       crs=parcels.crs).to_crs(epsg=26986)\nbu_buffer_500m = bu_point.buffer(500).iloc[0]\n# Filter for parcels within 500m of BU\nparcels_near_bu = parcels_proj[parcels_proj.geometry.intersects(bu_buffer_500m)].copy()\n# Define hospital locations\nhospital_locations = [\n    (-71.1065, 42.3501),  # Boston Medical Center\n    (-71.1215, 42.3519),  # Tufts Medical Center\n    (-71.0623, 42.3676),  # Massachusetts General Hospital\n    (-71.0759, 42.3625)   # Brigham and Women's Hospital\n]\n# Create hospital points\nhospital_points = gpd.GeoDataFrame(geometry=[gpd.points_from_xy(lon, lat)[0] for lon, lat in hospital_locations], \n                                      crs=parcels.crs).to_crs(epsg=26986)\n# Create hospital buffer (100m)\nhospital_buffers = [point.buffer(100) for point in hospital_points.geometry]\n# Combine hospital buffers\ncombined_hospital_buffer = gpd.GeoSeries(hospital_buffers).unary_union\n# Filter for parcels at least 100m from any hospital\nparcels_safe_from_hospitals = parcels_near_bu[~parcels_near_bu.geometry.intersects(combined_hospital_buffer)].copy()\n# Sort by parcel ID (ml)\nresult_parcels = parcels_safe_from_hospitals.sort_values('ml')\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Spatial_Constraints",
    "Subcategory": "Nested Spatial Relationships"
  },
  {
    "Query": "find residential parcels within 200 meters of a public park AND NOT within 150 meters of any major highway",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Convert to projected CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Define park and highway geometries\nparks = poi_proj[poi_proj['poi_type'] == 'park'].copy()\nhighways = poi_proj[poi_proj['poi_type'] == 'highway'].copy()\n# Filter for residential parcels\nresidential_codes = [\n    '101', '1014', '102', '1024', '1025', '103', '104', '109', '1094', '1095',\n    '1099', '121', '122', '123', '124', '125', '126', '130', '131', '132',\n    '970', '9700', '9424', '9425'\n]\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_codes)].copy()\n# CONDITION 1: Within 200m of a park\npark_buffer = parks.geometry.unary_union.buffer(200)  # 200m buffer\nnear_parks = residential_parcels[residential_parcels.geometry.intersects(park_buffer)].copy()\n# CONDITION 2: NOT within 150m of any major highway\n# Major highways are typically classified as 'highway' in POI data\n# Create 150m buffer around highways\nif not highways.empty:\n    highway_buffer = highways.geometry.unary_union.buffer(150)  # 150m buffer\n    # Filter out parcels within 150m of highways\n    near_parks = near_parks[~near_parks.geometry.intersects(highway_buffer)].copy()\n# Convert back to original CRS\nfinal_parcels = near_parks.to_crs(parcels.crs)\n# Sort by parcel ID (ml)\nfinal_parcels = final_parcels.sort_values('ml')\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(result_ids)",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Nested Spatial Relationships"
  },
  {
    "Query": "find parcels within 300 meters of harvard business school AND at least 100 meters from any type of school",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Define Harvard Business School location\nhbs_location = (-71.1189, 42.3676)  # HBS coordinates\nhbs_point = gpd.GeoDataFrame(geometry=[gpd.points_from_xy(*hbs_location)], crs=parcels.crs)\nhbs_point_proj = hbs_point.to_crs(cambridge_crs)\n# Filter for school POIs\nschool_types = ['school', 'college', 'university']\nschools_proj = poi_proj[poi_proj['poi_type'].isin(school_types)].copy()\n# CONDITION 1: Parcels within 300m of Harvard Business School\nhbs_buffer_300m = hbs_point_proj.buffer(300)  # 300m buffer\n# CONDITION 2: Parcels at least 100m from any school\n# Get school locations\nschool_locations = schools_proj.geometry.tolist()\n# Create 100m buffer around each school\nschool_buffers_100m = [loc.buffer(100) for loc in school_locations]\n# Combine school buffers into a single geometry\nunion_school_buffers = gpd.GeoSeries(school_buffers_100m).unary_union\n# Filter for parcels within 300m of HBS\nparcels_near_hbs = parcels_proj[parcels_proj.intersects(hbs_buffer_300m.iloc[0])].copy()\n# Filter for parcels at least 100m from any school\nparcels_far_from_schools = parcels_proj[~parcels_proj.intersects(union_school_buffers)].copy()\n# Combine conditions (AND)\nfinal_parcels = pd.merge(\n    parcels_near_hbs,\n    parcels_far_from_schools,\n    how='inner',\n    on='ml'\n)\n# Sort by parcel ID\nfinal_parcels = final_parcels.sort_values('ml')\n# Convert back to original CRS\nfinal_parcels = final_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Nested Spatial Relationships"
  },
  {
    "Query": "find parcels within 400 meters of cambridge city hall AND at least 250 meters from any industrial area",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Convert to projected CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Define Cambridge City Hall location (approximate)\ncity_hall_location = (-71.0825, 42.3736)  # (longitude, latitude)\ncity_hall_geom = gpd.GeoSeries(gpd.points_from_xy([city_hall_location[0]], [city_hall_location[1]]), crs=parcels.crs)\ncity_hall_geom_proj = city_hall_geom.to_crs(cambridge_crs)\n# Define industrial use codes\nindustrial_use_codes = ['300', '302', '316', '323', '324', '325', '326', '327', '330', '332', '334', '340', '341', '343', '345', '346', '353', '362', '375']\n# Filter for industrial parcels\nindustrial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(industrial_use_codes)].copy()\n# CONSTRAINT 1: Within 400m of Cambridge City Hall\n# Create 400m buffer around City Hall\ncity_hall_buffer = city_hall_geom_proj.buffer(400).iloc[0]\n# Filter for parcels within 400m of City Hall\nnear_city_hall_parcels = parcels_proj[parcels_proj.geometry.intersects(city_hall_buffer)].copy()\n# CONSTRAINT 2: At least 250m from any industrial area\n# Create 250m buffer around all industrial parcels\nindustrial_buffers = [geom.buffer(250) for geom in industrial_parcels.geometry]\n# Use unary_union for efficiency\ncombined_industrial_buffer = gpd.GeoSeries(industrial_buffers).unary_union\n# Filter out parcels that are within 250m of industrial areas\nfar_from_industrial_parcels = near_city_hall_parcels[~near_city_hall_parcels.geometry.intersects(combined_industrial_buffer)].copy()\n# Convert back to original CRS\nfinal_parcels = far_from_industrial_parcels.to_crs(parcels.crs)\n# Sort by parcel ID (ml column)\nfinal_parcels = final_parcels.sort_values('ml')\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Nested Spatial Relationships"
  },
  {
    "Query": "find commercial parcels within 500 meters of major tourist attractions (harvard, mit) AND NOT within 100 meters of chain restaurants",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define chain restaurant codes\nchain_restaurant_codes = ['0112', '0115', '0114', '0406', '0401', '0407', '0411', '0420', '0430', '0450']\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Define major tourist attractions (Harvard, MIT) as points\nharvard = gpd.GeoDataFrame(geometry=[gpd.points_from_xy(-71.1189, 42.3770)], crs=parcels.crs)\nmit = gpd.GeoDataFrame(geometry=[gpd.points_from_xy(-71.0942, 42.3601)], crs=parcels.crs)\nattractions = pd.concat([harvard, mit]).reset_index(drop=True)\nattractions_proj = attractions.to_crs(epsg=26986)\n# Filter for commercial parcels (use specific codes for consistency)\ncommercial_parcel_types = ['323', '324', '325', '326', '327', '330', '332', '334', '340', '341', \n                           '343', '345', '346', '353', '362', '375', '404', '406', '0340', '0406']\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith(('32', '33', '34', '40'))]\n# CONDITION 1: Within 500m of major tourist attractions\n# Create 500m buffer around attractions\nattraction_buffers = [geom.buffer(500) for geom in attractions_proj.geometry]\nunion_buffer = gpd.GeoSeries(attraction_buffers).unary_union\n# Filter for parcels within 500m of attractions\nparcels_near_attractions = commercial_parcels[commercial_parcels.geometry.intersects(union_buffer)]\n# CONDITION 2: NOT within 100m of chain restaurants\n# First, identify chain restaurants\nchain_restaurants = poi_proj[poi_proj['business_type'].astype(str).str.startswith('restaurant') & \n                              poi_proj['business_id'].isin(chain_restaurant_codes)]\n# Create 100m buffer around chain restaurants\nchain_buffers = [geom.buffer(100) for geom in chain_restaurants.geometry]\nunion_chain_buffer = gpd.GeoSeries(chain_buffers).unary_union\n# Filter out parcels that are within 100m of chain restaurants\nparcels_final = parcels_near_attractions[~parcels_near_attractions.geometry.intersects(union_chain_buffer)]\n# Sort by parcel ID (ml column)\nresult_ids = parcels_final['ml'].tolist()\nresult_ids.sort()\n# Print results\nprint(f\"Found {len(parcels_final)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Nested Spatial Relationships"
  },
  {
    "Query": "find retail parcels within 300 meters of any public transit stop AND at least 200 meters from another retail business",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define retail business types\nretail_types = ['restaurant', 'cafe', 'clothing_store', 'department_store', 'grocery_store', \n                'supermarket', 'convenience_store', 'furniture_store', 'hardware_store', \n                'electronics_store', 'department_store']\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith('3')]\n# Filter transit stops from POI data\ntransit_types = ['subway_station', 'bus_station', 'train_station']\ntransit_stops = poi_proj[poi_proj['business_type'].isin(transit_types)]\n# Condition 1: Within 300m of any transit stop\nretail_near_transit = retail_parcels.copy()\n# Create 300m buffer around transit stops\ntransit_buffers = [geom.buffer(300) for geom in transit_stops.geometry]\nunion_buffer = gpd.GeoSeries(transit_buffers).unary_union\n# Filter for parcels within 300m of transit stops\nretail_near_transit = retail_near_transit[retail_near_transit.geometry.intersects(union_buffer)]\n# Condition 2: At least 200m from another retail business\n# For each retail parcel, check distance to other retail parcels\ndef has_distance_from_other_retail(parcel_geom, parcel_id, all_retail, min_distance=200):\n    # Calculate distance to all other retail parcels\n    other_retail = all_retail[all_retail['ml'] != parcel_id]\n    distances = other_retail.geometry.distance(parcel_geom)\n    # Check if any are at least min_distance away\n    return any(distances >= min_distance)\n# Filter by second condition\nretail_final = []\nfor idx, row in retail_near_transit.iterrows():\n    if has_distance_from_other_retail(row.geometry, row['ml'], retail_parcels, min_distance=200):\n        retail_final.append(row['ml'])\n# Sort by parcel ID\nretail_final = sorted(retail_final)\n# Print results\nprint(f\"Found {len(retail_final)} parcels meeting both criteria\")\nprint(f\"Parcel IDs: {retail_final}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Nested Spatial Relationships"
  },
  {
    "Query": "find parcels within 250 meters of high-density residential area AND outside 150 meters of major roads",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define high-density residential codes\nhigh_density_res_codes = ['102', '104', '109', '111', '112', '121', '970']\n# Filter for high-density residential parcels\nhigh_density_parcels = parcels[parcels['use_code'].astype(str).isin(high_density_res_codes)].copy()\n# Project to metric CRS for accurate buffering\nhigh_density_parcels_proj = high_density_parcels.to_crs(epsg=26986)\n# Create 250m buffer around high-density residential areas\nhigh_density_buffers = [geom.buffer(250) for geom in high_density_parcels_proj.geometry]\n# Combine buffers into a single geometry\nunion_buffer = gpd.GeoSeries(high_density_buffers).unary_union\n# Filter for residential parcels within 250m of high-density areas\nresidential_parcels_near_hd = high_density_parcels_proj[high_density_parcels_proj.geometry.intersects(union_buffer)].copy()\n# Define major road types\nmajor_road_types = ['A', 'B', 'C', 'D', 'E', 'F']\n# Filter for major roads from POI data\nmajor_roads = poi[poi['poi_type'].astype(str).str.startswith('road')].copy()\n# Project to metric CRS\nmajor_roads_proj = major_roads.to_crs(epsg=26986)\n# Create 150m buffer around major roads\nmajor_road_buffers = [geom.buffer(150) for geom in major_roads_proj.geometry]\n# Combine road buffers into a single geometry\nunion_road_buffer = gpd.GeoSeries(major_road_buffers).unary_union\n# Filter for parcels outside 150m of major roads\nresidential_parcels_final = residential_parcels_near_hd[~residential_parcels_near_hd.geometry.intersects(union_road_buffer)].copy()\n# Convert back to original CRS\nresidential_parcels_final = residential_parcels_final.to_crs(parcels.crs)\n# Sort by parcel ID (ml)\nresult_ids = residential_parcels_final['ml'].tolist()\nresult_ids.sort()\n# Print results\nprint(f\"Found {len(residential_parcels_final)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Nested Spatial Relationships"
  },
  {
    "Query": "find parcels within 400 meters of mass ave AND at least 300 meters from any large retail store",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Define Mass Ave location\nmass_ave_coords = [\n    (-71.1054, 42.3676),  # Near Mass Ave and West St\n    (-71.1049, 42.3679),  # Near Mass Ave and West St\n    (-71.1036, 42.3684)   # Near Mass Ave and West St\n]\nmass_ave_geom = gpd.GeoSeries(\n    [gpd.points_from_xy(*coords) for coords in mass_ave_coords],\n    crs=parcels.crs\n).to_crs(cambridge_crs)\n# Create 400m buffer around Mass Ave\nmass_ave_buffer = mass_ave_geom.buffer(400).iloc[0]\n# Filter for parcels within 400m of Mass Ave\nparcels_near_mass_ave = parcels_proj[parcels_proj.geometry.intersects(mass_ave_buffer)].copy()\n# Define large retail store POI types\nlarge_retail_types = [\n    'supermarket', 'department_store', 'clothing_store', 'home_goods_store',\n    'electronics_store', 'furniture_store', 'hardware_store', 'grocery_store'\n]\n# Filter for large retail stores\nlarge_retail_stores = poi_proj[poi_proj['business_type'].isin(large_retail_types)].copy()\n# Create 300m buffer around large retail stores\nlarge_retail_buffers = [geom.buffer(300) for geom in large_retail_stores.geometry]\n# Combine buffers with union\nif large_retail_buffers:\n    retail_union_buffer = gpd.GeoSeries(large_retail_buffers).unary_union\nelse:\n    retail_union_buffer = gpd.GeoSeries().unary_union\n# Filter for parcels at least 300m from any large retail store\nparcels_away_from_large_retail = parcels_near_mass_ave[~parcels_near_mass_ave.geometry.intersects(retail_union_buffer)].copy()\n# Sort by parcel ID (ml column)\nresult_ids = parcels_away_from_large_retail['ml'].tolist()\nresult_ids.sort()\n# Print results\nprint(f\"Found {len(parcels_away_from_large_retail)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Nested Spatial Relationships"
  },
  {
    "Query": "find commercial parcels within 500 meters of harvard art museums AND NOT within 100 meters of any chain hotels",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define projection for Cambridge, MA\ncambridge_crs = 'EPSG:26986'\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Define Harvard Art Museums location\nharvard_art_museums = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy([-71.1189], [42.3736])],\n    crs=parcels.crs\n).to_crs(cambridge_crs)\n# Filter for commercial parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith(('3', '31', '32', '33', '34', '340', '341', '343', '345', '346', '353', '362'))].copy()\n# CONSTRAINT 1: Within 500m of Harvard Art Museums\nnear_harvard = commercial_parcels[commercial_parcels.geometry.distance(harvard_art_museums.iloc[0]) <= 500].copy()\n# Filter for chain hotels\nchain_hotels = poi_proj[\n    poi_proj['business_type'].isin(['hotel', 'motel']) & \n    poi_proj['brand'].isin([\n        'Marriott', 'Hilton', 'Hyatt', 'Holiday Inn', 'Sheraton', \n        'Westin', 'Courtyard', 'Residence Inn', 'Fairfield Inn', \n        'Embassy Suites', 'Hampton Inn'\n    ])\n].copy()\n# CONSTRAINT 2: NOT within 100m of any chain hotels\n# Get all chain hotel locations\nchain_hotel_locations = chain_hotels.geometry.tolist()\n# Create a 100m buffer around each chain hotel\nchain_hotel_buffers = [geom.buffer(100) for geom in chain_hotel_locations]\n# Combine buffers into a single geometry\nunion_buffers = gpd.GeoSeries(chain_hotel_buffers).unary_union\n# Filter out parcels that are too close to chain hotels\nnear_harvard = near_harvard[~near_harvard.geometry.intersects(union_buffers)].copy()\n# Convert back to original CRS\nfinal_parcels = near_harvard.to_crs(parcels.crs)\n# Sort by parcel ID (ml)\nfinal_parcels = final_parcels.sort_values('ml')\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Spatial_Constraints",
    "Subcategory": "Nested Spatial Relationships"
  }
]