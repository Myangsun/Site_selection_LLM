[
  {
    "Query": "find retail parcels that are at least 200m away from the nearest competing retail business",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define retail business types\nretail_business_types = [\n    'restaurant', 'cafe', 'clothing_store', 'department_store', 'grocery_store',\n    'convenience_store', 'furniture_store', 'hardware_store', 'electronics_store'\n]\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Filter retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith(('323', '324', '325', '326', '327', '330'))].copy()\n# Filter retail businesses from POI\nretail_businesses = poi_proj[poi_proj['business_type'].isin(retail_business_types)].copy()\n# Function to find parcels at least 200m away from nearest competing retail business\ndef filter_parcels_away_from_competitors(parcel_geom, retail_business_geoms, min_distance=200):\n    # Calculate distances to all retail business geometries\n    distances = [parcel_geom.distance(geom) for geom in retail_business_geoms]\n    # Check if any retail business is within the min_distance\n    return all(dist >= min_distance for dist in distances)\n# Filter retail parcels\nretail_parcels = retail_parcels.copy()\n# Get retail business geometries\nretail_business_geoms = retail_businesses['geometry'].tolist()\n# Filter by competitor distance\nfiltered_parcels = []\nfor idx, row in retail_parcels.iterrows():\n    if filter_parcels_away_from_competitors(row['geometry'], retail_business_geoms):\n        filtered_parcels.append(row['ml'])\n# Sort by parcel ID\nfiltered_parcels.sort()\n# Convert back to original CRS\nfiltered_parcels = [parcels.loc[parcels_proj['ml'] == ml].copy() for ml in filtered_parcels]\nfiltered_parcels = [p.to_crs(parcels.crs) for p in filtered_parcels]\n# Output results\nresult_ids = [p['ml'] for p in filtered_parcels]\nprint(f\"Found {len(filtered_parcels)} retail parcels at least 200m away from competitors\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Competitor Density"
  },
  {
    "Query": "find restaurants that are located at least 300m away from the nearest competitor restaurant",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Define restaurant POI types\nrestaurant_types = ['3112', '5812', '5813', '722']\n# Filter for restaurants\nrestaurants = poi_proj[poi_proj['place_type'].astype(str).isin(restaurant_types)].copy()\n# Function to find restaurants at least 300m away from competitors\ndef filter_by_competitor_distance(restaurants, min_distance=300):\n    # Create buffer for competitor distance\n    buffered = restaurants.geometry.buffer(min_distance)\n    # Find restaurants that are at least 300m away from competitors\n    result_ids = []\n    for idx, geom in zip(restaurants.index, buffered):\n        # Count competitors within 300m\n        count = restaurants[restaurants.index != idx][restaurants[restaurants.index != idx].geometry.intersects(geom)].shape[0]\n        if count == 0:\n            result_ids.append(idx)\n    return result_ids\n# Find restaurants that meet the criteria\nfiltered_ids = filter_by_competitor_distance(restaurants)\n# Sort by original parcel ID\nfiltered_ids.sort()\n# Convert back to original CRS\nfiltered_parcels = parcels_proj.loc[filtered_ids]\n# Output results\nresult_ids = filtered_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Competitor Density"
  },
  {
    "Query": "find parcels with office space that have no more than 2 competing office businesses within 400m",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Filter for office parcels (ml codes for office)\noffice_ml_codes = ['340', '343', '345', '346', '0346', '404', '406', '0340', '0406']\noffice_parcels = parcels_proj[parcels_proj['ml'].astype(str).str.startswith(('34', '40'))]\n# Filter POI for office businesses\noffice_business_types = ['341', '342', '345', '346', '404', '406']\noffice_poi = poi_proj[poi_proj['business_type'].astype(str).isin(office_business_types)]\n# Function to count nearby office businesses\ndef count_nearby_offices(parcel_geom, office_poi_geoms, buffer_distance=400):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    count = sum(1 for geom in office_poi_geoms if geom is not None and buffered_geom.contains(geom))\n    return count\n# Get office POI geometries\noffice_poi_geoms = office_poi['geometry'].tolist()\n# Calculate office count for each office parcel\noffice_parcels = office_parcels.copy()\noffice_parcels['nearby_offices'] = office_parcels.geometry.apply(\n    lambda geom: count_nearby_offices(geom, office_poi_geoms)\n)\n# Filter for parcels with no more than 2 nearby offices\nresult_parcels = office_parcels[office_parcels['nearby_offices'] <= 2]\n# Sort by parcel ID\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Competitor Density"
  },
  {
    "Query": "find retail parcels that are at least 100m away from the nearest competing retail store",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\n# Define retail business codes\nretail_business_codes = ['101', '1010', '1011', '1013', '1014', '1015', '102', '1020', \n                         '103', '104', '204', '912']\n# Filter for retail parcels\nretail_parcels = parcels[parcels['business_code'].astype(str).isin(retail_business_codes)].copy()\n# Convert to projected CRS for accurate distance measurement\nretail_parcels_proj = retail_parcels.to_crs(epsg=26986)\n# Filter POI for retail businesses\nretail_poi = poi[poi['business_code'].astype(str).isin(retail_business_codes)].copy()\n# Convert retail POI to same CRS\nretail_poi_proj = retail_poi.to_crs(epsg=26986)\n# Function to find parcels at least 100m away from any retail store\ndef filter_parcels_by_competition(parcel_geom, retail_poi_geoms, min_distance=100):\n    # Calculate distances to all retail POI\n    distances = [parcel_geom.distance(geom) for geom in retail_poi_geoms]\n    # Count competitors within 100m\n    if any(d < min_distance for d in distances):\n        return False  # Has at least one competitor within 100m\n    return True  # No competitors within 100m\n# Get retail POI geometries\nretail_poi_geoms = retail_poi_proj['geometry'].tolist()\n# Filter parcels\nfiltered_ids = []\nfor idx, row in retail_parcels_proj.iterrows():\n    if filter_parcels_by_competition(row['geometry'], retail_poi_geoms):\n        filtered_ids.append(row['ml'])\n# Sort by parcel ID\nfiltered_ids.sort()\n# Convert back to original CRS\nresult_parcels = parcels[parcels['ml'].isin(filtered_ids)]\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Competitor Density"
  },
  {
    "Query": "find businesses that are 'clothing store' type with no more than 1 direct competitor within 300m",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Filter for clothing stores\nclothing_store_ids = poi_proj[poi_proj['business_type'] == 'clothing_store']['place_id'].tolist()\n# Filter for clothing store parcels\nclothing_store_parcels = parcels_proj[parcels_proj['ml'].astype(str).isin(clothing_store_ids)].copy()\n# Function to count direct competitors within 300m\ndef count_competitors(parcel_geom, store_id, all_store_geoms, buffer_distance=300):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    # Exclude the store itself from competitor count\n    competitor_geoms = [geom for geom in all_store_geoms if geom is not None and geom != parcel_geom]\n    count = sum(1 for geom in competitor_geoms if geom is not None and buffered_geom.contains(geom))\n    return count\n# Get all clothing store geometries\nall_clothing_geoms = poi_proj[poi_proj['business_type'] == 'clothing_store']['geometry'].tolist()\n# Calculate competitor count for each store\nclothing_store_parcels['competitor_count'] = clothing_store_parcels.apply(\n    lambda row: count_competitors(row['geometry'], row['ml'], all_clothing_geoms),\n    axis=1\n)\n# Filter for stores with at most 1 competitor\nresult_parcels = clothing_store_parcels[clothing_store_parcels['competitor_count'] <= 1]\n# Sort by parcel ID\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Competitor Density"
  },
  {
    "Query": "find cafes that are at least 250m away from the nearest competing cafe",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define cafe POI codes\ncafe_codes = ['5812', '5813', '3241']\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Filter for cafes\ncafes = poi_proj[poi_proj['poi_code'].astype(str).isin(cafe_codes)].copy()\n# Filter parcels that contain cafes\ncafe_parcels = parcels_proj[parcels_proj['ml'].isin(cafes['parcel'])].copy()\n# Find competing cafes (those that are also cafes)\ndef get_competing_cafes(cafe_geom, all_cafes, buffer_distance=250):\n    buffered = cafe_geom.buffer(buffer_distance)\n    competing = all_cafes[all_cafes.geometry.intersects(buffered)].copy()\n    # Remove the original cafe from its own competitors\n    competing = competing[competing['ml'] != cafe_parcels.loc[cafe_parcels['ml'] == cafe_geom]['ml'].values[0]]\n    return competing\n# Calculate cafes' competitors\ncafe_parcels['competing_cafes'] = cafe_parcels.geometry.apply(lambda geom: get_competing_cafes(geom, cafes))\n# Filter for cafes with at least 250m away from competitors\ncafe_parcels = cafe_parcels[cafe_parcels['competing_cafes'].apply(len) > 0].copy()\n# Sort by parcel ID\nresult_ids = sorted(cafe_parcels['ml'].tolist())\n# Print results\nprint(result_ids)",
    "Answer": "[\"Error: 'poi_code\"]",
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Competitor Density"
  },
  {
    "Query": "find parcels that have no more than 3 competitors within 600m, regardless of type",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Define business types that are considered competitors\ncompetitor_types = [\n    'restaurant', 'cafe', 'fast_food', 'grocery', 'supermarket', \n    'clothing_store', 'department_store', 'convenience_store', \n    'liquor_store', 'hardware_store', 'home_goods_store', \n    'electronics_store', 'furniture_store', 'pet_store'\n]\n# Filter POI for competitors\ncompetitor_poi = poi_proj[poi_proj['business_type'].isin(competitor_types)].copy()\n# Calculate competitor count within 600m for each parcel\ndef count_competitors(parcel_geom, competitor_geoms, buffer_distance=600):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    count = sum(1 for geom in competitor_geoms if geom is not None and buffered_geom.contains(geom))\n    return count\n# Get competitor geometries\ncompetitor_geoms = competitor_poi['geometry'].tolist()\n# Calculate competitor count for each parcel\nparcels_proj['competitor_count'] = parcels_proj.geometry.apply(\n    lambda geom: count_competitors(geom, competitor_geoms)\n)\n# Filter for parcels with no more than 3 competitors\nresult_parcels = parcels_proj[parcels_proj['competitor_count'] <= 3].copy()\n# Sort by parcel ID (ml) for consistency\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Competitor Density"
  },
  {
    "Query": "find retail spaces that are located in areas with the lowest density of competing retail businesses",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define retail business types\nretail_business_types = [\n    'restaurant', 'cafe', 'clothing_store', 'department_store', 'grocery_store',\n    'supermarket', 'convenience_store', 'furniture_store', 'hardware_store',\n    'electronics_store', 'toy_store', 'book_store', 'jewelry_store', 'department_store'\n]\n# Filter for retail POIs\nretail_poi = poi[poi['business_type'].isin(retail_business_types)].copy()\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\nretail_poi_proj = retail_poi.to_crs(epsg=26986)\n# Define retail space criteria\nretail_space_criteria = (\n    (parcels_proj['use_code'].astype(str).str.startswith('3')) |  # Commercial\n    (parcels_proj['use_code'].astype(str).str.startswith('34')) |  # Restaurant\n    (parcels_proj['use_code'].astype(str).str.startswith('323'))  # Retail\n)\n# Filter for retail spaces\nretail_spaces = parcels_proj[retail_space_criteria].copy()\n# Calculate retail business density in 500ft (152.4m) radius\ndef calculate_density(parcel_geom, poi_geoms, radius=152.4):\n    buffered_geom = parcel_geom.buffer(radius)\n    count = sum(1 for geom in poi_geoms if geom is not None and buffered_geom.contains(geom))\n    return count / (3.14 * (radius ** 2))  # Density = count / area\n# Get retail POI geometries\nretail_poi_geoms = retail_poi_proj['geometry'].tolist()\n# Calculate density for each retail space\nretail_spaces.loc[:, 'business_density'] = retail_spaces.geometry.apply(\n    lambda geom: calculate_density(geom, retail_poi_geoms)\n)\n# Sort by density (lower is better)\nresult_parcels = retail_spaces.sort_values('business_density').copy()\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Get parcel IDs\nresult_ids = result_parcels['ml'].tolist()\n# Print results\nprint(f\"Found {len(result_parcels)} retail spaces with lowest business density\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"251-255\", \"267F-291\", \"99-51\", \"7-35\", \"260-74\", \"260-76\", \"267E-280\", \"186-85\", \"228-55\", \"184-13\", \"66-122\", \"234-177\", \"180-57\", \"189-103\", \"251-9\", \"252-114\", \"242B-998\", \"228-33\", \"266-40\", \"219-37\", \"189-88\", \"35-88\", \"66-94\", \"268B-8\", \"199-30\", \"267.1-279\", \"267F-296\", \"194-68\", \"184-168\", \"22-130\", \"189-4\", \"260-73\", \"267F-295\", \"267C-91\", \"267E-17\", \"267F-393\", \"190-33\", \"96-124\", \"178-43\", \"186-96\", \"252A-155\", \"248-82\", \"65-47\", \"268B-15\", \"251-221\", \"267.4-247\", \"186-14\", \"234-178\", \"267F-283\", \"267.2-270\", \"267D-333\", \"67-65\", \"66-73\", \"267D-300\", \"87-109\", \"55-18\", \"267E-234\", \"267D-259\", \"87-19\", \"267D-256\", \"54-25\", \"94-6\", \"95-51\", \"231-27\", \"267C-70\", \"267.3-278\", \"267F-274\", \"252A-157\", \"267D-310\", \"267D-316\", \"267.2-261\", \"100-86\", \"94-7\", \"267F-279\", \"267.2-267\", \"67-56\", \"118-67\", \"126-131\", \"109-22\", \"54-16\", \"108-54\", \"109-50\", \"109-51\", \"125-80\", \"195-59\", \"267F-293\", \"267D-293\", \"110-90\", \"267E-279\", \"66-99\", \"267D-311\", \"127-139\", \"95-1\", \"267F-281\", \"267.2-264\", \"267D-284\", \"87-153\", \"67-61\", \"267.4-209\", \"267D-329\", \"271-44\", \"252-147\", \"267D-319\", \"66-82\", \"267D-258\", \"252-160\", \"267D-307\", \"184-27\", \"271-32\", \"267.4-296\", \"192-156\", \"267D-282\", \"267E-287\", \"203A-77\", \"268C-32\", \"267D-299\", \"267.1-282\", \"267F-391\", \"216-7\", \"122-12\", \"68-60\", \"95-60\", \"150-114\", \"95-77\", \"267D-313\", \"267.3-254\", \"22-109\", \"7-37\", \"268C-30\", \"267E-292\", \"75-128\", \"267D-305\", \"260-46\", \"267.3-253\", \"261-112\", \"267.4-295\", \"267.4-312\", \"12-19\", \"267.3-252\", \"267E-244\", \"267E-282\", \"183-119\", \"267D-325\", \"267E-291\", \"172-29\", \"136-15\", \"267D-285\", \"1A-70\", \"137-13\", \"267E-290\", \"260-32\", \"95-76\", \"203B-52\", \"267.4-288\", \"261-6\", \"81-15\", \"157-26\", \"28-23\", \"267F-301\", \"273-20\", \"62-40\", \"261-65\", \"11-46\", \"108-80\", \"1A-209\", \"89-95\", \"181-65\", \"255-21\", \"95-79\", \"120-17\", \"273-40\", \"267.4-305\", \"1A-200\", \"267.4-284\", \"92-125\", \"88-48\", \"139-83\", \"21-124\", \"79-22\", \"119-46\", \"236-95\", \"254-78\", \"27-34\", \"236-148\", \"166-52\", \"261-7\", \"233-147\", \"96-152\", \"166-31\", \"100-68\", \"199-31\", \"184-191\", \"273-29\", \"142-44\", \"189-72\", \"96-109\", \"166-24\", \"68-75\", \"100-62\", \"1A-201\", \"111-43\", \"96-110\", \"80-51\", \"234-193\", \"254-81\", \"184-31\", \"252-172\", \"97-111\", \"142-43\", \"63-131\", \"236-146\", \"63-134\", \"254-86\", \"254-76\", \"233-89\", \"170-39\", \"141-80\", \"166-13\", \"126-27\", \"236-84\", \"254-82\", \"233-175\", \"252-158\", \"166-106\", \"96-153\", \"89-17\", \"36-189\", \"184-159\", \"261-77\", \"85-76\", \"261-85\", \"96-98\", \"1A-172\", \"77-41\", \"81-16\", \"88-53\", \"261-186\", \"184-193\", \"102-25\", \"81-109\", \"1A-105\", \"40-153\", \"189-57\", \"86-84\", \"166-77\", \"102-46\", \"110-63\", \"268C-35\", \"166-33\", \"107-117\", \"80-175\", \"88-45\", \"140-157\", \"17-10\", \"262-116\", \"46-12\", \"27-82\", \"31-20\", \"192-75\", \"229-131\", \"117-56\", \"265A-45\", \"19-10\", \"90-18\", \"39-88\", \"140-148\", \"119-93\", \"230-116\", \"265B-57\", \"90-20\", \"90-127\", \"21-115\", \"7-115\", \"119-47\", \"7-31\", \"230-71\", \"129-55\", \"119-5\", \"129-11\", \"229-117\", \"184-109\", \"80-172\", \"229-135\", \"226-46\", \"226-67\", \"229-150\", \"265A-35\", \"1A-190\", \"118-1\", \"7-34\", \"230-97\", \"106-60\", \"39-179\", \"265D-53\", \"227-24\", \"13-16\", \"166-35\", \"168-48\", \"68-19\", \"1A-211\", \"48-160\", \"273-51\", \"199-90\", \"91-7\", \"166-37\", \"81-50\", \"117-25\", \"119-95\", \"265A-31\", \"230-41\", \"198-28\", \"80-142\", \"265A-29\", \"1A-189\", \"119-90\", \"199-67\", \"117-1\", \"181-88\", \"117-29\", \"90-14\", \"106-42\", \"16-11\", \"168-49\", \"200-91\", \"230-42\", \"265A-40\", \"36-164\", \"265A-7\", \"120-48\", \"23-146\", \"119-21\", \"1A-212\", \"42-81\", \"81-21\", \"273-2\", \"43-78\", \"200-22\", \"265A-46\", \"128-70\", \"118-79\", \"128-63\", \"20-92\", \"90-13\", \"196-123\", \"15-31\", \"273-35\", \"39-174\", \"1A-192\", \"265A-39\", \"182-88\", \"182-90\", \"128-72\", \"39-173\", \"42-91\", \"81-99\", \"68-50\", \"23-157\", \"43A-21\", \"182-84\", \"16-23\", \"265B-59\", \"29-50\", \"37-20\", \"21-121\", \"20-103\", \"53-54\", \"13-23\", \"20-82\", \"1A-214\", \"200-79\", \"196-154\", \"181-80\", \"17-74\", \"36-137\", \"125-73\", \"81-103\", \"23-156\", \"15-3\", \"182-98\", \"10-39\", \"20-83\", \"192-121\", \"265B-26\", \"182-8\", \"182-89\", \"42-94\", \"173-35\", \"1A-215\", \"196-153\", \"21-118\", \"24-133\", \"120-74\", \"265B-61\", \"118-34\", \"192-74\", \"18-76\", \"23-90\", \"36-248\", \"192-73\", \"47-94\", \"35-87\", \"81-104\", \"41-28\", \"265B-28\", \"183-97\", \"21-16\", \"43A-19\", \"183-100\", \"36-247\", \"81-3\", \"21-120\", \"20-31\", \"80-3\", \"24-139\", \"20-75\", \"191-65\", \"18-73\", \"83-1\", \"192-177\", \"116-13\", \"114A-120\", \"192-39\", \"17-84\", \"23-149\", \"28-31\", \"165-60\", \"42-97\", \"154-97\", \"265A-43\", \"156-55\", \"41-36\", \"116-94\", \"116-12\", \"43-73\", \"36-226\", \"154-98\", \"114A-66\", \"37-128\", \"175-68\", \"10-38\", \"44-100\", \"8-75\", \"70-74\", \"42-33\", \"184-155\", \"83-92\", \"191-85\", \"35-89\", \"191-112\", \"81-100\", \"69-162\", \"116-43\", \"41-34\", \"19-23\", \"116-100\", \"154-101\", \"44-95\", \"178-1\", \"133-30\", \"265C-25\", \"173-65\", \"134-7\", \"133-28\", \"42-99\", \"42-13\", \"20-104\", \"133-27\", \"82-57\", \"133-36\", \"152-17\", \"10-31\", \"28-43\", \"116-117\", \"35-34\", \"161-92\", \"156-60\", \"1A-207\", \"34-28\", \"34-8\", \"69-161\", \"133-52\", \"93-48\", \"154-64\", \"42-70\", \"35-36\", \"175-84\", \"34-116\", \"154-65\", \"11-40\", \"119-89\", \"121-13\", \"154-73\", \"154-111\", \"8-70\", \"133-49\", \"133-14\", \"119-51\", \"154-89\", \"43-70\", \"14-54\", \"105-58\", \"105-123\", \"176-64\", \"133-33\", \"175-77\", \"121-94\", \"133-15\", \"168-41\", \"15-30\", \"74-6\", \"82-31\", \"133-48\", \"174-37\", \"44-104\", \"14-26\", \"40-197\", \"42-87\", \"43-71\", \"175-75\", \"41-38\", \"134-33\", \"121-2\", \"174-33\", \"48-158\", \"105-53\", \"133-12\", \"83-7\", \"174-36\", \"174-31\", \"44-99\", \"133-20\", \"134-59\", \"168-64\", \"42-86\", \"178-106\", \"105-67\", \"175-37\", \"110-91\", \"174-30\", \"74-8\", \"107-9\", \"70-22\", \"110-55\", \"83-12\", \"90-193\", \"110-16\", \"44-105\", \"176-15\", \"165-53\", \"156-25\", \"9-31\", \"174-25\", \"174-27\", \"174-26\", \"83-13\", \"107-137\", \"155-42\", \"107-8\", \"74-1\", \"133-56\", \"174-73\", \"85-13\", \"133-54\", \"178-117\", \"90-55\", \"133-23\", \"110-53\", \"105-68\", \"105-89\", \"105-77\", \"14-58\", \"179-42\", \"14-36\", \"168-22\", \"75-130\", \"110-18\", \"70-86\", \"44-106\", \"105-93\", \"168-60\", \"91-98\", \"177-71\", \"84-85\", \"178-21\", \"14-55\", \"110-21\", \"178-118\", \"152-52\", \"85-66\", \"133-51\", \"69-62\", \"107-135\", \"105-82\", \"18-74\", \"178-79\", \"83-15\", \"91-119\", \"70-88\", \"14-47\", \"177-79\", \"91-81\", \"84-100\", \"168-25\", \"84-12\", \"179-75\", \"105-81\", \"168-59\", \"70-92\", \"83-99\", \"105-74\", \"84-1\", \"178-133\", \"106-109\", \"84-91\", \"83-98\", \"84-66\", \"83-90\", \"84-99\", \"168-21\", \"106-117\", \"90-52\", \"91-82\", \"83-80\", \"169-86\", \"93-72\", \"84-67\", \"90-70\", \"179-87\", \"84-97\", \"106-123\", \"90-125\", \"90-185\", \"90-169\", \"75-44\", \"8-76\", \"70-10\", \"90-161\", \"90-133\", \"177-34\", \"90-162\", \"91-83\", \"169-68\", \"168-20\", \"107-136\", \"169-7\", \"169-67\", \"84-101\", \"106-124\", \"69-159\", \"70-91\", \"91-68\", \"18-65\", \"90-170\", \"18-75\", \"18-64\", \"70-9\", \"160-48\", \"93-74\", \"178-91\", \"91-65\", \"75-170\", \"93-73\", \"93-75\", \"91-52\", \"152-25\", \"91-63\", \"91-191\", \"70-12\", \"91-70\", \"9-41\", \"91-64\", \"9-61\", \"75-57\", \"93-78\", \"93-79\", \"93-76\", \"90-184\", \"91-195\", \"90-155\", \"8-88\", \"91-200\", \"168-13\", \"91-118\", \"93-99\", \"169-82\", \"93-80\", \"70-90\", \"169-81\", \"92-88\", \"160-84\", \"160-83\", \"160-76\", \"160-77\", \"91-87\", \"169-100\", \"165-55\", \"169-84\", \"165-57\", \"91-208\", \"169-99\", \"160-85\", \"169-47\", \"162-36\", \"162-65\", \"168-33\", \"165-34\", \"162-66\", \"169-42\", \"159-2\", \"162-26\", \"162-73\", \"160-58\", \"162-64\", \"169-102\", \"169-93\", \"162-29\", \"169-50\", \"162-19\", \"162-17\", \"162-18\", \"169-46\", \"162-54\", \"169-98\", \"160-14\", \"168-36\", \"160-59\", \"162-67\", \"160-69\", \"162-68\", \"160-72\", \"160-64\", \"160-66\", \"160-67\", \"160-71\", \"160-63\", \"160-11\", \"160-57\"]",
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Competitor Density"
  },
  {
    "Query": "find restaurants that have no more than 2 competing restaurants within 500m",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define restaurant POI types\nrestaurant_types = ['3112', '5812', '5813', '5814', '722']\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Filter for restaurants\nrestaurants = poi_proj[poi_proj['business_type'].astype(str).isin(restaurant_types)].copy()\n# Function to count competitors within 500m\ndef count_competitors(parcel_geom, restaurant_geom, all_restaurants, buffer_distance=500):\n    buffered_geom = restaurant_geom.buffer(buffer_distance)\n    # Exclude the restaurant itself from the count\n    competitors = all_restaurants[all_restaurants.geometry.intersects(buffered_geom)].copy()\n    competitors = competitors[competitors.geometry.ne(restaurant_geom)]\n    return len(competitors)\n# Filter for restaurant parcels\nrestaurant_parcels = parcels_proj[parcels_proj['ml'].isin(restaurants['ml'])].copy()\n# Calculate competitor count for each restaurant\nrestaurant_parcels['competitor_count'] = restaurant_parcels.apply(\n    lambda row: count_competitors(row.geometry, row.geometry, restaurant_parcels),\n    axis=1\n)\n# Filter for restaurants with no more than 2 competitors\nquiet_restaurants = restaurant_parcels[restaurant_parcels['competitor_count'] <= 2].copy()\n# Sort by parcel ID\nresult_ids = quiet_restaurants['ml'].sort_values().tolist()\n# Convert back to original CRS\nquiet_restaurants = quiet_restaurants.to_crs(parcels.crs)\n# Print results\nprint(f",
    "Answer": null,
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Competitor Density"
  },
  {
    "Query": "find parcels with office space that are at least 150m away from the nearest competing office",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Define office use codes\noffice_use_codes = ['340', '343', '345', '346', '0340', '404', '406']\n# Filter for office parcels\noffice_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(office_use_codes)].copy()\n# Filter POI for office businesses\noffice_poi_types = ['341', '342', '345', '346', '0406']\noffice_poi = poi_proj[poi_proj['business_type'].astype(str).isin(office_poi_types)].copy()\n# Ensure consistent geometry type\noffice_poi = office_poi[office_poi.geometry.type == 'POINT']\n# Calculate 150m buffer around each office POI\noffice_poi_buffers = [geom.buffer(150) for geom in office_poi.geometry]\noffice_poi_union_buffer = gpd.GeoSeries(office_poi_buffers).unary_union\n# Find competing office POI (those within 150m of any office POI)\n# For each office parcel, check if it is at least 150m away from any competing office\ndef has_competing_office(parcel_geom, office_poi_union_buffer):\n    # Check if parcel is within 150m of any office POI\n    return not office_poi_union_buffer.contains(parcel_geom)\n# Filter for parcels that have at least one competing office\noffice_parcels = office_parcels[office_parcels.geometry.notnull()].copy()\noffice_parcels.loc[:, 'has_competing_office'] = office_parcels.geometry.apply(\n    lambda geom: has_competing_office(geom, office_poi_union_buffer)\n)\n# Filter for parcels that have at least one competing office\nresult_parcels = office_parcels[office_parcels['has_competing_office']].copy()\n# Sort by parcel ID\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Competitor Density"
  },
  {
    "Query": "find commercial parcels that are near a diverse mix of residential and retail uses, specifically located in areas with at least 3 different business types within 500 meters.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(epsg=cambridge_crs)\npoi_proj = poi.to_crs(epsg=cambridge_crs)\ncensus_proj = census.to_crs(epsg=cambridge_crs)\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_use_codes)].copy()\n# Define retail POI categories\nretail_categories = [\n    'restaurant', 'clothing_store', 'department_store', 'grocery_store', \n    'convenience_store', 'furniture_store', 'hardware_store', 'electronics_store'\n]\n# Filter retail POIs\nretail_poi = poi_proj[poi_proj['category'].isin(retail_categories)].copy()\n# Define residential use codes\nresidential_use_codes = [\n    '101', '1014', '102', '1024', '104', '109', '1094', '1095', \n    '1098', '111', '112', '113', '114', '121', '970', '9700'\n]\n# Filter residential parcels\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_use_codes)].copy()\n# Function to check if a parcel is near diverse retail and residential\ndef has_nearby_diverse_use(parcel_geom, poi_geoms, residential_geoms, retail_poi, \n                            num_types=3, buffer_dist=500):\n    # Get buffered area\n    buffered_geom = parcel_geom.buffer(buffer_dist)\n    \n    # Get nearby residential\n    nearby_residential = [geom for geom in residential_geoms if geom is not None and buffered_geom.contains(geom)]\n    \n    # Get nearby retail\n    nearby_retail = retail_poi[retail_poi['geometry'].notnull() & \n                                (retail_poi['geometry'].apply(lambda x: buffered_geom.contains(x)))].copy()\n    \n    # Count distinct business types\n    if len(nearby_retail) > 0:\n        # If there are nearby retail, count their types\n        retail_types = nearby_retail['category'].unique()\n    else:\n        retail_types = []\n    \n    # Count residential type (all are the same, so just 1)\n    residential_type_count = 1 if len(nearby_residential) > 0 else 0\n    \n    # Total distinct types\n    total_types = residential_type_count + len(retail_types)\n    \n    return total_types >= num_types\n# Get residential geometries\nresidential_geoms = residential_parcels['geometry'].tolist()\n# Check each commercial parcel\ndiverse_parcels = []\nfor idx, parcel in commercial_parcels.iterrows():\n    if has_nearby_diverse_use(parcel['geometry'], \n                              parcel['geometry'].buffer(500), \n                              residential_geoms, \n                              retail_poi):\n        diverse_parcels.append(parcel['ml'])\n# Sort by parcel ID\ndiverse_parcels.sort()\n# Convert back to original CRS\ndiverse_parcels = [p for p in diverse_parcels if p in commercial_parcels['ml'].values]\n# Output results\nprint(f\"Found {len(diverse_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {diverse_parcels}\")",
    "Answer": "[\"Found 0 parcels meeting criteria\", \"Parcel IDs:\"]",
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Land Use Mix"
  },
  {
    "Query": "identify sites surrounded by a variety of land uses, specifically those with at least 4 different types of businesses within 400 meters.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Filter for business types in POI data\nbusiness_types = [\n    'restaurant', 'cafe', 'grocery', 'convenience_store', 'department_store',\n    'clothing_store', 'furniture_store', 'hardware_store', 'electronics_store'\n]\npoi_business = poi_proj[poi_proj['business_type'].isin(business_types)].copy()\n# Function to count unique business types within 400m\ndef count_unique_business_types(parcel_geom, poi_geoms, poi_types, buffer_distance=400):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    # Filter POI within buffer\n    within_buffer = poi_geoms[poi_geoms['geometry'].within(buffered_geom)].copy()\n    # Count unique business types\n    if 'business_type' in within_buffer:\n        unique_types = within_buffer['business_type'].nunique()\n    else:\n        unique_types = 0\n    return unique_types\n# Calculate business diversity for each parcel\npoi_business_geoms = poi_business.copy()\npoi_business_geoms['geometry'] = poi_business_geoms['geometry'].copy()\nparcels_proj.loc[:, 'business_diversity'] = [\n    count_unique_business_types(row['geometry'], poi_business_geoms, business_types)\n    for idx, row in parcels_proj.iterrows()\n]\n# Filter for parcels with at least 4 different business types\ndiverse_parcels = parcels_proj[parcels_proj['business_diversity'] >= 4].copy()\n# Sort by business diversity (highest first) and then by parcel ID\ndiverse_parcels = diverse_parcels.sort_values(['business_diversity', 'ml'], ascending=False)\n# Convert back to original CRS\ndiverse_parcels = diverse_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = diverse_parcels['ml'].tolist()\nprint(f\"Found {len(diverse_parcels)} parcels with diverse businesses\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Land Use Mix"
  },
  {
    "Query": "locate retail parcels that are in areas with a balanced mix of residential and commercial uses, defined as having at least 30% of nearby businesses being restaurants or cafes.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define retail use codes consistently\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Filter for retail parcels\nretail_parcels = parcels[parcels['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Set CRS for accurate distance measurement\nretail_parcels = retail_parcels.to_crs(epsg=26986)\npoi = poi.to_crs(epsg=26986)\n# Define restaurant/cafe POI codes\nrestaurant_codes = ['0406', '0407', '0408', '0411', '042', '043', '0903']\n# Function to calculate restaurant ratio\ndef calculate_restaurant_ratio(parcel_geom, poi_geoms, buffer_distance=100):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    # Filter POI within buffer\n    nearby_poi = poi_geoms[buffered_geom.contains(poi_geoms)]\n    if nearby_poi.empty:\n        return 0.0\n    # Count restaurants\n    restaurant_count = sum(1 for p in nearby_poi if str(p['business_code']) in restaurant_codes)\n    # Count total businesses\n    total_businesses = len(nearby_poi)\n    # Calculate ratio\n    return restaurant_count / total_businesses if total_businesses > 0 else 0.0\n# Calculate restaurant ratio for each retail parcel\npoi_geoms = poi['geometry'].tolist()\nretail_parcels.loc[:, 'restaurant_ratio'] = retail_parcels.geometry.apply(\n    lambda g: calculate_restaurant_ratio(g, poi_geoms)\n)\n# Filter for parcels with at least 30% restaurant ratio\nbalanced_parcels = retail_parcels[retail_parcels['restaurant_ratio'] >= 0.3].copy()\n# Sort by parcel ID\nbalanced_parcels = balanced_parcels.sort_values('ml')\n# Output results\nresult_ids = balanced_parcels['ml'].tolist()\nprint(result_ids)",
    "Answer": "[\"Error: only integer scalar arrays can be converted to a scalar index\"]",
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Land Use Mix"
  },
  {
    "Query": "search for commercial sites that are in predominantly retail neighborhoods but within walking distance to residential areas, ensuring at least 20% of nearby buildings are homes.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(epsg=cambridge_crs)\npoi_proj = poi.to_crs(epsg=cambridge_crs)\ncensus_proj = census.to_crs(epsg=cambridge_crs)\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Define residential POI categories\nresidential_poi_categories = [\n    'hotels', 'lodging', 'real_estate', 'apartment', 'housing', 'establishment'\n]\n# Filter for residential POI\nresidential_poi = poi_proj[poi_proj['category'].isin(residential_poi_categories)].copy()\n# Function to calculate residential density around retail parcels\ndef has_nearby_residential(parcel_geom, poi_geoms, buffer_distance=200):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    # Count nearby residential POI\n    count = sum(1 for geom in poi_geoms if geom is not None and buffered_geom.contains(geom))\n    return count > 0\n# Filter retail parcels by residential proximity\nretail_with_residential = []\nfor idx, row in retail_parcels.iterrows():\n    if has_nearby_residential(row.geometry, residential_poi['geometry'].tolist()):\n        retail_with_residential.append(row['ml'])\n# Sort by parcel ID\nresult_ids = sorted(retail_with_residential)\n# Convert back to original CRS\nresult_ids = [int(parcel_id) for parcel_id in result_ids]\n# Print results\nprint(result_ids)",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Land Use Mix"
  },
  {
    "Query": "find parcels that are in lively mixed-use areas, defined as having at least 5 different business types within 600 meters, including grocery stores and restaurants.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(epsg=cambridge_crs)\npoi_proj = poi.to_crs(epsg=cambridge_crs)\n# Filter for business parcels (commercial, mixed-use, etc.)\nbusiness_types = [\n    '101', '1014', '102', '1021', '1022', '104', '109', '110', '111', \n    '112', '912', '013', '014', '015', '016', '017', '018', '020', \n    '021', '022', '023', '024', '025', '026', '027', '034', '040', \n    '041', '042', '043', '044', '045', '046', '047', '048', '049'\n]\nbusiness_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(business_types)].copy()\n# Filter POI for grocery stores and restaurants\ngrocery_ids = ['412', '411', '213', '212', '210']\nrestaurant_ids = ['401', '402', '403', '404', '406', '408', '410']\ngrocery_poi = poi_proj[poi_proj['business_type'].astype(str).isin(grocery_ids)].copy()\nrestaurant_poi = poi_proj[poi_proj['business_type'].astype(str).isin(restaurant_ids)].copy()\n# Function to check if a parcel is in a lively mixed-use area\ndef is_lively_mixed_use(parcel_geom, poi_geoms, buffer_distance=600):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    # Count different business types within buffer\n    poi_types = []\n    for geom in poi_geoms:\n        if geom is not None and buffered_geom.contains(geom):\n            poi_types.append(1)  # Count each POI as 1 type\n    # Check for at least 5 different business types\n    return len(set(poi_types)) >= 5\n# Get POI geometries\ngrocery_geoms = grocery_poi['geometry'].tolist()\nrestaurant_geoms = restaurant_poi['geometry'].tolist()\n# Check each business parcel for lively mixed-use area\nlively_parcels = []\nfor idx, row in business_parcels.iterrows():\n    if is_lively_mixed_use(row['geometry'], grocery_geoms + restaurant_geoms):\n        lively_parcels.append(row['ml'])\n# Sort by parcel ID\nlively_parcels.sort()\n# Convert back to original CRS\nlively_parcels = [str(parcel) for parcel in lively_parcels]\n# Print results\nprint(f\"Found {len(lively_parcels)} parcels in lively mixed-use areas\")\nprint(f\"Parcel IDs: {lively_parcels}\")",
    "Answer": "[\"Found 0 parcels in lively mixed-use areas\", \"Parcel IDs:\"]",
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Land Use Mix"
  },
  {
    "Query": "locate sites that are close to diverse shopping districts, specifically those within 300 meters of a street with at least 10 different retailers.",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(epsg=cambridge_crs)\npoi_proj = poi.to_crs(epsg=cambridge_crs)\n# Filter for retail POIs\nretail_types = [\n    'restaurant', 'cafe', 'clothing_store', 'department_store', 'grocery_store',\n    'convenience_store', 'furniture_store', 'hardware_store', 'shoe_store', \n    'jewelry_store', 'book_store', 'department_store'\n]\nretail_poi = poi_proj[poi_proj['business_type'].isin(retail_types)].copy()\n# Function to find streets with at least 10 different retailers\ndef has_diverse_retail_street(street_geom, poi_geoms, threshold=10):\n    if pd.isna(street_geom):\n        return False\n    buffered_street = street_geom.buffer(15)  # 15m buffer\n    # Get retail POIs near the street\n    nearby_retail = [geom for geom in poi_geoms if geom is not None and buffered_street.contains(geom)]\n    if len(nearby_retail) == 0:\n        return False\n    # Count unique retail types\n    retail_types_nearby = set()\n    for geom in nearby_retail:\n        if geom is not None:\n            retail_type = poi_proj.loc[poi_proj['geometry'] == geom, 'business_type'].values[0]\n            retail_types_nearby.add(retail_type)\n    return len(retail_types_nearby) >= threshold\n# Filter for retail POIs\nretail_poi = poi_proj[poi_proj['business_type'].isin(retail_types)].copy()\n# Get unique street geometries\nstreets = poi_proj[poi_proj['is_street']].copy()\nstreet_geoms = streets['geometry'].tolist()\n# Check each street for diverse retail\ndiverse_streets = []\nfor i, geom in enumerate(street_geoms):\n    if has_diverse_retail_street(geom, retail_poi['geometry'].tolist()):\n        diverse_streets.append(streets.iloc[i]['ml'])\n# Filter parcels by proximity to diverse retail streets\nresult_parcels = parcels_proj[parcels_proj['ml'].isin(diverse_streets)].copy()\n# Sort by parcel ID\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels near diverse retail streets\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: 'is_street\"]",
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Land Use Mix"
  },
  {
    "Query": "search for restaurants that are in areas with a mix of food and retail, ensuring at least 40% of nearby businesses are not direct competitors.",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Define restaurant and retail business codes\nrestaurant_codes = ['2000', '2010', '2011', '2012', '2013', '2014', '2015', '2170']\nretail_codes = ['245', '246', '253', '254', '255', '256', '257', '262', '263', '264', '0650']\n# Filter for restaurants and retail businesses\nrestaurants = poi_proj[poi_proj['business_code'].astype(str).isin(restaurant_codes)].copy()\nretail = poi_proj[poi_proj['business_code'].astype(str).isin(retail_codes)].copy()\n# Combine restaurant and retail for mixed-use areas\nmixed_use_poi = pd.concat([restaurants, retail]).drop_duplicates()\n# Function to calculate business mix\ndef calculate_business_mix(parcel_geom, all_poi, competitor_codes, buffer_distance=100):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    # Find nearby businesses\n    nearby_poi = all_poi[all_poi.geometry.intersects(buffered_geom)].copy()\n    # Filter out direct competitors (restaurants)\n    non_competitors = nearby_poi[~nearby_poi['business_code'].astype(str).isin(competitor_codes)].copy()\n    # Calculate ratios\n    if len(nearby_poi) > 0:\n        competitor_ratio = len(non_competitors) / len(nearby_poi)\n    else:\n        competitor_ratio = 0\n    return competitor_ratio\n# Filter for restaurant parcels\nrestaurant_parcels = parcels_proj[parcels_proj['ml'].astype(str).isin(restaurants['ml'].astype(str))].copy()\n# Calculate business mix for each restaurant parcel\ncompetitor_codes = ['2000', '2010', '2011', '2012', '2013', '2014', '2015', '2170']  # Restaurant codes\nrestaurant_parcels.loc[:, 'business_mix'] = restaurant_parcels.geometry.apply(\n    lambda geom: calculate_business_mix(geom, mixed_use_poi, competitor_codes)\n)\n# Filter for parcels with at least 40% non-competitors\nresult_parcels = restaurant_parcels[restaurant_parcels['business_mix'] >= 0.4].copy()\n# Sort by ml for consistent output\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Land Use Mix"
  },
  {
    "Query": "identify commercial parcels near diverse marketplaces, specifically those within 500 meters of an area with at least 15 different types of businesses.",
    "Code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Filter for commercial parcels\ncommercial_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', '330', \n    '332', '334', '340', '341', '343', '345', '346', '353', '362',\n    '375', '404', '406', '0340', '0406'\n]\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_codes)].copy()\n# Define function to identify diverse marketplaces\ndef is_diverse_marketplace(poi_subset):\n    if poi_subset.shape[0] < 15:\n        return False\n    business_types = poi_subset['business_type'].nunique()\n    return business_types >= 15\n# Create 500m buffer around commercial parcels\nbuffered_parcels = commercial_parcels.buffer(500)\n# Identify diverse marketplaces within 500m\ndiverse_market_ids = set()\nfor idx, buffered in zip(commercial_parcels.index, buffered_parcels):\n    nearby_poi = poi_proj[poi_proj.geometry.distance(buffered) < 500].copy()\n    if is_diverse_marketplace(nearby_poi):\n        diverse_market_ids.add(idx)\n# Filter for parcels near diverse marketplaces\nresult_parcels = commercial_parcels.loc[diverse_market_ids].copy()\n# Sort by parcel ID (ml)\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(result_ids)",
    "Answer": "[\"Error: Passing a set as an indexer is not supported. Use a list instead.\"]",
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Land Use Mix"
  },
  {
    "Query": "find retail sites that are in mixed-use developments, ensuring that among 10 nearby parcels, there are both residential and different types of retail.",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(epsg=cambridge_crs)\npoi_proj = poi.to_crs(epsg=cambridge_crs)\n# Define retail and residential use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\nresidential_use_codes = ['101', '1014', '102', '1024', '104', '105', '109', '1094', '1095', '1098', \n                         '111', '112', '113', '114', '121', '970', '9700']\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Filter for mixed-use retail parcels\nmixed_use_retail = retail_parcels[retail_parcels['ml'].astype(str).str.endswith(('000', '001', '100', '101'))]\n# Function to check surrounding parcels for mixed-use\ndef has_mixed_use_nearby(parcel_geom, all_parcels, poi_geoms, residential_codes, retail_codes, num_neighbors=10, buffer=50):\n    # Get 10 closest parcels\n    buffered_geom = parcel_geom.buffer(buffer)\n    nearby_parcels = all_parcels[all_parcels.geometry.intersects(buffered_geom)].copy()\n    \n    # Sort by distance\n    nearby_parcels = nearby_parcels.sort_values('ml')\n    \n    # Ensure we have exactly num_neighbors\n    if len(nearby_parcels) > num_neighbors:\n        nearby_parcels = nearby_parcels.iloc[:num_neighbors]\n    \n    # Check for residential\n    has_residential = any(nearby_parcels['use_code'].astype(str).isin(residential_codes))\n    \n    # Check for multiple retail types\n    retail_types = []\n    for retail_code in retail_codes:\n        if any(nearby_parcels['use_code'].astype(str).str.startswith(str(retail_code))):\n            retail_types.append(retail_code)\n    \n    has_multiple_retail = len(retail_types) > 1\n    \n    return has_residential and has_multiple_retail\n# Find valid mixed-use retail parcels\nvalid_parcels = []\nfor ml in mixed_use_retail['ml']:\n    parcel_geom = mixed_use_retail.loc[mixed_use_retail['ml'] == ml, 'geometry'].values[0]\n    if has_mixed_use_nearby(parcel_geom, parcels_proj, poi_proj['geometry'], residential_use_codes, [32, 33, 34, 31]):\n        valid_parcels.append(ml)\n# Sort by parcel ID\nvalid_parcels.sort()\n# Convert back to original CRS\nvalid_parcels = [str(p) for p in valid_parcels]\n# Print results\nprint(f\"Found {len(valid_parcels)} mixed-use retail parcels with diverse nearby uses:\")\nprint(f\"Parcel IDs: {valid_parcels}\")",
    "Answer": "[\"Error: 'business_type\"]",
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Land Use Mix"
  },
  {
    "Query": "locate parcels in vibrant neighborhoods, defined as areas with high foot traffic and a mix of shops, restaurants, and services within 300 meters.",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Convert to projected CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Define vibrant neighborhood criteria\ndef is_vibrant_neighborhood(ml, poi_proj, census_proj, spend, buffer_distance=300):\n    # Get parcel location\n    parcel_geom = parcels_proj.loc[parcels_proj['ml'] == ml, 'geometry'].values[0]\n    \n    # Create buffer for neighborhood\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    \n    # POI analysis\n    poi_within = poi_proj[poi_proj.geometry.intersects(buffered_geom)].copy()\n    if poi_within.empty:\n        return False\n    # Calculate POI diversity (mix of shops, restaurants, services)\n    def calculate_poi_diversity(poi):\n        if poi.empty:\n            return 0\n        # Use 'category' field to determine type of POI\n        # Count different types of POI\n        types = poi['category'].astype(str).str.split(',').explode().str.strip()\n        type_counts = types.value_counts()\n        # More types = more diversity\n        return min(len(type_counts), 5)  # Cap at 5 types for diversity metric\n    poi_diversity = calculate_poi_diversity(poi_within)\n    \n    # Spending analysis\n    # Get approximate location of parcel for spending analysis\n    centroid = parcel_geom.centroid\n    # Find closest spending record (using Euclidean distance in projected space)\n    spend['approx_location'] = spend.apply(lambda row: (centroid.x, centroid.y), axis=1)\n    spend['distance'] = spend.apply(lambda row: ((row['approx_location'][0] - centroid.x) ** 2 + (row['approx_location'][1] - centroid.y) ** 2) ** 0.5, axis=1)\n    # Define 'vibrant' spend threshold\n    vibrant_spend_threshold = 1000  # Adjust as needed\n    # Check if any spending record indicates vibrant area\n    has_vibrant_spend = spend[spend['distance'] < 100].any()['total_spend'] > vibrant_spend_threshold\n    \n    # Census analysis\n    # Get demographic data for area\n    # Use buffered_geom to find relevant census tracts\n    # For simplicity, use mean values from nearby tracts\n    nearby_tracts = census_proj[census_proj.geometry.intersects(buffered_geom)]\n    if nearby_tracts.empty:\n        return False\n    # Calculate average values for key indicators\n    avg_income = nearby_tracts['median_income'].mean()\n    pct_college_grad = nearby_tracts['pct_college_grad'].mean()\n    # Define 'vibrant' demographic thresholds\n    vibrant_income_threshold = 80000  # Adjust as needed\n    vibrant_college_grad_threshold = 0.5  # 50% college graduates\n    # Check if area meets demographic criteria\n    meets_demographic_criteria = (avg_income > vibrant_income_threshold) and (pct_college_grad > vibrant_college_grad_threshold)\n    \n    # Combine criteria\n    return poi_diversity > 2 and has_vibrant_spend and meets_demographic_criteria\n# Filter parcels for vibrant neighborhoods\nvibrant_parcels = []\nfor ml in parcels_proj['ml']:\n    if is_vibrant_neighborhood(ml, poi_proj, census_proj, spend):\n        vibrant_parcels.append(ml)\n# Sort by parcel ID\nvibrant_parcels.sort()\n# Convert back to original CRS\nvibrant_parcels = [int(ml) for ml in vibrant_parcels]\n# Print results\nprint(f",
    "Answer": null,
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Land Use Mix"
  },
  {
    "Query": "find parcels in areas where RAW_TOTAL_SPEND is above average for their census tract",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend_data = pd.read_csv('data/cambridge_spend_processed.csv')\n# Convert to projected CRS for accurate distance calculations\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Merge spending data with POI data\npoi_with_spend = poi_proj.merge(\n    spend_data,\n    left_on='PLACEKEY',\n    right_on='PLACEKEY',\n    how='left'\n)\n# Fill NaN values in RAW_TOTAL_SPEND with 0\nif 'RAW_TOTAL_SPEND' in poi_with_spend.columns:\n    poi_with_spend['RAW_TOTAL_SPEND'] = poi_with_spend['RAW_TOTAL_SPEND'].fillna(0)\nelse:\n    poi_with_spend['RAW_TOTAL_SPEND'] = 0\n# Spatial join: assign POI to each parcel\nparcels_with_poi = gpd.sjoin_nearest(\n    parcels_proj,\n    poi_with_spend,\n    how='left',\n    distance_col='poi_distance',\n    max_distance=100  # 100m\n)\n# Calculate average spend for each parcel's POI\ndef calculate_poi_spend(parcel_row):\n    if pd.isna(parcel_row['RAW_TOTAL_SPEND']):\n        return 0\n    return parcel_row['RAW_TOTAL_SPEND']\nparcels_with_poi['poi_spend'] = parcels_with_poi.apply(calculate_poi_spend, axis=1)\n# Filter: parcels where POI spend is above average\nresult_parcels = parcels_with_poi[parcels_with_poi['poi_spend'] > 0].copy()\nresult_parcels = result_parcels.sort_values('poi_spend', ascending=False)\n# Sort by parcel ID for consistency\nresult_ids = result_parcels['ml'].tolist()\n# Output results\nprint(f\"Found {len(result_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs (sorted): {result_ids}\")",
    "Answer": "[\"electronics_and_appliance_stores\", \"general_merchandise_stores,_including_warehouse_clubs_and_supercenters\", \"grocery_stores\", \"grocery_stores\", \"grocery_stores\", \"health_and_personal_care_stores\", \"electronics_and_appliance_stores\", \"grocery_stores\", \"grocery_stores\", \"grocery_stores\", \"grocery_stores\", \"book_stores_and_news_dealers\", \"health_and_personal_care_stores\", \"general_merchandise_stores,_including_warehouse_clubs_and_supercenters\", \"traveler_accommodation\", \"grocery_stores\", \"service\", \"gasoline_stations\", \"restaurant\", \"restaurant\", \"grocery_stores\", \"department_stores\", \"retail\", \"furniture_stores\", \"health_and_personal_care_stores\", \"administration_of_economic_programs\", \"automobile_dealers\", \"automobile_dealers\", \"automobile_dealers\", \"automobile_dealers\", \"automobile_dealers\", \"grocery_stores\", \"restaurant\", \"book_stores_and_news_dealers\", \"health_and_personal_care_stores\", \"book_stores_and_news_dealers\", \"building_material_and_supplies_dealers\", \"building_material_and_supplies_dealers\", \"restaurant\", \"drinking_places_(alcoholic_beverages)\", \"drinking_places_(alcoholic_beverages)\", \"traveler_accommodation\", \"sporting_goods,_hobby,_and_musical_instrument_stores\", \"restaurant\", \"restaurant\", \"restaurant\", \"transit_and_ground_passenger_transportation\", \"traveler_accommodation\", \"health_and_personal_care_stores\", \"restaurant\", \"book_stores_and_news_dealers\", \"traveler_accommodation\", \"grocery_stores\", \"restaurant\", \"restaurant\", \"clothing_stores\", \"restaurant\", \"automotive_equipment_rental_and_leasing\", \"automotive_equipment_rental_and_leasing\", \"automotive_equipment_rental_and_leasing\", \"beer,_wine,_and_liquor_stores\", \"sporting_goods,_hobby,_and_musical_instrument_stores\", \"restaurant\", \"restaurant\", \"automotive_repair_and_maintenance\", \"automotive_repair_and_maintenance\", \"restaurant\", \"traveler_accommodation\", \"restaurant\", \"offices_of_other_health_practitioners\", \"department_stores\", \"health_and_personal_care_stores\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"beer,_wine,_and_liquor_stores\", \"restaurant\", \"drinking_places_(alcoholic_beverages)\", \"restaurant\", \"clothing_stores\", \"health_and_personal_care_stores\", \"health_and_personal_care_stores\", \"restaurant\", \"restaurant\", \"gasoline_stations\", \"health_and_personal_care_stores\", \"restaurant\", \"gasoline_stations\", \"health_and_personal_care_stores\", \"restaurant\", \"clothing_stores\", \"restaurant\", \"restaurant\", \"beer,_wine,_and_liquor_stores\", \"grocery_stores\", \"traveler_accommodation\", \"automotive_repair_and_maintenance\", \"automotive_repair_and_maintenance\", \"beverage_manufacturing\", \"restaurant\", \"offices_of_physicians\", \"restaurant\", \"traveler_accommodation\", \"drinking_places_(alcoholic_beverages)\", \"restaurant\", \"wired_and_wireless_telecommunications_carriers\", \"clothing_stores\", \"retail\", \"restaurant\", \"restaurant\", \"service\", \"service\", \"restaurant\", \"service\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"clothing_stores\", \"restaurant\", \"restaurant\", \"restaurant\", \"health_and_personal_care_stores\", \"restaurant\", \"traveler_accommodation\", \"motion_picture_and_video_industries\", \"restaurant\", \"restaurant\", \"used_merchandise_stores\", \"lessors_of_real_estate\", \"restaurant\", \"restaurant\", \"other_amusement_and_recreation_industries\", \"clothing_stores\", \"restaurant\", \"service\", \"service\", \"building_material_and_supplies_dealers\", \"restaurant\", \"clothing_stores\", \"traveler_accommodation\", \"restaurant\", \"restaurant\", \"grocery_stores\", \"restaurant\", \"restaurant\", \"restaurant\", \"drinking_places_(alcoholic_beverages)\", \"service\", \"restaurant\", \"restaurant\", \"restaurant\", \"automotive_repair_and_maintenance\", \"automotive_repair_and_maintenance\", \"gasoline_stations\", \"gasoline_stations\", \"gasoline_stations\", \"restaurant\", \"restaurant\", \"restaurant\", \"other_amusement_and_recreation_industries\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"sporting_goods,_hobby,_and_musical_instrument_stores\", \"restaurant\", \"automotive_repair_and_maintenance\", \"grocery_stores\", \"restaurant\", \"health_and_personal_care_stores\", \"restaurant\", \"beer,_wine,_and_liquor_stores\", \"service\", \"traveler_accommodation\", \"restaurant\", \"wired_and_wireless_telecommunications_carriers\", \"jewelry,_luggage,_and_leather_goods_stores\", \"restaurant\", \"restaurant\", \"health_and_personal_care_stores\", \"offices_of_other_health_practitioners\", \"service\", \"other_amusement_and_recreation_industries\", \"retail\", \"restaurant\", \"restaurant\", \"museums,_historical_sites,_and_similar_institutions\", \"restaurant\", \"restaurant\", \"drinking_places_(alcoholic_beverages)\", \"restaurant\", \"restaurant\", \"restaurant\", \"shoe_stores\", \"grocery_stores\", \"grocery_stores\", \"restaurant\", \"offices_of_other_health_practitioners\", \"restaurant\", \"restaurant\", \"service\", \"restaurant\", \"used_merchandise_stores\", \"education\", \"restaurant\", \"book_stores_and_news_dealers\", \"restaurant\", \"restaurant\", \"beer,_wine,_and_liquor_stores\", \"gasoline_stations\", \"service\", \"clothing_stores\", \"offices_of_other_health_practitioners\", \"sporting_goods,_hobby,_and_musical_instrument_stores\", \"restaurant\", \"restaurant\", \"other_miscellaneous_manufacturing\", \"restaurant\", \"offices_of_dentists\", \"restaurant\", \"building_material_and_supplies_dealers\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"waste_treatment_and_disposal\", \"restaurant\", \"restaurant\", \"electronics_and_appliance_stores\", \"service\", \"restaurant\", \"restaurant\", \"restaurant\", \"depository_credit_intermediation\", \"restaurant\", \"service\", \"restaurant\", \"health_and_personal_care_stores\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"florists\", \"florists\", \"other_transit_and_ground_passenger_transportation\", \"restaurant\", \"restaurant\", \"restaurant\", \"service\", \"restaurant\", \"restaurant\", \"restaurant\", \"other_amusement_and_recreation_industries\", \"restaurant\", \"service\", \"service\", \"consumer_goods_rental\", \"printing_and_related_support_activities\", \"warehousing_and_storage\", \"jewelry,_luggage,_and_leather_goods_stores\", \"restaurant\", \"health_and_personal_care_stores\", \"beer,_wine,_and_liquor_stores\", \"restaurant\", \"other_amusement_and_recreation_industries\", \"clothing_stores\", \"restaurant\", \"retail\", \"building_material_and_supplies_dealers\", \"health_and_personal_care_stores\", \"restaurant\", \"book_stores_and_news_dealers\", \"service\", \"restaurant\", \"service\", \"service\", \"restaurant\", \"restaurant\", \"grocery_stores\", \"restaurant\", \"grocery_stores\", \"restaurant\", \"restaurant\", \"restaurant\", \"health_and_personal_care_stores\", \"health_and_personal_care_stores\", \"health_and_personal_care_stores\", \"general_merchandise_stores,_including_warehouse_clubs_and_supercenters\", \"beer,_wine,_and_liquor_stores\", \"restaurant\", \"restaurant\", \"service\", \"health_and_personal_care_stores\", \"grocery_stores\", \"restaurant\", \"restaurant\", \"automotive_repair_and_maintenance\", \"clothing_stores\", \"grocery_stores\", \"grocery_stores\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"service\", \"office_supplies,_stationery,_and_gift_stores\", \"restaurant\", \"grocery_stores\", \"electronic_and_precision_equipment_repair_and_maintenance\", \"printing_and_related_support_activities\", \"service\", \"restaurant\", \"restaurant\", \"restaurant\", \"sporting_goods,_hobby,_and_musical_instrument_stores\", \"retail\", \"grocery_stores\", \"shoe_stores\", \"restaurant\", \"automobile_dealers\", \"restaurant\", \"restaurant\", \"clothing_stores\", \"jewelry,_luggage,_and_leather_goods_stores\", \"service\", \"service\", \"grocery_stores\", \"restaurant\", \"grocery_stores\", \"other_amusement_and_recreation_industries\", \"restaurant\", \"gasoline_stations\", \"restaurant\", \"service\", \"restaurant\", \"restaurant\", \"florists\", \"offices_of_dentists\", \"book_stores_and_news_dealers\", \"restaurant\", \"restaurant\", \"other_financial_investment_activities\", \"wired_and_wireless_telecommunications_carriers\", \"service\", \"offices_of_other_health_practitioners\", \"restaurant\", \"restaurant\", \"service\", \"offices_of_dentists\", \"electronics_and_appliance_stores\", \"grocery_stores\", \"service\", \"service\", \"sporting_goods,_hobby,_and_musical_instrument_stores\", \"service\", \"restaurant\", \"other_amusement_and_recreation_industries\", \"service\", \"converted_paper_product_manufacturing\", \"service\", \"electronics_and_appliance_stores\", \"service\", \"service\", \"restaurant\", \"health_and_personal_care_stores\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"wired_and_wireless_telecommunications_carriers\", \"clothing_stores\", \"lessors_of_real_estate\", \"service\", \"home_furnishings_stores\", \"shoe_stores\", \"service\", \"restaurant\", \"restaurant\", \"restaurant\", \"restaurant\", \"service\", \"retail\", \"restaurant\", \"restaurant\", \"service\", \"offices_of_physicians\", \"clothing_stores\", \"restaurant\", \"social_advocacy_organizations\", \"restaurant\", \"clothing_stores\", \"motion_picture_and_video_industries\", \"restaurant\", \"grocery_stores\", \"restaurant\", \"machinery,_equipment,_and_supplies_merchant_wholesalers\", \"service\", \"wired_and_wireless_telecommunications_carriers\", \"museums,_historical_sites,_and_similar_institutions\", \"sporting_goods,_hobby,_and_musical_instrument_stores\", \"service\", \"restaurant\", \"other_miscellaneous_manufacturing\", \"shoe_stores\", \"service\", \"restaurant\", \"other_amusement_and_recreation_industries\", \"restaurant\", \"restaurant\", \"lessors_of_real_estate\", \"restaurant\", \"other_amusement_and_recreation_industries\", \"lessors_of_real_estate\", \"restaurant\", \"restaurant\", \"restaurant\", \"service\", \"restaurant\", \"used_merchandise_stores\", \"higher_education\", \"education\", \"education\", \"beer,_wine,_and_liquor_stores\", \"restaurant\", \"restaurant\", \"service\", \"restaurant\", \"service\", \"restaurant\", \"furniture_stores\", \"restaurant\", \"clothing_stores\", \"restaurant\", \"retail\", \"restaurant\", \"restaurant\", \"restaurant\", \"lessors_of_real_estate\", \"public_administration\", \"service\", \"offices_of_real_estate_agents_and_brokers\", \"restaurant\", \"restaurant\", \"service\", \"restaurant\", \"restaurant\", \"service\", \"restaurant\", \"gasoline_stations\", \"restaurant\", \"service\", \"restaurant\", \"grocery_stores\", \"restaurant\", \"restaurant\", \"retail\", \"restaurant\", \"restaurant\", \"grocery_stores\"]",
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Consumer Spending Patterns"
  },
  {
    "Query": "find top 10 parcels by total RAW_TOTAL_SPEND within 300m of a major shopping area (defined as area with highest retail spending)",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Convert to projected CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Calculate retail spending for each POI\nretail_types = ['restaurant', 'cafe', 'grocery', 'supermarket', 'clothing_store', 'department_store', 'convenience_store']\npoi_retail = poi_proj[poi_proj['business_type'].isin(retail_types)].copy()\n# Merge with spending data\nif 'ml' in spend.columns:\n    spend = spend.rename(columns={'ml': 'ml_spend'})\nelif 'place_id' in spend.columns:\n    spend = spend.rename(columns={'place_id': 'ml_spend'})\npoi_retail = poi_retail.merge(spend, left_on='ml', right_on='ml_spend', how='left')\n# Fill NaN values in spending with 0\nif 'total_spend' in poi_retail.columns:\n    poi_retail['total_spend'] = poi_retail['total_spend'].fillna(0)\nelif 'spend' in poi_retail.columns:\n    poi_retail['spend'] = poi_retail['spend'].fillna(0)\n    poi_retail['total_spend'] = poi_retail['spend']\n# Calculate total retail spending for each POI\nif 'total_spend' in poi_retail.columns:\n    poi_retail['total_spend'] = poi_retail['total_spend'].fillna(0)\nelif 'spend' in poi_retail.columns:\n    poi_retail['total_spend'] = poi_retail['spend'].fillna(0)\n# Identify major shopping area (top 10 POI by retail spending)\ntop_shopping_areas = poi_retail.nlargest(10, 'total_spend')\n# Create 300m buffer around major shopping area\nshopping_buffers = [geom.buffer(300) for geom in top_shopping_areas.geometry]\ncombined_buffer = gpd.GeoSeries(shopping_buffers).unary_union\n# Find parcels within 300m of major shopping area\nparcels_near_shopping = parcels_proj[parcels_proj.geometry.intersects(combined_buffer)].copy()\n# Sort by total RAW_TOTAL_SPEND\nparcels_near_shopping = parcels_near_shopping.sort_values('RAW_TOTAL_SPEND', ascending=False)\n# Get top 10 parcels by spend\ntop_parcels = parcels_near_shopping.head(10)\n# Convert back to original CRS\ntop_parcels = top_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = top_parcels['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Consumer Spending Patterns"
  },
  {
    "Query": "find parcels with retail businesses that have consistently high RAW_TOTAL_SPEND over time",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define retail business codes consistently\nretail_business_codes = ['101', '1011', '102', '1021', '104', '105', '106', '107', '108', '109', \n                         '591', '592', '593', '594', '595', '596', '597', '598', '599']\n# Filter for retail POI\nretail_poi = poi[poi['business_code'].astype(str).isin(retail_business_codes)].copy()\n# Filter for parcels with retail businesses\nretail_parcel_ids = retail_poi['ml'].unique()\nretail_parcels = parcels[parcels['ml'].isin(retail_parcel_ids)].copy()\n# Filter spending data for retail businesses\nretail_spend = spend[spend['ml'].isin(retail_parcel_ids)].copy()\n# Calculate average spend for each retail business\nretail_spend['RAW_TOTAL_SPEND'] = pd.to_numeric(retail_spend['RAW_TOTAL_SPEND'], errors='coerce')\n# Drop NaN values in spend\nretail_spend = retail_spend.dropna(subset=['RAW_TOTAL_SPEND'])\n# Calculate consistent high spend (above 90th percentile)\nhigh_spend_threshold = retail_spend['RAW_TOTAL_SPEND'].quantile(0.9)\nconsistent_high_spend_ids = retail_spend[retail_spend['RAW_TOTAL_SPEND'] >= high_spend_threshold]['ml'].unique()\n# Filter for parcels that meet consistent high spend criteria\nfinal_parcels = retail_parcels[retail_parcels['ml'].isin(consistent_high_spend_ids)].copy()\n# Sort by parcel ID\nfinal_parcels = final_parcels.sort_values('ml')\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(result_ids)",
    "Answer": "[\"Error: 'business_code\"]",
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Consumer Spending Patterns"
  },
  {
    "Query": "find parcels in areas with high youth population (aged 18-24) and high RAW_TOTAL_SPEND",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Convert to projected CRS for accurate distance calculations\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Filter for youth population (18-24) in census data\nyouth_census = census_proj[\n    (census_proj['AGE'] == '18-24') | (census_proj['AGE'] == '24')].copy()\n# Filter for high RAW_TOTAL_SPEND in spending data\nhigh_spend_threshold = spend['RAW_TOTAL_SPEND'].quantile(0.75)\nhigh_spend = spend[spend['RAW_TOTAL_SPEND'] > high_spend_threshold].copy()\n# Define function to check if parcel is in high youth area\ndef is_in_high_youth_area(parcel_geom, youth_areas, buffer_distance=100):  # 100m buffer\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    for area_geom in youth_areas:\n        if buffered_geom.contains(area_geom):\n            return True\n    return False\n# Find high youth areas (where youth population is significantly above average)\nyouth_area_threshold = youth_census['POPULATION'].mean() * 1.5\nhigh_youth_areas = youth_census[youth_census['POPULATION'] > youth_area_threshold]\n# Filter parcels for those in high youth areas\nparcels_in_high_youth = []\nfor idx, row in parcels_proj.iterrows():\n    if is_in_high_youth_area(row['geometry'], high_youth_areas['geometry']):\n        parcels_in_high_youth.append(row['ml'])\n# Filter for high spend among those in high youth areas\nparcels_in_high_youth = list(set(parcels_in_high_youth))  # Remove duplicates\nparcels_high_youth_spend = []\nfor parcel_id in parcels_in_high_youth:\n    if parcel_id in high_spend['ml'].values:\n        parcels_high_youth_spend.append(parcel_id)\n# Sort by parcel ID for consistency\nparcels_high_youth_spend.sort()\n# Convert back to original CRS\nparcels_high_youth_spend = pd.Series(parcels_high_youth_spend)\nparcels_high_youth_spend = parcels_high_youth_spend.to_frame().rename(columns={0: 'ml'})\nparcels_high_youth_spend = parcels_high_youth_spend.merge(parcels, on='ml')\nparcels_high_youth_spend = parcels_high_youth_spend.to_crs(parcels.crs)\n# Output results\nresult_ids = parcels_high_youth_spend['ml'].tolist()\nprint(f",
    "Answer": null,
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Consumer Spending Patterns"
  },
  {
    "Query": "find parcels near universities where student spending is known to be high",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend_data = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define university POIs\nuniversity_pois = ['Harvard University', 'Massachusetts Institute of Technology']\n# Filter for university POIs\nuniversities = poi[poi['name'].isin(university_pois)].copy()\n# Filter for high spending areas\nhigh_spend_tracts = spend_data[spend_data['average_spending'] > 1000]['tract'].tolist()\n# Convert to spatial data\ncensus_with_geom = census.assign(geometry=census['geometry']).copy()\n# Filter for high spending areas using tract\ncensus_high_spend = census_with_geom[census_with_geom['tract'].astype(str).isin(map(str, high_spend_tracts))].copy()\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\nuniversities_proj = universities.to_crs(epsg=26986)\n# Find high spending areas near universities\n# Define a function to find nearby parcels\ndef find_nearby_parcels(univ_geom, cambridge_parcels, buffer_distance=300):  # 300m buffer\n    buffered_geom = univ_geom.buffer(buffer_distance)\n    return cambridge_parcels[cambridge_parcels.geometry.intersects(buffered_geom)].copy()\n# Find nearby parcels for each university\nnearby_parcels_list = []\nfor idx, row in universities_proj.iterrows():\n    nearby = find_nearby_parcels(row['geometry'], parcels_proj)\n    nearby_parcels_list.append(nearby)\n# Combine results\nall_nearby_parcels = pd.concat(nearby_parcels_list)\n# Remove duplicates\nall_nearby_parcels = all_nearby_parcels.drop_duplicates('ml')\n# Sort by proximity to universities (optional)\nall_nearby_parcels = all_nearby_parcels.sort_values('ml')\n# Convert back to original CRS\nall_nearby_parcels = all_nearby_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = all_nearby_parcels['ml'].tolist()\nprint(f\"Found {len(all_nearby_parcels)} parcels near universities with high student spending\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: 'average_spending\"]",
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Consumer Spending Patterns"
  },
  {
    "Query": "find parcels in neighborhoods undergoing revitalization with increasing RAW_TOTAL_SPEND",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Convert to projected CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\n# Define revitalization neighborhoods (based on previous criteria)\nrevitalization_neighborhoods = [\n    'Cambridgeport', 'The Port', 'East Cambridge', 'Inman Square'\n]\n# Filter for revitalization neighborhoods\nparcels_revital = parcels_proj[parcels_proj['neighborhood'].isin(revitalization_neighborhoods)].copy()\n# Merge with spending data\nparcels_with_spend = pd.merge(\n    parcels_revital,\n    spend,\n    left_on='ml',\n    right_on='ml',\n    how='left'\n)\n# Drop rows with NaN spend values\nparcels_with_spend = parcels_with_spend.dropna(subset=['RAW_TOTAL_SPEND'])\n# Sort by spend to find those with increasing spend\nparcels_sorted_by_spend = parcels_with_spend.sort_values('RAW_TOTAL_SPEND')\n# Select parcels that are consistently increasing in spend\nconsistent_spend_parcels = []\nfor idx in range(len(parcels_sorted_by_spend) - 1):\n    if (\n        parcels_sorted_by_spend.iloc[idx]['ml'] + 1 == parcels_sorted_by_spend.iloc[idx + 1]['ml'] and\n        parcels_sorted_by_spend.iloc[idx]['RAW_TOTAL_SPEND'] < parcels_sorted_by_spend.iloc[idx + 1]['RAW_TOTAL_SPEND']\n    ):\n        consistent_spend_parcels.append(parcels_sorted_by_spend.iloc[idx]['ml'])\n# Remove duplicates\nconsistent_spend_parcels = list(set(consistent_spend_parcels))\n# Sort by parcel ID\nconsistent_spend_parcels.sort()\n# Convert back to original CRS\nparcels_with_spend = parcels_with_spend.to_crs(parcels.crs)\n# Print results\nprint(f\"Found {len(consistent_spend_parcels)} parcels in revitalization areas with increasing spend:\")\nprint(consistent_spend_parcels)",
    "Answer": "[\"Error: 'neighborhood\"]",
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Consumer Spending Patterns"
  },
  {
    "Query": "find parcels that are popular food delivery locations based on aggregated spend data",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend_data = pd.read_csv('data/cambridge_spend_processed.csv')\n# Convert to projected CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\n# Define food-related POI categories\nfood_poi_categories = [\n    'restaurant', 'cafe', 'fast_food', 'bakery', 'bar', 'grocery_store',\n    'convenience_store', 'food_market', 'meal_delivery', 'meal_takeaway'\n]\n# Filter food-related POI\nfood_poi = poi[poi['poi_category'].isin(food_poi_categories)].copy()\n# Convert food POI to projected CRS\nfood_poi_proj = food_poi.to_crs(epsg=26986)\n# Filter spending data for food-related transactions\nfood_spend_data = spend_data[spend_data['category'].str.contains('food', case=False)].copy()\n# Convert spend data POI IDs to numeric\nfood_spend_data['poi_id'] = pd.to_numeric(food_spend_data['poi_id'], errors='coerce')\n# Drop NaN POI IDs\nfood_spend_data = food_spend_data.dropna(subset=['poi_id'])\n# Merge food POI with spending data\nfood_poi_with_spend = food_poi.merge(\n    food_spend_data,\n    left='poi_id',\n    right='poi_id',\n    how='left'\n)\n# Aggregate spending by POI\nif 'amount' in food_poi_with_spend.columns:\n    spend_by_poi = food_poi_with_spend.groupby('poi_id')['amount'].sum().reset_index()\nelse:\n    spend_by_poi = food_poi_with_spend.groupby('poi_id')['spend'].sum().reset_index()\nspend_by_poi.rename(columns={'amount': 'total_spend'}, inplace=True)\n# Merge back to POI to get location\nfood_poi_with_spend = food_poi_with_spend.merge(\n    spend_by_poi,\n    on='poi_id',\n    how='left'\n)\n# Filter out POI without spend data\nfood_poi_with_spend = food_poi_with_spend[food_poi_with_spend['total_spend'].notnull()]\n# Sort by spend (higher is better)\nfood_poi_with_spend = food_poi_with_spend.sort_values('total_spend', ascending=False)\n# Get top 30% of POI by spend\ntop_spend_threshold = food_poi_with_spend['total_spend'].quantile(0.7)\npopular_food_poi = food_poi_with_spend[food_poi_with_spend['total_spend'] >= top_spend_threshold]\n# Find which parcels are within 100m of these popular food POI\ndef is_near_popular_food_poi(parcel_geom, popular_poi_geoms, buffer_distance=100):\n    buffered_poi = [geom.buffer(buffer_distance) for geom in popular_poi_geoms]\n    return any(parcel_geom.intersects(buf) for buf in buffered_poi)\n# Get popular POI geometries\npopular_food_poi_geoms = popular_food_poi['geometry'].tolist()\n# Filter parcels\nparcels_near_popular_food = parcels_proj[\n    parcels_proj.geometry.apply(lambda geom: is_near_popular_food_poi(geom, popular_food_poi_geoms))\n].copy()\n# Sort by distance to popular food POI (closer is better)\nparcels_near_popular_food = parcels_near_popular_food.sort_values(\n    parcels_near_popular_food.geometry.apply(lambda geom: min(geom.distance(buf) for buf in buffered_poi))\n)\n# Get parcel IDs\nresult_ids = parcels_near_popular_food['ml'].tolist()\n# Print results\nprint(f",
    "Answer": null,
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Consumer Spending Patterns"
  },
  {
    "Query": "find restaurants that consistently rank in top 10 for RAW_TOTAL_SPEND in their area",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend_data = pd.read_csv('data/cambridge_spend_processed.csv')\n# Convert to projected CRS for accurate distance calculations\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define restaurant POI types\nrestaurant_types = [\n    'restaurant', 'fast_food', 'cafe', 'diner', 'pizzeria', \n    'brunch', 'bistro', 'coffee_shop', 'food_court', 'takeout'\n]\n# Filter for restaurants\nrestaurants = poi_proj[poi_proj['poi_type'].isin(restaurant_types)].copy()\n# Merge with spending data\nrestaurants_with_spend = restaurants.merge(\n    spend_data,\n    left_on='poi_id',\n    right_on='poi_id',\n    how='left'\n)\n# Drop NaN values in RAW_TOTAL_SPEND\nrestaurants_with_spend = restaurants_with_spend.dropna(subset=['RAW_TOTAL_SPEND'])\n# Calculate area-based rankings\ndef calculate_spend_rank(restaurant, spend_df, all_restaurants, k=10):\n    # Get restaurant's location\n    restaurant_geom = restaurant.geometry\n    # Find nearby restaurants within 200m\n    nearby_restaurants = all_restaurants[\n        all_restaurants.geometry.distance(restaurant_geom) <= 200\n    ].copy()\n    \n    # Sort by spend (lower is better)\n    ranked_by_spend = nearby_restaurants.sort_values('RAW_TOTAL_SPEND')\n    \n    # Calculate rank (1 = top spender, k = k-th spender)\n    spend_rank = (ranked_by_spend.index.get_loc(restaurant.name) + 1) if restaurant.name in ranked_by_spend.index else None\n    \n    return spend_rank\n# Calculate spend rank for each restaurant\nrestaurants_with_spend['spend_rank'] = restaurants_with_spend.apply(\n    lambda row: calculate_spend_rank(row, spend_data, restaurants_with_spend),\n    axis=1\n)\n# Filter for restaurants that consistently rank in top 10\nconsistent_top_spenders = restaurants_with_spend[\n    (restaurants_with_spend['spend_rank'].notna()) & \n    (restaurants_with_spend['spend_rank'] <= 10)\n]\n# Sort by rank (lower is better)\nconsistent_top_spenders = consistent_top_spenders.sort_values('spend_rank')\n# Get parcel IDs\nresult_parcels = consistent_top_spenders['ml'].tolist()\n# Convert back to original CRS\nresult_parcels = [str(parcel) for parcel in result_parcels]\n# Print results\nprint(f",
    "Answer": null,
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Consumer Spending Patterns"
  },
  {
    "Query": "find cafes or bakeries near transit hubs with high foot traffic and spend",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Convert to projected CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Define cafe and bakery POI types\ncafe_bakery_types = ['cafe', 'bakery']\n# Filter for cafes and bakeries\ncafes_bakeries = poi_proj[poi_proj['poi_type'].isin(cafe_bakery_types)].copy()\n# Define transit hub locations (Cambridge subway stations)\ntransit_hubs = [\n    (42.365486, -71.103553),  # Harvard Square\n    (42.373611, -71.118956),  # Central Square\n    (42.362490, -71.086176),  # South Station\n    (42.361145, -71.057083),  # Downtown Crossing\n    (42.378202, -71.10364)    # Porter Square\n]\ntransit_hubs_gdf = gpd.GeoDataFrame(\n    transit_hubs,\n    columns=['lat', 'lon'],\n    geometry=gpd.points_from_xy([-h[1] for h in transit_hubs], [h[0] for h in transit_hubs]),\n    crs=parcels.crs\n)\ntransit_hubs_proj = transit_hubs_gdf.to_crs(cambridge_crs)\n# Filter for high foot traffic areas (using spending data)\n# Merge spend data with census data to get foot traffic estimates\ncensus_with_spend = census_proj.merge(\n    spend,\n    left_on='geoid',\n    right_on='geoid',\n    how='left'\n)\n# Fill NaN values in spending with 0\ncensus_with_spend['total_spend'] = census_with_spend['total_spend'].fillna(0)\n# Define high foot traffic as above average spending\naverage_spend = census_with_spend['total_spend'].mean()\nhigh_traffic_areas = census_with_spend[census_with_spend['total_spend'] > average_spend].copy()\n# Filter cafes/bakeries by location near high traffic areas\n# Use 200m buffer for proximity\nhigh_traffic_geom = high_traffic_areas.geometry.unary_union\nhigh_traffic_buffer = high_traffic_geom.buffer(200)  # 200m buffer\n# Find cafes/bakeries near high traffic areas\ncafes_near_high_traffic = cafes_bakeries[cafes_bakeries.geometry.intersects(high_traffic_buffer)].copy()\n# Sort by distance to high traffic areas (closer = better)\ndef sort_by_distance_to_high_traffic(cafe_geom, high_traffic_geom):\n    return cafe_geom.distance(high_traffic_geom)\ncafes_near_high_traffic['distance_to_high_traffic'] = cafes_near_high_traffic.geometry.apply(\n    lambda g: sort_by_distance_to_high_traffic(g, high_traffic_geom)\n)\nresult_cafes = cafes_near_high_traffic.sort_values('distance_to_high_traffic')\n# Convert back to original CRS\nresult_ids = result_cafes['ml'].tolist()\n# Print results\nprint(f\"Found {len(result_cafes)} cafes/bakeries near high foot traffic areas\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "Answer": "[\"Error: cannot import name 'union_all' from 'shapely.ops' (/Users/mingyang/anaconda3/lib/python3.10/site-packages/shapely/ops.py\"]",
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Consumer Spending Patterns"
  },
  {
    "Query": "find popular brunch spots (high weekend spend) within 500m of college campuses",
    "Code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('data/cambridge_parcels.geojson')\npoi = gpd.read_file('data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('data/cambridge_spend_processed.csv')\n# Define college campuses in Cambridge\ncambridge_colleges = [\n    {'name': 'Harvard University', 'location': (-71.1167, 42.3770)},\n    {'name': 'Massachusetts Institute of Technology (MIT)', 'location': (-71.0942, 42.3601)},\n    {'name': 'Lesley University', 'location': (-71.1189, 42.3623)},\n    {'name': 'Cambridge College', 'location': (-71.1032, 42.3736)},\n    {'name': 'Hult International Business School', 'location': (-71.0865, 42.3645)}\n]\n# Convert college locations to GeoDataFrame\ncollege_geoms = [gpd.points_from_xy([loc[0]], [loc[1]])[0] for loc in [c['location'] for c in cambridge_colleges]]\ncolleges = gpd.GeoDataFrame({'name': [c['name'] for c in cambridge_colleges]}, geometry=college_geoms)\ncolleges.crs = parcels.crs\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\ncolleges_proj = colleges.to_crs(epsg=26986)\n# Filter for brunch spots (restaurants with specific cuisine codes)\nrestaurant_cuisines = ['040', '041', '070', '072', '075', '084']  # Breakfast/brunch-related\nbrunch_spots = poi[poi['cuisine'].astype(str).isin(restaurant_cuisines)].copy()\n# Merge with spending data to get weekend spend\nbrunch_spots = brunch_spots.merge(\n    spend[spend['ml'].astype(str).str.startswith('3')], \n    on='ml', \n    how='left'\n)\n# Filter for high weekend spend (top 30%)\nif 'total_spend' in brunch_spots.columns:\n    high_spend_threshold = brunch_spots['total_spend'].quantile(0.7)\n    brunch_spots = brunch_spots[brunch_spots['total_spend'] >= high_spend_threshold]\n# Create 500m buffer around each college\ncollege_buffers = [geom.buffer(500) for geom in colleges_proj.geometry]\n# Find brunch spots within 500m of any college\nresult_ids = set()\nfor buffer in college_buffers:\n    nearby_spots = brunch_spots[brunch_spots.geometry.intersects(buffer)]\n    result_ids.update(nearby_spots['ml'].astype(str))\n# Convert back to original CRS\nparcels_proj = parcels_proj.to_crs(parcels.crs)\n# Filter for results\nresult_parcels = parcels_proj[parcels_proj['ml'].astype(str).isin(result_ids)]\n# Sort by parcel ID\nresult_parcels = result_parcels.sort_values('ml')\n# Output results\nresult_ids = result_parcels['ml'].astype(str).tolist()\nprint(f",
    "Answer": null,
    "Category": "Business_Environment_Constraints",
    "Subcategory": "Consumer Spending Patterns"
  }
]