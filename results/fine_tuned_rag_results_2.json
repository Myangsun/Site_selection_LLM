[
  {
    "query": "find commercial parcels within 500 meters of harvard square.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\n\n# Load the parcel data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\n\n# Load the POI data\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\n\n# Filter POI for Harvard Square\nharvard_square = poi[poi['name'].str.contains('Harvard Square', case=False, na=False)]\n\n# Ensure both GeoDataFrames use the same projected CRS for distance calculations\nparcels = parcels.to_crs(epsg=26986)\nharvard_square = harvard_square.to_crs(epsg=26986)\n\n# Buffer Harvard Square by 500 meters\nharvard_square_buffer = harvard_square.buffer(500)\n\n# Filter parcels that are commercial and within 500 meters of Harvard Square\ncommercial_parcels = parcels[parcels['land_use'] == 'commercial']\nselected_parcels = commercial_parcels[commercial_parcels.intersects(harvard_square_buffer.unary_union)]\n\n# Sort the selected parcels by 'ml' column\nsorted_parcels = selected_parcels.sort_values(by='ml')\n\n# Extract and print the list of parcel IDs\nparcel_ids = sorted_parcels['ml'].tolist()\nprint(parcel_ids)"
  },
  {
    "query": "find parcels larger than 6000 square feet that are zoned for retail use.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\n\n# Load parcel data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\n\n# Ensure the data is in the correct projected CRS for accurate area calculations\nparcels = parcels.to_crs(epsg=26986)\n\n# Filter parcels larger than 6000 square feet and zoned for retail use\nfiltered_parcels = parcels[(parcels['geometry'].area > 6000) & (parcels['zoning'] == 'Retail')]\n\n# Sort the filtered parcels by parcel ID (ml column)\nsorted_parcels = filtered_parcels.sort_values(by='ml')\n\n# Extract the list of parcel IDs\nparcel_ids = sorted_parcels['ml'].tolist()\n\n# Print the final list of parcel IDs\nprint(parcel_ids)"
  },
  {
    "query": "find all parcels that have no more than 2 competing restaurants within 800 meters.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\n\n# Load the data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\n\n# Filter POIs to get only restaurants\nrestaurants = poi[poi['category'] == 'restaurant']\n\n# Project to EPSG:26986 for accurate distance calculations\nparcels = parcels.to_crs(epsg=26986)\nrestaurants = restaurants.to_crs(epsg=26986)\n\n# Buffer restaurants by 800 meters\nrestaurants_buffer = restaurants.buffer(800)\n\n# Spatial join to find parcels within 800 meters of restaurants\nparcels_within_buffer = gpd.sjoin(parcels, gpd.GeoDataFrame(geometry=restaurants_buffer), how='inner', op='intersects')\n\n# Count the number of restaurants within 800 meters for each parcel\nparcel_restaurant_counts = parcels_within_buffer.groupby('index_left').size()\n\n# Filter parcels with no more than 2 restaurants within 800 meters\neligible_parcels = parcel_restaurant_counts[parcel_restaurant_counts <= 2].index\n\n# Get the parcel IDs (ml column) of eligible parcels\nresult_parcels = parcels.loc[eligible_parcels, 'ml']\n\n# Sort the parcel IDs\nsorted_parcel_ids = result_parcels.sort_values()\n\n# Print the final list of parcel IDs\nprint(sorted_parcel_ids.tolist())"
  },
  {
    "query": "find the top 20 parcels in cambridge with the most diverse mix of residential and commercial land uses within 500 meters.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\nfrom shapely.geometry import Point\n\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n\n# Set CRS to EPSG:26986 for accurate distance calculations\nparcels = parcels.to_crs(epsg=26986)\npoi = poi.to_crs(epsg=26986)\n\n# Filter POI for residential and commercial categories\nresidential_poi = poi[poi['category'] == 'residential']\ncommercial_poi = poi[poi['category'] == 'commercial']\n\n# Function to calculate diversity score\ndef calculate_diversity_score(parcel, residential_poi, commercial_poi, buffer_distance=500):\n    buffer = parcel.geometry.buffer(buffer_distance)\n    residential_count = residential_poi[residential_poi.intersects(buffer)].shape[0]\n    commercial_count = commercial_poi[commercial_poi.intersects(buffer)].shape[0]\n    return min(residential_count, commercial_count)\n\n# Calculate diversity score for each parcel\nparcels['diversity_score'] = parcels.apply(\n    calculate_diversity_score, \n    axis=1, \n    residential_poi=residential_poi, \n    commercial_poi=commercial_poi\n)\n\n# Sort parcels by diversity score and select top 20\ntop_parcels = parcels.sort_values(by='diversity_score', ascending=False).head(20)\n\n# Print the list of parcel IDs\nprint(top_parcels['ml'].tolist())"
  },
  {
    "query": "find the top 20 commercial parcels in areas with the highest percentage of residents with advanced degrees.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n\n# Set CRS to EPSG:26986 for accurate distance calculations\nparcels = parcels.to_crs(epsg=26986)\npoi = poi.to_crs(epsg=26986)\ncensus = census.to_crs(epsg=26986)\n\n# Filter for commercial parcels\ncommercial_parcels = parcels[parcels['land_use'] == 'commercial']\n\n# Merge parcels with census data to get percentage of residents with advanced degrees\nparcels_with_census = gpd.sjoin(commercial_parcels, census, how='inner', op='intersects')\n\n# Sort parcels by percentage of residents with advanced degrees\nsorted_parcels = parcels_with_census.sort_values(by='pct_advanced_degrees', ascending=False)\n\n# Select top 20 parcels\ntop_20_parcels = sorted_parcels.head(20)\n\n# Extract parcel IDs\ntop_20_parcel_ids = top_20_parcels['ml'].tolist()\n\n# Print the final list of parcel IDs\nprint(top_20_parcel_ids)"
  },
  {
    "query": "\u201cfind the top 20 parcels with the highest consumer spending in surrounding areas.\u201d",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\nspending = pd.read_csv('../data/cambridge_spend_processed.csv')\n\n# Set CRS to EPSG:26986 for accurate distance calculations\nparcels = parcels.to_crs(epsg=26986)\npoi = poi.to_crs(epsg=26986)\ncensus = census.to_crs(epsg=26986)\n\n# Merge spending data with census data\ncensus = census.merge(spending, on='census_tract_id')\n\n# Calculate total spending in surrounding areas for each parcel\ndef calculate_surrounding_spending(parcel):\n    buffer = parcel.geometry.buffer(500)  # 500 meters buffer\n    nearby_census = census[census.intersects(buffer)]\n    return nearby_census['spending'].sum()\n\nparcels['surrounding_spending'] = parcels.apply(calculate_surrounding_spending, axis=1)\n\n# Sort parcels by surrounding spending and get top 20\ntop_parcels = parcels.nlargest(20, 'surrounding_spending')\n\n# Extract and print the list of parcel IDs\ntop_parcel_ids = top_parcels['ml'].tolist()\nprint(top_parcel_ids)"
  },
  {
    "query": "find vacant commercial parcels larger than 3000 square feet that are within 800 meters of a subway station.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\n\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\n\n# Filter for subway stations\nsubway_stations = poi[poi['type'] == 'subway_station']\n\n# Project to EPSG:26986 for accurate distance calculations\nparcels = parcels.to_crs(epsg=26986)\nsubway_stations = subway_stations.to_crs(epsg=26986)\n\n# Filter parcels: vacant, commercial, and larger than 3000 square feet\nvacant_commercial_parcels = parcels[\n    (parcels['use'] == 'commercial') &\n    (parcels['status'] == 'vacant') &\n    (parcels['area'] > 3000)\n]\n\n# Buffer subway stations by 800 meters\nsubway_buffer = subway_stations.buffer(800)\n\n# Find parcels within 800 meters of a subway station\nparcels_within_buffer = vacant_commercial_parcels[\n    vacant_commercial_parcels.intersects(subway_buffer.unary_union)\n]\n\n# Sort by parcel ID (ml column)\nsorted_parcels = parcels_within_buffer.sort_values(by='ml')\n\n# Extract and print the list of parcel IDs\nparcel_ids = sorted_parcels['ml'].tolist()\nprint(parcel_ids)"
  },
  {
    "query": "find commercial parcels zoned for retail use with fewer than 3 competing retail businesses within 300 meters.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\n\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\n\n# Project data to EPSG:26986 for accurate distance calculations\nparcels = parcels.to_crs(epsg=26986)\npoi = poi.to_crs(epsg=26986)\n\n# Filter parcels for commercial parcels zoned for retail use\ncommercial_parcels = parcels[parcels['zoning'] == 'Retail']\n\n# Filter POI for retail businesses\nretail_poi = poi[poi['business_type'] == 'Retail']\n\n# Function to count competing businesses within 300 meters\ndef count_competing_retail(parcel):\n    buffer = parcel.geometry.buffer(300)\n    competing_retail = retail_poi[retail_poi.geometry.within(buffer)]\n    return len(competing_retail)\n\n# Apply function to count competing businesses\ncommercial_parcels['competing_retail_count'] = commercial_parcels.apply(count_competing_retail, axis=1)\n\n# Filter parcels with fewer than 3 competing retail businesses\nsuitable_parcels = commercial_parcels[commercial_parcels['competing_retail_count'] < 3]\n\n# Sort parcels by 'ml' column\nsorted_parcels = suitable_parcels.sort_values(by='ml')\n\n# Extract and print the list of parcel IDs\nparcel_ids = sorted_parcels['ml'].tolist()\nprint(parcel_ids)"
  },
  {
    "query": "find the top 20 commercial parcels within 1km of massachusetts avenue, prioritizing areas with higher consumer spending.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\nspending = pd.read_csv('../data/cambridge_spend_processed.csv')\n\n# Ensure all GeoDataFrames use the same CRS\nparcels = parcels.to_crs(epsg=26986)\npoi = poi.to_crs(epsg=26986)\ncensus = census.to_crs(epsg=26986)\n\n# Filter POIs for Massachusetts Avenue\nmass_ave_poi = poi[poi['name'].str.contains('Massachusetts Avenue', case=False, na=False)]\n\n# Buffer POIs to 1km\nmass_ave_buffer = mass_ave_poi.buffer(1000)\n\n# Combine buffers into a single geometry\nmass_ave_union = mass_ave_buffer.unary_union\n\n# Filter parcels within 1km of Massachusetts Avenue\nparcels_within_1km = parcels[parcels.intersects(mass_ave_union)]\n\n# Merge parcels with spending data\nparcels_with_spending = parcels_within_1km.merge(spending, left_on='ml', right_on='parcel_id')\n\n# Sort parcels by consumer spending\nsorted_parcels = parcels_with_spending.sort_values(by='consumer_spending', ascending=False)\n\n# Select top 20 parcels\ntop_20_parcels = sorted_parcels.head(20)\n\n# Print the list of parcel IDs\nprint(top_20_parcels['ml'].tolist())"
  },
  {
    "query": "find commercial parcels larger than 8000 square feet in census tracts with at least 90% of residents aged 18-64.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\n\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n\n# Set CRS to EPSG:26986 for accurate spatial operations\nparcels = parcels.to_crs(epsg=26986)\ncensus = census.to_crs(epsg=26986)\n\n# Filter parcels: commercial and larger than 8000 square feet\ncommercial_parcels = parcels[(parcels['land_use'] == 'commercial') & (parcels['area'] > 8000)]\n\n# Filter census tracts: at least 90% of residents aged 18-64\ncensus_filtered = census[census['pct_18_64'] >= 90]\n\n# Spatial join to find parcels in the desired census tracts\nselected_parcels = gpd.sjoin(commercial_parcels, census_filtered, how='inner', op='intersects')\n\n# Sort and extract parcel IDs\nsorted_parcel_ids = selected_parcels['ml'].sort_values().tolist()\n\n# Print the final list of parcel IDs\nprint(sorted_parcel_ids)"
  },
  {
    "query": "find commercial parcels that are between 5000-10000 square feet, within 500 meters of a subway station, and have no more than 1 competitor within 500 meters.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\n\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\n\n# Set CRS to EPSG:26986 for accurate distance calculations\nparcels = parcels.to_crs(epsg=26986)\npoi = poi.to_crs(epsg=26986)\n\n# Filter commercial parcels between 5000-10000 square feet\ncommercial_parcels = parcels[(parcels['land_use'] == 'commercial') & \n                             (parcels['area'] >= 5000) & \n                             (parcels['area'] <= 10000)]\n\n# Identify subway stations\nsubway_stations = poi[poi['type'] == 'subway_station']\n\n# Buffer subway stations by 500 meters\nsubway_buffer = subway_stations.buffer(500)\n\n# Find parcels within 500 meters of a subway station\nparcels_near_subway = commercial_parcels[commercial_parcels.intersects(subway_buffer.unary_union)]\n\n# Identify competitors\ncompetitors = poi[poi['type'] == 'competitor']\n\n# Function to count competitors within 500 meters\ndef count_competitors(parcel):\n    buffer = parcel.geometry.buffer(500)\n    return competitors[competitors.intersects(buffer)].shape[0]\n\n# Filter parcels with no more than 1 competitor within 500 meters\nsuitable_parcels = parcels_near_subway[parcels_near_subway.apply(count_competitors, axis=1) <= 1]\n\n# Sort by parcel ID (ml column)\nsorted_parcels = suitable_parcels.sort_values(by='ml')\n\n# Print the list of parcel IDs\nprint(sorted_parcels['ml'].tolist())"
  },
  {
    "query": "find parcels that are zoned for mixed-use, within 400 meters of public transportation, and at least 200 meters away from industrial areas.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\n\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n\n# Set CRS to EPSG:26986 for accurate distance calculations\nparcels = parcels.to_crs(epsg=26986)\npoi = poi.to_crs(epsg=26986)\ncensus = census.to_crs(epsg=26986)\n\n# Filter parcels for mixed-use zoning\nmixed_use_parcels = parcels[parcels['zoning'] == 'mixed-use']\n\n# Filter POIs for public transportation\npublic_transport_poi = poi[poi['type'] == 'public_transport']\n\n# Buffer public transport POIs by 400 meters\npublic_transport_buffer = public_transport_poi.buffer(400)\n\n# Find parcels within 400 meters of public transportation\nparcels_near_transport = mixed_use_parcels[mixed_use_parcels.intersects(public_transport_buffer.unary_union)]\n\n# Filter census data for industrial areas\nindustrial_areas = census[census['land_use'] == 'industrial']\n\n# Buffer industrial areas by 200 meters\nindustrial_buffer = industrial_areas.buffer(200)\n\n# Find parcels at least 200 meters away from industrial areas\nparcels_away_from_industrial = parcels_near_transport[~parcels_near_transport.intersects(industrial_buffer.unary_union)]\n\n# Extract and sort parcel IDs\nparcel_ids = parcels_away_from_industrial['ml'].sort_values().tolist()\n\n# Print the final list of parcel IDs\nprint(parcel_ids)"
  },
  {
    "query": "find retail parcels between 2000-5000 square feet within 500m of a residential area, prioritizing locations with high foot traffic and in census tracts with median income above $30,000.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\nspending = pd.read_csv('../data/cambridge_spend_processed.csv')\n\n# Project to EPSG:26986 for accurate distance calculations\nparcels = parcels.to_crs(epsg=26986)\npoi = poi.to_crs(epsg=26986)\ncensus = census.to_crs(epsg=26986)\n\n# Filter parcels by area\nparcels_filtered = parcels[(parcels['area'] >= 2000) & (parcels['area'] <= 5000)]\n\n# Identify residential areas\nresidential_poi = poi[poi['type'] == 'residential']\n\n# Buffer residential areas by 500m\nresidential_buffer = residential_poi.buffer(500)\n\n# Find parcels within 500m of residential areas\nparcels_near_residential = parcels_filtered[parcels_filtered.intersects(residential_buffer.unary_union)]\n\n# Join parcels with census data to filter by median income\nparcels_with_census = gpd.sjoin(parcels_near_residential, census, how='inner', op='intersects')\nparcels_high_income = parcels_with_census[parcels_with_census['median_income'] > 30000]\n\n# Join with spending data to prioritize high foot traffic\nparcels_high_income = parcels_high_income.merge(spending, left_on='ml', right_on='parcel_id', how='left')\n\n# Sort by foot traffic (assuming 'foot_traffic' column exists in spending data)\nsorted_parcels = parcels_high_income.sort_values(by='foot_traffic', ascending=False)\n\n# Extract and print parcel IDs\nparcel_ids = sorted_parcels['ml'].tolist()\nprint(parcel_ids)"
  },
  {
    "query": "find office parcels larger than 5000 square feet with at least 2 parking spaces, prioritizing those in areas with high educational attainment.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n\n# Set CRS to EPSG:26986 for accurate spatial operations\nparcels = parcels.to_crs(epsg=26986)\npoi = poi.to_crs(epsg=26986)\ncensus = census.to_crs(epsg=26986)\n\n# Filter parcels larger than 5000 square feet with at least 2 parking spaces\nfiltered_parcels = parcels[(parcels['area'] > 5000) & (parcels['parking_spaces'] >= 2)]\n\n# Join parcels with census data to get educational attainment\nparcels_with_census = gpd.sjoin(filtered_parcels, census, how='left', op='intersects')\n\n# Sort parcels by educational attainment (assuming column 'education_attainment' exists)\nsorted_parcels = parcels_with_census.sort_values(by='education_attainment', ascending=False)\n\n# Extract sorted list of parcel IDs\nsorted_parcel_ids = sorted_parcels['ml'].tolist()\n\n# Print the final list of parcel IDs\nprint(sorted_parcel_ids)"
  },
  {
    "query": "find parcels that are either commercial places within 100m of harvard square or residential larger than 5000 square feet and within 200m of 50 restaurants.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\nfrom shapely.geometry import Point\n\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson').to_crs(epsg=26986)\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson').to_crs(epsg=26986)\n\n# Define Harvard Square location\nharvard_square = Point(-71.1189, 42.3736)\nharvard_square = gpd.GeoSeries([harvard_square], crs='EPSG:4326').to_crs(epsg=26986)\n\n# Filter POI for restaurants\nrestaurants = poi[poi['type'] == 'restaurant']\n\n# Commercial parcels within 100m of Harvard Square\ncommercial_near_harvard = parcels[\n    (parcels['land_use'] == 'commercial') &\n    (parcels.geometry.distance(harvard_square.geometry[0]) <= 100)\n]\n\n# Residential parcels larger than 5000 sqft\nresidential_large = parcels[\n    (parcels['land_use'] == 'residential') &\n    (parcels['area'] > 5000)\n]\n\n# Residential parcels within 200m of 50 restaurants\nresidential_near_restaurants = residential_large[\n    residential_large.geometry.apply(\n        lambda x: restaurants.geometry.distance(x).lt(200).sum() >= 50\n    )\n]\n\n# Combine results\nselected_parcels = commercial_near_harvard.append(residential_near_restaurants)\n\n# Sort and get parcel IDs\nsorted_parcel_ids = selected_parcels['ml'].sort_values().tolist()\n\n# Print the final list of parcel IDs\nprint(sorted_parcel_ids)"
  },
  {
    "query": "find parcels that are zoned for retail and within 300m of a subway station and not within 100m of a competitor.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\n\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\n\n# Set CRS to EPSG:26986 for accurate distance calculations\nparcels = parcels.to_crs(epsg=26986)\npoi = poi.to_crs(epsg=26986)\n\n# Filter POI for subway stations and competitors\nsubway_stations = poi[poi['type'] == 'subway_station']\ncompetitors = poi[poi['type'] == 'competitor']\n\n# Filter parcels zoned for retail\nretail_parcels = parcels[parcels['zoning'] == 'retail']\n\n# Find parcels within 300m of a subway station\nretail_near_subway = retail_parcels[\n    retail_parcels.geometry.apply(\n        lambda geom: subway_stations.distance(geom).min() <= 300\n    )\n]\n\n# Exclude parcels within 100m of a competitor\nfinal_parcels = retail_near_subway[\n    retail_near_subway.geometry.apply(\n        lambda geom: competitors.distance(geom).min() > 100\n    )\n]\n\n# Sort and extract parcel IDs\nsorted_parcel_ids = final_parcels['ml'].sort_values().tolist()\n\n# Print the final list of parcel IDs\nprint(sorted_parcel_ids)"
  },
  {
    "query": "find parcels that are either office space larger than 10,000 sq ft or retail space within 500m of high-density residential areas.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\n\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n\n# Set CRS to EPSG:26986 for accurate distance calculations\nparcels = parcels.to_crs(epsg=26986)\npoi = poi.to_crs(epsg=26986)\ncensus = census.to_crs(epsg=26986)\n\n# Filter parcels for office space larger than 10,000 sq ft\noffice_parcels = parcels[(parcels['use'] == 'office') & (parcels['area'] > 10000)]\n\n# Filter census data for high-density residential areas\nhigh_density_residential = census[census['density'] > threshold]  # Define a threshold for high density\n\n# Buffer high-density residential areas by 500m\nhigh_density_buffer = high_density_residential.buffer(500)\n\n# Filter parcels for retail space within 500m of high-density residential areas\nretail_parcels = parcels[parcels['use'] == 'retail']\nretail_near_high_density = retail_parcels[retail_parcels.intersects(high_density_buffer.unary_union)]\n\n# Combine results\nselected_parcels = office_parcels.append(retail_near_high_density).drop_duplicates()\n\n# Sort by parcel ID\nselected_parcels_sorted = selected_parcels.sort_values(by='ml')\n\n# Print the list of parcel IDs\nprint(selected_parcels_sorted['ml'].tolist())"
  },
  {
    "query": "find commercial parcels that, if larger than 5000 sq ft, must be within 400m of public transit, or if smaller, must be within 200m of residential areas.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\n\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n\n# Set CRS to EPSG:26986 for accurate distance calculations\nparcels = parcels.to_crs(epsg=26986)\npoi = poi.to_crs(epsg=26986)\ncensus = census.to_crs(epsg=26986)\n\n# Filter POI for public transit\npublic_transit = poi[poi['type'] == 'public_transit']\n\n# Filter census for residential areas\nresidential_areas = census[census['land_use'] == 'residential']\n\n# Spatial join to find parcels within distance criteria\nparcels_large = parcels[parcels['area'] > 5000]\nparcels_small = parcels[parcels['area'] <= 5000]\n\n# Buffer and spatial join for large parcels\nbuffered_transit = public_transit.buffer(400)\nlarge_near_transit = gpd.sjoin(parcels_large, buffered_transit, op='intersects')\n\n# Buffer and spatial join for small parcels\nbuffered_residential = residential_areas.buffer(200)\nsmall_near_residential = gpd.sjoin(parcels_small, buffered_residential, op='intersects')\n\n# Combine results\nselected_parcels = large_near_transit['ml'].append(small_near_residential['ml']).unique()\n\n# Sort and print the final list of parcel IDs\nsorted_parcel_ids = sorted(selected_parcels)\nprint(sorted_parcel_ids)"
  },
  {
    "query": "find parcels that are: if zoned for commercial, must be larger than 8000 sq ft; if zoned for residential, must have less than 2 similar properties within 1000m",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\n\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\n\n# Set CRS to EPSG:26986 for accurate distance calculations\nparcels = parcels.to_crs(epsg=26986)\npoi = poi.to_crs(epsg=26986)\n\n# Filter parcels based on zoning and size\ncommercial_parcels = parcels[(parcels['zoning'] == 'commercial') & (parcels['area'] > 8000)]\nresidential_parcels = parcels[parcels['zoning'] == 'residential']\n\n# Function to count similar properties within 1000m\ndef count_similar_properties(parcel, all_parcels):\n    buffer = parcel.geometry.buffer(1000)\n    similar = all_parcels[all_parcels.geometry.within(buffer)]\n    return len(similar) - 1  # Exclude the parcel itself\n\n# Filter residential parcels with less than 2 similar properties within 1000m\nfiltered_residential = residential_parcels[\n    residential_parcels.apply(lambda row: count_similar_properties(row, residential_parcels) < 2, axis=1)\n]\n\n# Combine filtered parcels\nfiltered_parcels = commercial_parcels.append(filtered_residential)\n\n# Sort by parcel ID (ml column)\nsorted_parcels = filtered_parcels.sort_values(by='ml')\n\n# Extract and print the list of parcel IDs\nparcel_ids = sorted_parcels['ml'].tolist()\nprint(parcel_ids)"
  },
  {
    "query": "find mixed-use parcels that, if north of massachusetts avenue, must have retail on the ground floor, otherwise must have at least 3000 sq ft of commercial space.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-2024-08-06:mit:spatial-agent-20250505-213242:BU8HJW5s",
    "success": false,
    "code": "import geopandas as gpd\n\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\n\n# Set CRS to EPSG:26986 for accurate spatial operations\nparcels = parcels.to_crs(epsg=26986)\npoi = poi.to_crs(epsg=26986)\n\n# Define Massachusetts Avenue line (approximate)\nmass_ave_line = gpd.GeoSeries.from_wkt([\n    \"LINESTRING (X1 Y1, X2 Y2)\"  # Replace X1, Y1, X2, Y2 with actual coordinates\n]).set_crs(epsg=26986)\n\n# Filter parcels north of Massachusetts Avenue\nnorth_parcels = parcels[parcels.intersects(mass_ave_line.unary_union)]\n\n# Filter for retail on the ground floor\nretail_poi = poi[poi['category'] == 'retail']\nnorth_with_retail = north_parcels[north_parcels.intersects(retail_poi.unary_union)]\n\n# Filter parcels south of Massachusetts Avenue\nsouth_parcels = parcels[~parcels.index.isin(north_parcels.index)]\n\n# Filter for at least 3000 sq ft of commercial space\nsouth_with_commercial = south_parcels[south_parcels['commercial_sqft'] >= 3000]\n\n# Combine results\nselected_parcels = north_with_retail.append(south_with_commercial)\n\n# Sort by parcel ID (ml column)\nsorted_parcel_ids = selected_parcels['ml'].sort_values().tolist()\n\n# Print the final list of parcel IDs\nprint(sorted_parcel_ids)\n```\n\nNote: Replace `\"LINESTRING (X1 Y1, X2 Y2)\"` with the actual coordinates of Massachusetts Avenue."
  }
]