{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find retail parcels that are within 300 meters of a subway station."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n\n\n# Define subway station locations (longitude, latitude)\nsubway_coords = [\n    (-71.1189, 42.3736),  # Harvard Square\n    (-71.1032, 42.3656),  # Central Square\n    (-71.0865, 42.3625),  # Kendall/MIT\n    (-71.1226, 42.3782),  # Porter Square\n    (-71.1429, 42.3954)   # Alewife\n]\n\n\n# Create GeoDataFrame for subway stations\nsubway_gdf = gpd.GeoDataFrame(\n    geometry=gpd.points_from_xy(\n        [lon for lon, lat in subway_coords],\n        [lat for lon, lat in subway_coords]\n    ),\n    crs='EPSG:4326'\n)\n\n\n# Project to metric CRS for spatial buffer\nparcels_proj = parcels.to_crs(epsg=26986)\nsubway_proj = subway_gdf.to_crs(epsg=26986)\n\n\n# Filter for retail parcels\nretail_codes = ['323', '324', '325', '326', '327', '330']\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_codes)]\n\n\n# Create 300m buffer and find intersecting parcels\nsubway_buffer = subway_proj.buffer(300).union_all()\nretail_near_subway = retail_parcels[retail_parcels.geometry.intersects(subway_buffer)]\n\n\n# Return parcel IDs\nresult_ids = retail_near_subway.sort_values('ml')['ml'].tolist()\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find office parcels larger than 10000 square feet"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\n\n# Define office use codes based on the land use table\noffice_use_codes = [\n    '340',  # GEN-OFFICE\n    '343',  # OFFICE-CONDO\n    '345',  # RETAIL-OFFIC\n    '346',  # INV-OFFICE\n    '0340'  # MXD GEN-OFFICE\n]\n\n# Filter for office parcels larger than 10000 sq ft\nlarge_office_parcels = parcels_proj[\n    (parcels_proj['use_code'].astype(str).isin(office_use_codes)) & \n    (parcels_proj['land_area'] > 10000)\n].copy()\n\n# Sort by parcel ID (ml) for consistency\nlarge_office_parcels = large_office_parcels.sort_values('ml')\n\n# Convert back to original CRS\nlarge_office_parcels = large_office_parcels.to_crs(parcels.crs)\n\n# Extract parcel IDs\nresult_ids = large_office_parcels['ml'].tolist()\n\n# Print results\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find commercial parcels larger than 5000 square feet AND within 400 meters of harvard square"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n# Define Harvard Square location\nharvard_square_point = Point(-71.1189, 42.3736)\nharvard_square = gpd.GeoDataFrame(geometry=[harvard_square_point], crs=parcels.crs)\n\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\nharvard_square_proj = harvard_square.to_crs(epsg=26986)\n\n# Filter for commercial parcels larger than 5000 sq ft\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\nlarge_commercial_parcels = parcels_proj[\n    (parcels_proj['use_code'].astype(str).isin(commercial_use_codes)) & \n    (parcels_proj['land_area'] > 5000) \n].copy()\n\n# Filter for parcels within 400m of Harvard Square\nharvard_buffer = harvard_square_proj.geometry[0].buffer(400)\nparcels_near_harvard = large_commercial_parcels[large_commercial_parcels.geometry.intersects(harvard_buffer)].copy()\n\n# Sort by parcel ID (ml)\nresult_ids = parcels_near_harvard['ml'].sort_values().tolist()\n\n# Convert back to original CRS\nparcels_near_harvard = parcels_near_harvard.to_crs(parcels.crs)\n\n# Output results\nprint(f\"Found {len(parcels_near_harvard)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find large commercial parcels (over 5000 sq ft) close to popular shopping areas, preferably in locations with high consumer spending and educational institutions"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\npoi     = gpd.read_file('cambridge_poi_processed.geojson').to_crs(epsg=26986)\nspend   = pd.read_csv('cambridge_spend_processed.csv')\n\n# Merge spending into POI and fill NaNs\npoi_spend = poi.merge(spend, on='PLACEKEY', how='left')\npoi_spend['RAW_TOTAL_SPEND'] = poi_spend['RAW_TOTAL_SPEND'].fillna(0.0)\n\n# Filter commercial parcels >5000 sq ft\ncomm_codes = [\n    '300','302','316','323','324','325','326','327',\n    '330','332','334','340','341','343','345','346',\n    '353','362','375','404','406','0340','0406'\n]\nlarge_comm = parcels[(parcels['use_code'].isin(comm_codes)) & (parcels['land_area'] > 5000)].copy()\n\n# Buffer shopping areas (malls, centers) by 500m\nshops = poi[poi['SUB_CATEGORY']== 'Malls']\nbuf_shops = shops.geometry.buffer(500).union_all()\nnear_shops = large_comm[large_comm.geometry.intersects(buf_shops)].copy()\n\n# Compute average spending within 500m of each parcel\ndef assign_spend(geom):\n    buf = geom.buffer(500)\n    vals = poi_spend[poi_spend.geometry.within(buf)]['RAW_TOTAL_SPEND']\n    return float(vals.mean()) if not vals.empty else 0.0\nnear_shops['parcel_spend'] = near_shops.geometry.apply(assign_spend)\n\n# Ensure numeric dtype and drop NaNs before quantile\nnear_shops['parcel_spend'] = pd.to_numeric(near_shops['parcel_spend'], errors='coerce')\nif near_shops['parcel_spend'].notna().any():\n    threshold = near_shops['parcel_spend'].quantile(0.8)\n    high_spend = near_shops[near_shops['parcel_spend'] >= threshold].copy()\nelse:\n    high_spend = near_shops.copy()\n\n# Buffer educational institutions 500m and filter\nunis = poi[poi['SUB_CATEGORY'].str.contains('Colleges, Universities, and Professional Schools', case=False, na=False)]\nbuf_unis = unis.geometry.buffer(500).union_all()\nfinal = high_spend[high_spend.geometry.intersects(buf_unis)].copy()\n\n# Print parcel IDs\nresult_ids = sorted(final['ml'].tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find commercial parcels that are between 5000-10000 square feet, within 500 meters of a subway station, and have no more than 1 competitor within 500 meters."}, {"role": "assistant", "content": "import geopandas as gpd\nfrom shapely.geometry import Point\nfrom shapely.ops import unary_union\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\n# Define subway station locations\nsubway_stations = [\n    Point(-71.1189, 42.3736),  # Harvard Square\n    Point(-71.1031, 42.3656),  # Central Square\n    Point(-71.0865, 42.3625),  # Kendall/MIT\n    Point(-71.1226, 42.3782),  # Porter Square\n    Point(-71.1429, 42.3954)   # Alewife\n]\nsubway_gdf = gpd.GeoDataFrame(geometry=subway_stations, crs=parcels.crs)\n# Convert to projected CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\nsubway_gdf_proj = subway_gdf.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_use_codes)].copy()\n# CONSTRAINT 1: Size between 5000-10000 sq ft\nsize_filtered_parcels = commercial_parcels[\n    (commercial_parcels['land_area'] >= 5000) & \n    (commercial_parcels['land_area'] <= 10000)\n]\n# CONSTRAINT 2: Within 500m of subway station\n# Create 500m buffer around subway stations\nsubway_buffers = [geom.buffer(500) for geom in subway_gdf_proj.geometry]\nunion_buffer = unary_union(subway_buffers)\n# Filter by location, as a true copy\nlocation_filtered_parcels = size_filtered_parcels[\n    size_filtered_parcels.geometry.intersects(union_buffer)\n].copy()\n# CONSTRAINT 3: No more than 1 competitor within 500m\n# First identify competitors (businesses of same type)\ndef count_competitors(parcel_geom, parcel_use_code, poi_geoms, poi_use_codes, buffer_distance=500):\n    # Get business type for this parcel\n    parcel_type = str(parcel_use_code)[:3]  # First 3 digits of use code\n    \n    # Get competitor business types\n    competitor_types = []\n    if parcel_type.startswith('32'):  # Retail\n        competitor_types = ['restaurant', 'clothing_store', 'department_store', 'grocery_store', \n                           'convenience_store', 'retail']\n    elif parcel_type.startswith('33'):  # Food service\n        competitor_types = ['restaurant', 'cafe', 'bakery', 'fast_food']\n    elif parcel_type.startswith('31'):  # Office\n        competitor_types = ['offices_of_physicians', 'offices_of_other_health_practitioners',\n                          'offices_of_dentists', 'offices_of_real_estate_agents']\n    else:\n        competitor_types = ['business_type']  # Generic\n    \n    # Create buffer\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    \n    # Count competitors\n    count = 0\n    for i, (geom, use_code) in enumerate(zip(poi_geoms, poi_use_codes)):\n        if geom is not None and buffered_geom.contains(geom):\n            if any(comp_type in str(use_code).lower() for comp_type in competitor_types):\n                count += 1\n    \n    return count\n# Get competitors for each parcel\npoi_geoms = poi_proj['geometry'].tolist()\npoi_use_codes = poi_proj['business_type'].tolist()\ncompetitor_counts = []\nfor idx, row in location_filtered_parcels.iterrows():\n    count = count_competitors(row['geometry'], row['use_code'], poi_geoms, poi_use_codes)\n    competitor_counts.append(count)\nlocation_filtered_parcels.loc[:, 'competitor_count'] = competitor_counts\n# Filter for parcels with at most 1 competitor\nfinal_parcels = location_filtered_parcels[location_filtered_parcels['competitor_count'] <= 1]\n# Convert back to original CRS\nfinal_parcels = final_parcels.to_crs(parcels.crs)\n# Display results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} commercial parcels meeting all criteria:\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find retail parcels between 2000-5000 square feet within 500m of a residential area, prioritizing locations with high foot traffic and in census tracts with median income above $30,000."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.ops import unary_union\nimport numpy as np\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Define retail use codes consistently\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Define residential use codes\nresidential_use_codes = [\n    '101', '1014', '102', '1028', '104', '105', '109', '1094', '1095', \n    '1098', '111', '112', '113', '114', '121', '970', '9700', '9421'\n]\n# CONSTRAINT 1: Filter for retail parcels of the specified size\nretail_parcels = parcels_proj[\n    (parcels_proj['use_code'].astype(str).isin(retail_use_codes)) & \n    (parcels_proj['land_area'] >= 2000) & \n    (parcels_proj['land_area'] <= 5000)\n].copy()\n# CONSTRAINT 2: Filter for parcels within 500m of residential areas\n# First, identify all residential parcels\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_use_codes)]\n# Create 500m buffer around residential areas\nresidential_buffers = [geom.buffer(500) for geom in residential_parcels.geometry]\n# Use shapely's unary_union directly\nresidential_union_buffer = unary_union(residential_buffers)\n# Filter retail parcels by proximity to residential areas\nnear_residential_parcels = retail_parcels[\n    retail_parcels.geometry.intersects(residential_union_buffer)\n].copy()\n# CONSTRAINT 3: Join with census data to filter for high-income areas\n# Spatial join to get census tract for each parcel\nparcels_with_census = gpd.sjoin(\n    near_residential_parcels,\n    census_proj,\n    how='left',\n    predicate='within'\n)\n# Filter for areas with median income above $30,000\nif 'median_income' in parcels_with_census.columns:\n    income_filtered_parcels = parcels_with_census[parcels_with_census['median_income'] > 30000].copy()\nelse:\n    # If the exact column name is different, adjust accordingly\n    income_filtered_parcels = parcels_with_census.copy()\n    print(\"Warning: 'median_income' column not found, skipping income filter\")\n# SOFT CONSTRAINT: Prioritize areas with high foot traffic\n# Use POI density as a proxy for foot traffic\ndef calculate_foot_traffic_score(parcel_geom, poi_geoms, buffer_distance=200):\n    buffer = parcel_geom.buffer(buffer_distance)\n    # Count POIs within buffer (more POIs = higher foot traffic)\n    poi_count = sum(1 for geom in poi_geoms if buffer.contains(geom))\n    return poi_count\n# Get all POI geometries\npoi_geoms = poi_proj['geometry'].tolist()\n# Calculate foot traffic score for each parcel\nincome_filtered_parcels['foot_traffic_score'] = income_filtered_parcels['geometry'].apply(\n    lambda geom: calculate_foot_traffic_score(geom, poi_geoms)\n)\n# Sort by foot traffic score (descending) to prioritize high foot traffic areas\nprioritized_parcels = income_filtered_parcels.sort_values('foot_traffic_score', ascending=False)\n# Convert back to original CRS\nfinal_parcels = prioritized_parcels.to_crs(parcels.crs)\n# Display results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} retail parcels meeting all criteria\")\nprint(f\"Parcel IDs (prioritized by foot traffic): {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find retail parcels with high foot traffic OR in entertainment districts AND NOT within 200m of direct competitors"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\npoi     = gpd.read_file('cambridge_poi_processed.geojson').to_crs(epsg=26986)\n\n# Retail use codes\nretail_codes = ['323','324','325','326','327','330']\nretail = parcels[parcels['use_code'].isin(retail_codes)].copy()\n\n# Compute foot traffic: count all POI within 200m of each parcel centroid\ndef foot_traffic(geom):\n    buf = geom.buffer(200)\n    return sum(1 for pt in poi.geometry if buf.contains(pt))\nretail['ft_count'] = retail.geometry.centroid.apply(foot_traffic)\n\n# High foot traffic threshold (e.g., \u226515 POI within 200m)\nhigh_traffic = retail[retail['ft_count'] >= 15]\n\n# Entertainment districts: buffer around theaters, cinemas, concert halls\nent_types = poi[poi['business_type'].str.contains('Theatre|Cinema|Concert|Arena|Stadium', case=False, na=False)]\nent_buf = ent_types.geometry.buffer(300).union_all()\nentertainment = retail[retail.geometry.intersects(ent_buf)]\n\n# Union of parcels satisfying either condition\ncandidates = gpd.GeoDataFrame(pd.concat([high_traffic, entertainment], ignore_index=True)).drop_duplicates(subset='ml')\n\n# Exclude parcels with any direct retail competitor within 200m\ncompetitors = poi[poi['business_type'].str.contains('Store|Shop|Mall|Supermarket', case=False, na=False)]\ncomp_geoms = competitors.geometry.tolist()\n\ndef has_no_comp(geom):\n    buf = geom.buffer(200)\n    return not any(buf.intersects(pt) for pt in comp_geoms)\n\nfinal = candidates[candidates.geometry.apply(has_no_comp)]\n\n# Output result IDs\nresult_ids = sorted(final['ml'].tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find mixed-use parcels that include residential units, preferably in neighborhoods with a strong sense of community."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n# Define mixed-use codes that include residential units\nmixed_use_codes = ['323', '324', '325', '326', '327', '330', '332', '334', '340', '341', '343', '345', '346', '353']\n# Filter for mixed-use parcels\nmixed_use_parcels = parcels[parcels['use_code'].astype(str).isin(mixed_use_codes)].copy()\n# Set CRS for accurate distance measurement\nmixed_use_parcels = mixed_use_parcels.to_crs(epsg=26986)\n# Define community-oriented business types\ncommunity_business_types = ['restaurant', 'cafe', 'grocery', 'bakery', 'pharmacy', 'retail']\n# Filter POI for community-oriented businesses\ncommunity_poi = poi[poi['business_type'].isin(community_business_types)].copy()\n# Function to calculate community score\ndef calculate_community_score(parcel_geom, poi_geoms, buffer_distance=200):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    # Count community POI within buffer\n    count = sum(1 for geom in poi_geoms if geom is not None and buffered_geom.contains(geom))\n    return count\n# Get POI geometries\ncommunity_poi_geoms = community_poi['geometry'].tolist()\n# Calculate community score for each parcel\nmixed_use_parcels['community_score'] = mixed_use_parcels.geometry.apply(\n    lambda geom: calculate_community_score(geom, community_poi_geoms)\n)\n# Sort by community score (higher is better)\nresult_parcels = mixed_use_parcels.sort_values('community_score', ascending=False)\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Get parcel IDs\nresult_ids = result_parcels['ml'].tolist()\n# Print results\nprint(f\"Found {len(result_parcels)} mixed-use parcels with residential units\")\nprint(f\"Parcel IDs (sorted by community score): {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find commercial parcels larger than 3000 square feet within 500m of harvard square"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n# Define Harvard Square location\nharvard_square_point = Point(-71.1189, 42.3736)\nharvard_square = gpd.GeoDataFrame(geometry=[harvard_square_point], crs=parcels.crs)\n\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\nharvard_square_proj = harvard_square.to_crs(epsg=26986)\n\n# Filter for commercial parcels larger than 3000 sq ft\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\nlarge_commercial_parcels = parcels_proj[\n    (parcels_proj['use_code'].astype(str).isin(commercial_use_codes)) & \n    (parcels_proj['land_area'] > 3000) \n].copy()\n\n# Create 500m buffer around Harvard Square\nharvard_buffer = harvard_square_proj.geometry[0].buffer(500)\n\n# Filter large parcels by proximity to Harvard Square\nresult_parcels = large_commercial_parcels[large_commercial_parcels.geometry.intersects(harvard_buffer)].copy()\n\n# Sort by ml (parcel ID)\nresult_parcels = result_parcels.sort_values('ml')\n\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels larger than 3000 sqft within 500m of Harvard Square\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels that are at least 500 meters away from any restaurant."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\n\n\n# Define restaurant types\nrestaurant_keywords = ['restaurant', 'cafe', 'fast_food', 'diner', 'pizzeria', 'bakery']\n\n\n# Project CRS\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n\n\n# Filter for restaurant POIs\nrestaurants = poi_proj[poi_proj['business_type'].str.lower().isin(restaurant_keywords)]\n\n\n# Buffer restaurants and find parcels NOT intersecting\nrestaurant_buffer = restaurants.buffer(500).union_all()\nparcels_far = parcels_proj[~parcels_proj.geometry.intersects(restaurant_buffer)]\n\n\n# Output\nresult_ids = parcels_far.sort_values('ml')['ml'].tolist()\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find commercial parcels zoned for retail use with fewer than 3 competing retail businesses within 300 meters."}, {"role": "assistant", "content": "import geopandas as gpd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\n\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n\n# Filter retail businesses from POI data\nretail_business_types = ['restaurant', 'clothing_store', 'department_store', 'grocery_store', \n                         'convenience_store', 'furniture_store', 'hardware_store', 'electronics_store']\nretail_businesses = poi_proj[poi_proj['business_type'].isin(retail_business_types)].copy()\n\n# Function to count nearby retail businesses\ndef count_nearby_retail(parcel_geom, retail_geoms, buffer_distance=300):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    count = sum(1 for geom in retail_geoms if geom is not None and buffered_geom.contains(geom))\n    return count\n\n# Get retail business geometries\nretail_geoms = retail_businesses['geometry'].tolist()\n\n# Calculate retail count for each retail parcel\nretail_parcels.loc[:, 'nearby_retail'] = retail_parcels.geometry.apply(\n    lambda geom: count_nearby_retail(geom, retail_geoms)\n)\n\n# Filter for parcels with fewer than 3 competing retail businesses\nresult_parcels = retail_parcels[retail_parcels['nearby_retail'] < 3].copy()\n\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n\n# Sort by parcel ID for consistency\nresult_parcels = result_parcels.sort_values('ml')\n\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} retail parcels with <3 competing retail businesses within 300m\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels with high foot traffic business types AND within 400 meters of mit"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('cambridge_spend_processed.csv')\n# Define MIT location\nmit_location = (-71.09416, 42.3601)\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\n# Define high foot traffic business types\nhigh_foot_traffic_types = [\n    'restaurant', 'cafe', 'fast_food', 'clothing_store', 'department_store',\n    'grocery_store', 'convenience_store', 'shoe_store', 'bar', 'pub'\n]\n# Filter POI for high foot traffic business types\npoi_filtered = poi[poi['business_type'].isin(high_foot_traffic_types)].copy()\n# Project filtered POI to the same CRS\npoi_filtered_proj = poi_filtered.to_crs(epsg=26986)\n# Filter parcels that are within 400m of MIT\nmit_geom = gpd.GeoSeries([gpd.points_from_xy([mit_location[0]], [mit_location[1]])[0]], crs=parcels.crs)\nmit_geom_proj = mit_geom.to_crs(epsg=26986)\n# Create 400m buffer around MIT\nmit_buffer = mit_geom_proj.buffer(400)[0]\n# Filter for high foot traffic business type POI within 400m of MIT\n# Use spatial join to find which POI are within 400m of MIT\npoi_near_mit = poi_filtered_proj[poi_filtered_proj.geometry.intersects(mit_buffer)].copy()\n# Get parcel IDs for these POI\n# Use spatial join to find which parcels contain these POI\npoi_parcels = gpd.sjoin(poi_near_mit, parcels_proj, how='inner', predicate='within')\n# Sort by parcel ID\nresult_ids = poi_parcels['ml'].sort_values().tolist()\n# Convert back to original CRS\nparcels_proj = parcels_proj.to_crs(parcels.crs)\n# Print results\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find parcels that are either zoned for commercial use or within 200 meters of a restaurant, and have at least 20000 square feet of land area."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\nfrom shapely.ops import unary_union\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\n\n# Project to a metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n\n# CONSTRAINT 1: Filter for parcels larger than 20000 sq ft\nlarge_parcels = parcels_proj[parcels_proj['land_area'] > 20000]\n\n# CONDITION 1: Commercial parcels\ncommercial_parcels = large_parcels[large_parcels['use_code'].astype(str).isin(commercial_use_codes)]\n\n# CONDITION 2: Parcels within 200m of a restaurant\n# Filter POI for restaurants\nrestaurants = poi_proj[poi_proj['business_type'] == 'restaurant']\n\n# Create 200m buffer around restaurants\nrestaurant_buffers = [geom.buffer(200) for geom in restaurants.geometry]\nrestaurant_union_buffer = unary_union(restaurant_buffers)\n\n# Find parcels within 200m of restaurants\nparcels_near_restaurants = large_parcels[large_parcels.geometry.intersects(restaurant_union_buffer)]\n\n# Combine both sets of parcels (OR condition)\ncombined_parcels = pd.concat([commercial_parcels, parcels_near_restaurants]).drop_duplicates('ml')\n\n# Convert back to original CRS\nresult_parcels = combined_parcels.to_crs(parcels.crs)\n\n# Sort by parcel ID for consistency\nresult_parcels = result_parcels.sort_values('ml')\n\n# Display results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels within 400 meters of cambridge city hall AND at least 250 meters from any industrial area"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n\n# Project to metric CRS\ncambridge_crs = 26986\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n\n\n# City Hall location\ncity_hall_location = (-71.0825, 42.3736)\ncity_hall_geom = gpd.GeoSeries(gpd.points_from_xy([city_hall_location[0]], [city_hall_location[1]]), crs=parcels.crs)\ncity_hall_geom_proj = city_hall_geom.to_crs(cambridge_crs)\n\n\n# Industrial parcels\nindustrial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', '330', '332',\n    '334', '340', '341', '343', '345', '346', '353', '362', '375'\n]\nindustrial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(industrial_use_codes)].copy()\n\n\n# Condition 1: Near City Hall\ncity_hall_buffer = city_hall_geom_proj.buffer(1000).iloc[0]\nnear_city_hall_parcels = parcels_proj[parcels_proj.geometry.intersects(city_hall_buffer)].copy()\n\n\n# Condition 2: Far from industrial\nindustrial_buffers = [geom.buffer(150) for geom in industrial_parcels.geometry]\ncombined_industrial_buffer = gpd.GeoSeries(industrial_buffers).union_all()\nfar_from_industrial_parcels = near_city_hall_parcels[~near_city_hall_parcels.geometry.intersects(combined_industrial_buffer)].copy()\n\n\n# Final output\nfinal_parcels = far_from_industrial_parcels.to_crs(parcels.crs).sort_values('ml')\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find mixed-use parcels within 450 meters of a grocery store and within 350 meters of at least 2 coffee shops."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.ops import unary_union\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\npoi     = gpd.read_file('cambridge_poi_processed.geojson').to_crs(epsg=26986)\n\n# Mixed-use codes and filter\nmixed_codes = ['0101','0104','0105','0111','0112','0121','013','031','0340','0406','041','0942']\nmixed = parcels[parcels['use_code'].astype(str).isin(mixed_codes)].copy()\n\n# Buffer grocery stores by 450m\ngrocery = poi[poi['business_type']=='grocery_stores']\nbuf_groc = unary_union(grocery.geometry.buffer(450))\nmixed_groc = mixed[mixed.geometry.intersects(buf_groc)].copy()\n\n# Buffer each parcel by 350m for coffee shops\nbuffers = mixed_groc[['ml','geometry']].copy()\nbuffers['geometry'] = buffers.geometry.buffer(350)\n\n# Spatial join to count coffee shops\ncoffee = poi[poi['SUB_CATEGORY']=='Snack and Nonalcoholic Beverage Bars']\njoined = gpd.sjoin(buffers, coffee, how='left', predicate='intersects', lsuffix='buf', rsuffix='coffee')\ncounts = joined.groupby('ml').size().reset_index(name='coffee_count')\n\n# Merge counts back and filter \u22652\nmixed_groc = mixed_groc.merge(counts, on='ml', how='left').fillna({'coffee_count': 0})\nresult = mixed_groc[mixed_groc['coffee_count'] >= 2]\n\n# Output parcel IDs\nresult_ids = sorted(result['ml'].tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels where, if zoned for commercial use, then land area must be greater than 9000 sq ft and smaller than 10000, otherwise land area must be between 6000 and 6500 sq ft"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\n\n\n# Load parcel data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n\n\n# Define projected CRS for Cambridge\ncambridge_crs = 26986\nparcels_proj = parcels.to_crs(cambridge_crs)\n\n\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327',\n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n\n\n# Identify commercial parcels\nparcels_proj['is_commercial'] = parcels_proj['use_code'].astype(str).isin(commercial_use_codes)\n\n\n# Apply conditional filtering\ncondition = (\n    (parcels_proj['is_commercial'] & (parcels_proj['land_area'] > 9000)& (parcels_proj['land_area'] <= 10000)) |\n    (~parcels_proj['is_commercial'] & (parcels_proj['land_area'] >= 6000) & (parcels_proj['land_area'] <= 6500))\n)\nresult_parcels = parcels_proj[condition].copy()\n\n\n# Sort and convert back to original CRS\nresult_parcels = result_parcels.sort_values('ml').to_crs(parcels.crs)\n\n\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_ids)} parcels matching criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: locate retail parcels that are in areas with a balanced mix of residential and commercial uses, defined as having at least 30% of nearby businesses being restaurants or cafes"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\nimport numpy as np\n\n\n# Query: locate retail parcels that are in areas with a balanced mix of residential and commercial uses, \n# defined as having at least 30% of nearby businesses being restaurants or cafes.\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n\n# Define retail use codes consistently\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n\n\n# Filter for retail parcels\nretail_parcels = parcels[parcels['use_code'].astype(str).isin(retail_use_codes)].copy()\n\n\n# Set CRS for accurate distance measurement\nretail_parcels = retail_parcels.to_crs(epsg=26986)\npoi = poi.to_crs(epsg=26986)\n\n\n# Define restaurant/cafe POI codes\nrestaurant_cafe_types = ['restaurant', 'cafe', 'fast_food']\n\n\n# Function to calculate restaurant ratio\ndef calculate_restaurant_ratio(parcel_geom, poi_data, buffer_distance=100):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    \n    # Filter POI within buffer\n    nearby_poi = poi_data[poi_data.geometry.apply(lambda x: buffered_geom.contains(x))]\n    \n    if len(nearby_poi) == 0:\n        return 0.0\n    \n    # Count restaurants/cafes\n    restaurant_count = sum(1 for _, row in nearby_poi.iterrows() \n                         if row['business_type'] in restaurant_cafe_types)\n    \n    # Calculate ratio\n    return restaurant_count / len(nearby_poi) if len(nearby_poi) > 0 else 0.0\n\n\n# Calculate restaurant ratio for each retail parcel\nretail_parcels['restaurant_ratio'] = retail_parcels.apply(\n    lambda row: calculate_restaurant_ratio(row.geometry, poi),\n    axis=1\n)\n\n\n# Filter for parcels with at least 30% restaurant ratio\nbalanced_parcels = retail_parcels[retail_parcels['restaurant_ratio'] >= 0.3].copy()\n\n\n# Sort by parcel ID\nbalanced_parcels = balanced_parcels.sort_values('ml')\n\n\n# Output results\nresult_ids = balanced_parcels['ml'].tolist()\nprint(f\"Found {len(balanced_parcels)} retail parcels in areas with balanced mix\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find the top 20 parcels in Cambridge with the most diverse mix of residential and commercial land uses within 500 meters."}, {"role": "assistant", "content": "import geopandas as gpd\nimport numpy as np\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n\n# Project to a metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n\ndef calculate_land_use_diversity(parcel_geom, all_parcels, buffer_distance=500):\n    # Buffer the parcel\n    buffered = parcel_geom.buffer(buffer_distance)\n    # Select nearby parcels and make an explicit copy to avoid SettingWithCopyWarning\n    nearby = all_parcels[all_parcels.geometry.intersects(buffered)].copy()\n\n    # Categorize each parcel's use_code\n    def categorize_use_code(code):\n        code_str = str(code)\n        \n        # Residential codes\n        if code_str in ['101', '1014', '102', '1028', '104', '105', '109', '1094', '1095', \n                        '1098', '111', '112', '113', '114', '121', '970', '9700', '9421']:\n            return 'Residential'\n        \n        # Commercial codes\n        elif code_str in ['300', '302', '316', '323', '324', '325', '326', '327', '330', '332', \n                          '334', '340', '341', '343', '345', '346', '353', '362', '375', '404', '406']:\n            return 'Commercial'\n        \n        # Mixed use codes\n        elif code_str in ['0101', '0104', '0105', '0111', '0112', '0121', '013', '031', '0340', \n                          '0406', '041', '0942']:\n            return 'Mixed Use'\n        \n        # Industrial codes\n        elif code_str in ['400', '401', '407', '413']:\n            return 'Industrial'\n        \n        # Education codes\n        elif code_str in ['140', '934', '940', '9403', '941', '9410', '9413', '942', '9420', '943', '956']:\n            return 'Education'\n        \n        # Vacant codes\n        elif code_str in ['1062', '130', '131', '132', '1322', '390', '391', '392', '3922', '440', \n                          '442', '933', '936', '946']:\n            return 'Vacant'\n            \n        # Other categories\n        else:\n            return 'Other'\n\n    nearby.loc[:, 'general_category'] = nearby['use_code'].apply(categorize_use_code)\n    counts = nearby['general_category'].value_counts().to_dict()\n\n    # Shannon diversity index\n    total = sum(counts.values())\n    if total == 0:\n        return 0.0\n    proportions = [c/total for c in counts.values()]\n    shannon = -sum(p * np.log(p) for p in proportions if p > 0)\n\n    # Raw count of distinct categories\n    type_count = len(counts)\n\n    # Residential-commercial mix score\n    res = counts.get('Residential', 0)\n    com = counts.get('Commercial', 0)\n    mix_score = 0.0\n    if res and com:\n        ratio = res / com\n        mix_score = 1 / (1 + abs(np.log(ratio)))\n\n    # Composite diversity score\n    return 0.4 * shannon + 0.3 * (type_count / 5) + 0.3 * mix_score\n\n# To limit runtime, sample roughly 1,000 parcels evenly\nstep = max(1, len(parcels_proj) // 1000)\nparcels_to_evaluate = parcels_proj.iloc[::step].copy()\n\n# Compute diversity score\nparcels_to_evaluate.loc[:, 'diversity_score'] = (\n    parcels_to_evaluate.geometry\n        .apply(lambda g: calculate_land_use_diversity(g, parcels_proj))\n)\n\n# Select top 20 and revert to original CRS\ntop20 = (\n    parcels_to_evaluate\n      .nlargest(20, 'diversity_score')\n      .to_crs(parcels.crs)\n)\n\n# Output results\nresult_ids = top20['ml'].tolist()\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels with office space that have no more than 2 competing office businesses within 400m"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n\n\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n\n\n# Filter for office parcels (ml codes for office)\noffice_ml_codes = ['340', '343', '345', '346', '0346', '404', '406', '0340', '0406']\noffice_parcels = parcels_proj[parcels_proj['ml'].astype(str).str.startswith(('34', '40'))]\n\n\n# Filter POI for office businesses\noffice_business_types = ['341', '342', '345', '346', '404', '406']\noffice_poi = poi_proj[poi_proj['business_type'].astype(str).isin(office_business_types)]\n\n\n# Function to count nearby office businesses\ndef count_nearby_offices(parcel_geom, office_poi_geoms, buffer_distance=400):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    count = sum(1 for geom in office_poi_geoms if geom is not None and buffered_geom.contains(geom))\n    return count\n\n\n# Get office POI geometries\noffice_poi_geoms = office_poi['geometry'].tolist()\n\n\n# Calculate office count for each office parcel\noffice_parcels = office_parcels.copy()\noffice_parcels['nearby_offices'] = office_parcels.geometry.apply(\n    lambda geom: count_nearby_offices(geom, office_poi_geoms)\n)\n\n\n# Filter for parcels with no more than 2 nearby offices\nresult_parcels = office_parcels[office_parcels['nearby_offices'] <= 2]\n\n\n# Sort by parcel ID\nresult_parcels = result_parcels.sort_values('ml')\n\n\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n\n\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find parcels within 350 meters of Porter Square that have lower commercial competition than Harvard Square."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\n\n# Project to a metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n\n# Define locations\nporter_square = Point(-71.1226, 42.3782)\nharvard_square = Point(-71.1189, 42.3736)\n\n# Create GeoDataFrames for locations\nporter_gdf = gpd.GeoDataFrame(geometry=[porter_square], crs=parcels.crs)\nharvard_gdf = gpd.GeoDataFrame(geometry=[harvard_square], crs=parcels.crs)\n\n# Project to metric CRS\nporter_gdf_proj = porter_gdf.to_crs(epsg=26986)\nharvard_gdf_proj = harvard_gdf.to_crs(epsg=26986)\n\n# CONSTRAINT 1: Within 350m of Porter Square\nporter_buffer = porter_gdf_proj.buffer(350).iloc[0]\nparcels_near_porter = parcels_proj[parcels_proj.geometry.intersects(porter_buffer)].copy()\n\n# Define commercial business types\ncommercial_types = [\n    'restaurant', 'clothing_store', 'department_store', 'grocery_store', \n    'convenience_store', 'furniture_store', 'hardware_store', 'electronics_store',\n    'coffee_shop', 'retail', 'bank', 'pharmacy'\n]\n\n# Filter POI for commercial businesses\ncommercial_poi = poi_proj[poi_proj['business_type'].isin(commercial_types)]\n\n# Function to count nearby commercial businesses\ndef count_nearby_businesses(point_geom, commercial_geoms, buffer_distance=300):\n    buffered_geom = point_geom.buffer(buffer_distance)\n    count = sum(1 for geom in commercial_geoms if buffered_geom.contains(geom))\n    return count\n\n# Get commercial geometries\ncommercial_geoms = commercial_poi.geometry.tolist()\n\n# Calculate competition around Harvard Square (base comparison)\nharvard_competition = count_nearby_businesses(harvard_gdf_proj.geometry.iloc[0], commercial_geoms)\n\n# Calculate competition around each parcel near Porter\ndef calculate_competition(parcel_geom, commercial_geoms, buffer_distance=300):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    count = sum(1 for geom in commercial_geoms if buffered_geom.contains(geom))\n    return count\n\nparcels_near_porter['competition'] = parcels_near_porter.apply(\n    lambda row: calculate_competition(row.geometry, commercial_geoms),\n    axis=1\n)\n\n# Filter for parcels with less competition than Harvard Square\nlow_competition_parcels = parcels_near_porter[parcels_near_porter['competition'] < harvard_competition]\n\n# Convert back to original CRS\nresult_parcels = low_competition_parcels.to_crs(parcels.crs)\n\n# Sort by parcel ID for consistency\nresult_parcels = result_parcels.sort_values('ml')\n\n# Display results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels near Porter Square with less competition than Harvard Square\")\nprint(f\"Harvard Square competition: {harvard_competition} businesses\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find parcels that are zoned for educational use within 300 meters of at least 3 restaurants and within 500 meters of a subway station."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\nfrom shapely.ops import unary_union\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi     = gpd.read_file('cambridge_poi_processed.geojson')\n\n# Project\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj     = poi.to_crs(epsg=26986)\n\n# Educational use codes\nedu_codes = ['140','934','940','9403','941','9410','9413','942','9420','943','956']\nedu = parcels_proj[parcels_proj['use_code'].astype(str).isin(edu_codes)].copy()\n\n# Subway stations buffer 500m\nstations = [Point(-71.1189,42.3736), Point(-71.1031,42.3656), Point(-71.0865,42.3625), Point(-71.1226,42.3782), Point(-71.1429,42.3954)]\nsubway_buf = unary_union([s.buffer(500) for s in gpd.GeoSeries(stations, crs=parcels.crs).to_crs(epsg=26986).geometry])\nedu1 = edu[edu.geometry.intersects(subway_buf)].copy()\n\n# Count restaurants within 300m\nrest = poi_proj[poi_proj['business_type']=='restaurant']\nrest_geoms = rest.geometry.tolist()\nedu1.loc[:, 'nearby_restaurants'] = edu1.geometry.apply(lambda g: sum(1 for pt in rest_geoms if g.buffer(300).contains(pt)))\nresult = edu1[edu1['nearby_restaurants'] >= 3]\n\n# Print results\nprint(sorted(result['ml'].tolist()))"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: identify retail parcels (use_code for retail) not within 500m of any competitor, larger than 8000 sq ft, and in areas with high percentage of working-age residents (pct_18_64 above 50%)"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi     = gpd.read_file('cambridge_poi_processed.geojson')\ncensus  = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n# Retail use codes\nretail_use_codes = ['323','324','325','326','327','330']\n\n# Project to metric CRS\nparcels = parcels.to_crs(epsg=26986)\npoi     = poi.to_crs(epsg=26986)\ncensus  = census.to_crs(epsg=26986)\n\n# Filter retail parcels >8000 sq ft\nretail = parcels[\n    parcels['use_code'].isin(retail_use_codes) &\n    (parcels['land_area'] > 8000)\n].copy()\n\n# Competitor POIs\ncompetitors = poi[poi['SUB_CATEGORY']== 'Malls']\ncomp_geoms = competitors.geometry.tolist()\n\n# Function to test no competitors within 500m\ndef no_competitors(geom):\n    buf = geom.buffer(500)\n    return not any(buf.intersects(pt) for pt in comp_geoms)\n\n# Apply filter\nfiltered = retail[retail.geometry.apply(no_competitors)].copy()\n\n# Join centroids to census tracts and filter pct_18_64 > 50%\npts = filtered.copy()\npts.geometry = pts.geometry.centroid\njoined = gpd.sjoin(\n    pts, census, how='inner', predicate='within', rsuffix='right'\n)\nhigh_work = joined[joined['pct_18_64'] > 0.5]\n\n# Result IDs\nresult_ids = sorted(high_work['ml'].unique().tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find parcels with at least 10,000 square feet located within 1km of both Harvard Square and Central Square."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n\n# Define square locations\nharvard_square = Point(-71.1189, 42.3736)\ncentral_square = Point(-71.1031, 42.3656)\n\n# Create GeoDataFrames for locations\nharvard_gdf = gpd.GeoDataFrame(geometry=[harvard_square], crs=parcels.crs)\ncentral_gdf = gpd.GeoDataFrame(geometry=[central_square], crs=parcels.crs)\n\n# Project to a metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\nharvard_gdf_proj = harvard_gdf.to_crs(epsg=26986)\ncentral_gdf_proj = central_gdf.to_crs(epsg=26986)\n\n# CONSTRAINT 1: Filter for parcels > 10,000 sq ft\nlarge_parcels = parcels_proj[parcels_proj['land_area'] > 10000]\n\n# CONSTRAINT 2: Within 1km of Harvard Square\nharvard_buffer = harvard_gdf_proj.buffer(1000).iloc[0]\nparcels_near_harvard = large_parcels[large_parcels.geometry.intersects(harvard_buffer)]\n\n# CONSTRAINT 3: Within 1km of Central Square\ncentral_buffer = central_gdf_proj.buffer(1000).iloc[0]\nparcels_near_both = parcels_near_harvard[parcels_near_harvard.geometry.intersects(central_buffer)]\n\n# Convert back to original CRS\nresult_parcels = parcels_near_both.to_crs(parcels.crs)\n\n# Sort by parcel ID for consistency\nresult_parcels = result_parcels.sort_values('ml')\n\n# Display results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels >10,000 sq ft within 1km of both squares\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find residential parcels larger than 10000 square feet within 200 meters of at least 2 educational institutions."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi      = gpd.read_file('cambridge_poi_processed.geojson')\n\n# Project\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj     = poi.to_crs(epsg=26986)\n\n# Residential codes & filter\nres_codes = ['101','1014','102','1028','104','105','109','1094','1095','1098','111','112','113','114','121','970','9700','9421']\nres = parcels_proj[parcels_proj['use_code'].isin(res_codes)].copy()\nres = res[res['land_area'] > 10000].copy()\n\n# Education POIs & count\nedu = poi_proj[poi_proj['TOP_CATEGORY']=='Colleges, Universities, and Professional Schools']\nedu_geoms = edu.geometry.tolist()\n\ndef count_edu(geom):\n    buf = geom.buffer(200)\n    return sum(1 for g in edu_geoms if buf.contains(g))\n\nres.loc[:, 'edu_count'] = res.geometry.apply(count_edu)\nresult = res[res['edu_count'] >= 2]\n\n# Output\nids = sorted(result['ml'].tolist())\nprint(ids)"}]}
