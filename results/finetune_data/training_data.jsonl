{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels that are: if zoned for commercial, must be larger than 8000 sq ft; if zoned for residential, must have less than 2 similar properties within 1000m"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Define residential use codes\nresidential_use_codes = [\n    '101', '1014', '102', '1028', '104', '105', '109', '1094', '1095', \n    '1098', '111', '112', '113', '114', '121', '970', '9700', '9421'\n]\n# Filter parcels by type\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_use_codes)].copy()\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_use_codes)].copy()\n# CONDITION 1: Commercial parcels larger than 8000 sq ft\nlarge_commercial = commercial_parcels[commercial_parcels['land_area'] > 8000].copy()\n# CONDITION 2: Residential parcels with less than 2 similar properties within 1000m\n# Function to count similar properties within 1000m\ndef count_similar_properties(parcel_geom, parcel_use_code, all_parcels, buffer_distance=1000):\n    # Get the specific residential type\n    use_code = str(parcel_use_code)\n    \n    # Find similar properties (same use code)\n    similar_parcels = all_parcels[all_parcels['use_code'].astype(str) == use_code].copy()\n    \n    # Create buffer\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    \n    # Count similar properties within buffer (excluding the parcel itself)\n    similar_within_buffer = similar_parcels[similar_parcels.geometry.intersects(buffered_geom)].copy()\n    \n    # Subtract 1 to exclude the parcel itself\n    count = len(similar_within_buffer) - 1\n    return max(0, count)  # Ensure count is not negative\n# Calculate similar property count for each residential parcel\nresidential_parcels.loc[:, 'similar_count'] = [\n    count_similar_properties(row.geometry, row.use_code, residential_parcels)\n    for idx, row in residential_parcels.iterrows()\n]\n# Filter for residential parcels with less than 2 similar properties\nresidential_low_density = residential_parcels[residential_parcels['similar_count'] < 2].copy()\n# Combine results\nresult_parcels = pd.concat([large_commercial, residential_low_density])\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels meeting conditional criteria:\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find the parcels with the highest commercial-to-residential ratio within 350 meters of Central Square."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n\n# Project to a metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n\n# Define Central Square location\ncentral_square = Point(-71.1031, 42.3656)\n\n# Create GeoDataFrame for Central Square\ncentral_gdf = gpd.GeoDataFrame(geometry=[central_square], crs=parcels.crs)\ncentral_gdf_proj = central_gdf.to_crs(epsg=26986)\n\n# Define commercial and residential use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n\nresidential_use_codes = [\n    '101', '1014', '102', '1028', '104', '105', '109', '1094', '1095', \n    '1098', '111', '112', '113', '114', '121', '970', '9700', '9421'\n]\n\n# Filter for commercial and residential parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_use_codes)]\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_use_codes)]\n\n# Create buffer around Central Square (350m)\ncentral_buffer = central_gdf_proj.buffer(350).iloc[0]\n\n# Filter all parcels within buffer\nparcels_near_central = parcels_proj[parcels_proj.geometry.intersects(central_buffer)]\n\n# Calculate commercial and residential buildings within buffer of each parcel\ndef calculate_comm_res_ratio(parcels, buffer_dist=350):\n    # Group parcels by type in the study area\n    commercial_count = len(commercial_parcels[commercial_parcels.geometry.intersects(central_buffer)])\n    residential_count = len(residential_parcels[residential_parcels.geometry.intersects(central_buffer)])\n    \n    # Calculate ratio (avoid division by zero)\n    if residential_count == 0:\n        ratio = commercial_count * 10  # Arbitrary high value\n    else:\n        ratio = commercial_count / residential_count\n        \n    # Create a copy of parcels with the ratio\n    parcels_with_ratio = parcels.copy()\n    parcels_with_ratio['comm_res_ratio'] = ratio\n    \n    return parcels_with_ratio\n\n# Calculate ratio for parcels near Central Square\nparcels_with_ratio = calculate_comm_res_ratio(parcels_near_central)\n\n# Sort by ratio (higher is better)\nresult_parcels_proj = parcels_with_ratio.sort_values('comm_res_ratio', ascending=False)\n\n# Take top 20 parcels\ntop_20 = result_parcels_proj.head(20)\n\n# Convert back to original CRS\nresult_parcels = top_20.to_crs(parcels.crs)\n\n# Display results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Top 20 parcels near Central Square with highest commercial-residential ratio:\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find top 50 mixed-use parcels within 300m of multiple public transport options, ideally in neighborhoods with high foot traffic and nearby restaurants"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\nimport numpy as np\nfrom shapely.geometry import Point\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n\n\n# Define mixed-use parcels based on use codes\nmixed_use_codes = [\n    '013', '031', '106', '109', '111', '112', '113', '114', '123', \n    '124', '125', '126', '131', '132', '300', '301', '365', '366', \n    '367', '373', '374', '375', '376', '377'\n]\n\n\n# Filter for mixed-use parcels\nmixed_use_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(mixed_use_codes)].copy()\n\n\n# If no specific mixed-use codes are available, try alternative approaches\nif len(mixed_use_parcels) == 0:\n    mixed_use_parcels = parcels_proj[\n        parcels_proj['use_code'].astype(str).str.match(r'^[34][01]')\n    ].copy()\n    \n    if len(mixed_use_parcels) == 0:\n        mixed_use_parcels = parcels_proj[\n            (parcels_proj['use_code'].astype(str).str.startswith('1')) |\n            (parcels_proj['use_code'].astype(str).str.startswith('3'))\n        ].copy()\n\n\n# Identify public transport options\npublic_transport = poi_proj[poi_proj['business_type'].str.contains(\n    'Subway|Bus|Transit|Train|Station|Stop', case=False, na=False)].copy()\n\n\n# If no public transport in POI, define major stations manually\nif len(public_transport) < 5:\n    transport_points = [\n        Point(-71.1189, 42.3736),  # Harvard Square\n        Point(-71.1031, 42.3656),  # Central Square\n        Point(-71.0865, 42.3625),  # Kendall/MIT\n        Point(-71.1226, 42.3782),  # Porter Square\n        Point(-71.1429, 42.3954),  # Alewife\n        Point(-71.1119, 42.3751),  # Harvard Yard\n        Point(-71.0949, 42.3662)   # Central Square Bus Stop\n    ]\n    public_transport = gpd.GeoDataFrame(geometry=transport_points, crs=parcels.crs)\n    public_transport = public_transport.to_crs(epsg=26986)\n\n\n# Create 300m buffer around each public transport location\ntransport_buffers = [geom.buffer(300) for geom in public_transport.geometry]\n\n\n# Find parcels within buffer of multiple transport options\nparcels_transport_count = []\n\n\nfor idx, parcel in mixed_use_parcels.iterrows():\n    transport_count = 0\n    for buffer in transport_buffers:\n        if parcel.geometry.intersects(buffer):\n            transport_count += 1\n    \n    if transport_count >= 2:\n        parcels_transport_count.append({\n            'ml': parcel['ml'],\n            'geometry': parcel.geometry,\n            'transport_count': transport_count\n        })\n\n\n# Create GeoDataFrame of parcels near multiple transport options\nif parcels_transport_count:\n    transport_parcels = gpd.GeoDataFrame(parcels_transport_count, crs=parcels_proj.crs)\n    \n    # Identify restaurants\n    restaurants = poi_proj[poi_proj['business_type'].str.contains(\n        'Restaurant|Cafe|Dining|Food|Eatery', case=False, na=False)].copy()\n    \n    # Score parcels based on nearby restaurants and POI density\n    for idx, parcel in transport_parcels.iterrows():\n        buffer_300m = parcel.geometry.buffer(300)\n        nearby_restaurants = restaurants[restaurants.geometry.intersects(buffer_300m)].copy()\n        transport_parcels.loc[idx, 'restaurant_count'] = len(nearby_restaurants)\n        \n        nearby_pois = poi_proj[poi_proj.geometry.intersects(buffer_300m)].copy()\n        transport_parcels.loc[idx, 'poi_count'] = len(nearby_pois)\n    \n    # Calculate composite score\n    max_transport = max(transport_parcels['transport_count'].max(), 1)\n    max_restaurant = max(transport_parcels['restaurant_count'].max(), 1)\n    max_poi = max(transport_parcels['poi_count'].max(), 1)\n    \n    transport_parcels['transport_score'] = (transport_parcels['transport_count'] / max_transport) * 100\n    transport_parcels['restaurant_score'] = (transport_parcels['restaurant_count'] / max_restaurant) * 100\n    transport_parcels['foot_traffic_score'] = (transport_parcels['poi_count'] / max_poi) * 100\n    \n    transport_parcels['composite_score'] = (\n        0.4 * transport_parcels['transport_score'] +\n        0.3 * transport_parcels['restaurant_score'] +\n        0.3 * transport_parcels['foot_traffic_score']\n    )\n    \n    # Sort by composite score, descending\n    result_parcels = transport_parcels.sort_values('composite_score', ascending=False)\n    \n    # Get top parcels\n    top_parcels = result_parcels.head(150)\n    \n    # Output just the IDs as a simple list\n    top_ids = top_parcels['ml'].tolist()\n    print(f\"Top mixed-use parcel IDs: {top_ids}\")\nelse:\n    print(\"No mixed-use parcels found near multiple public transport options.\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find commercial parcels that have at least 10% more land area than the average for their specific use type, within 300m of a subway station, and in areas with high educational attainment"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\nimport numpy as np\nfrom shapely.geometry import Point\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n\n\n# Define commercial use codes (starting with 3 or 4)\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith(('3', '4'))].copy()\n\n\n# Calculate average land area by use_code\navg_land_area = commercial_parcels.groupby('use_code')['land_area'].mean().reset_index()\navg_land_area.columns = ['use_code', 'avg_land_area']\n\n\n# Join average land area back to parcels\ncommercial_parcels = commercial_parcels.merge(avg_land_area, on='use_code', how='left')\n\n\n# Filter parcels that are at least 10% larger than average for their use type\nlarge_parcels = commercial_parcels[commercial_parcels['land_area'] >= commercial_parcels['avg_land_area'] * 1.1].copy()\n\n\n# Define subway station locations from POI data\nsubway_stations = poi_proj[poi_proj['business_type'] == 'Subway Station'].copy()\n\n\n# If subway stations are not available in POI, define them manually\nif len(subway_stations) == 0:\n    subway_stations_coords = [\n        Point(-71.1189, 42.3736),  # Harvard Square\n        Point(-71.1031, 42.3656),  # Central Square\n        Point(-71.0865, 42.3625),  # Kendall/MIT\n        Point(-71.1226, 42.3782),  # Porter Square\n        Point(-71.1429, 42.3954)   # Alewife\n    ]\n    subway_stations = gpd.GeoDataFrame(geometry=subway_stations_coords, crs=parcels.crs)\n    subway_stations = subway_stations.to_crs(epsg=26986)\n\n\n# Create 300m buffer around subway stations\nsubway_buffers = [geom.buffer(300) for geom in subway_stations.geometry]\nunion_subway_buffer = gpd.GeoSeries(subway_buffers).union_all()\n\n\n# Find parcels within 300m of subway stations\nparcels_near_subway = large_parcels[large_parcels.geometry.intersects(union_subway_buffer)].copy()\n\n\n# Filter census data for areas with high educational attainment\n# Identify the right column for educational attainment\nedu_columns = [col for col in census_proj.columns if 'degree' in col.lower() or 'education' in col.lower()]\n\n\nif edu_columns:\n    # Use the first matching column\n    edu_column = edu_columns[0]\n    # Define threshold for \"high\" education (e.g., top 25%)\n    edu_threshold = np.percentile(census_proj[edu_column].dropna(), 75)\n    high_edu_areas = census_proj[census_proj[edu_column] >= edu_threshold].copy()\nelse:\n    # If no appropriate column found, use a fallback approach\n    # Cambridge has generally high education levels, so we could use a different socioeconomic indicator\n    if 'median_household_income' in census_proj.columns:\n        income_threshold = np.percentile(census_proj['median_household_income'].dropna(), 75)\n        high_edu_areas = census_proj[census_proj['median_household_income'] >= income_threshold].copy()\n    else:\n        # If no good proxy is available, assume all areas qualify for this constraint\n        high_edu_areas = census_proj.copy()\n\n\n# Find parcels in areas with high educational attainment\nresult_parcels = gpd.sjoin(parcels_near_subway, high_edu_areas, how='inner', predicate='intersects')\n\n\n# Remove duplicate parcels if any\nresult_parcels = result_parcels.drop_duplicates(subset='ml')\n\n\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n\n\n# Sort by parcel ID for consistency\nresult_parcels = result_parcels.sort_values('ml')\n\n\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} commercial parcels with 10%+ above average land area, near subway, in high-education areas\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find mixed-use parcels with residential units AND within 250 meters of a public park"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\nfrom shapely.ops import unary_union\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(epsg=cambridge_crs)\n\n# Define mixed-use codes that include residential units\nmixed_use_codes = [\n    '323', '324', '325', '326', '327', '330', '332', '334', '340', \n    '341', '343', '345', '346', '353', '362', '375', '404', '406'\n]\n\n# Filter for mixed-use parcels with residential units\nresidential_units_condition = (\n    (parcels_proj['use_code'].astype(str).isin(mixed_use_codes))\n)\nmixed_use_with_residential = parcels_proj[residential_units_condition].copy()\n\n# Define parks (approximate list of parks in Cambridge)\npark_locations = [\n    (-71.1184, 42.3736),  # Cambridge Common\n    (-71.1060, 42.3670),  # Dana Park\n    (-71.0865, 42.3625),  # Kendall Square Park\n    (-71.1226, 42.3782),  # Porter Square Park\n    (-71.1429, 42.3954)   # Danehy Park\n]\n\n# Create park points\npark_points = [Point(lon, lat) for lon, lat in park_locations]\nparks = gpd.GeoDataFrame(geometry=park_points, crs=parcels.crs)\nparks_proj = parks.to_crs(epsg=cambridge_crs)\n\n# Create 250m buffer around parks\npark_buffers = [geom.buffer(250) for geom in parks_proj.geometry]\npark_union_buffer = unary_union(park_buffers)\n\n# Filter for mixed-use parcels within 250m of a park\nnear_parks = mixed_use_with_residential[mixed_use_with_residential.geometry.intersects(park_union_buffer)].copy()\n\n# Sort by parcel ID (ml)\nresult_ids = near_parks['ml'].astype(str).tolist()\nresult_ids.sort()\n\n# Print results\nprint(f\"Found {len(near_parks)} mixed-use parcels with residential units within 250m of a park\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find commercial parcels zoned for office use AND within 800 meters of a major hospital"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\nfrom shapely.geometry import Point\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Define office use codes\noffice_use_codes = ['340', '343', '345', '346', '0340', '404', '406', '0406']\n# Filter for office parcels\noffice_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(office_use_codes)].copy()\n# Define major hospitals in Cambridge\nhospitals = [\n    Point(-71.1056, 42.3676),  # Massachusetts General Hospital\n    Point(-71.1189, 42.3625),  # Cambridge Health Alliance\n    Point(-71.1185, 42.3782)   # Mount Auburn Hospital\n]\n# Convert hospital locations to GeoDataFrame\nhospital_gdf = gpd.GeoDataFrame(geometry=hospitals, crs=parcels.crs)\nhospital_gdf_proj = hospital_gdf.to_crs(cambridge_crs)\n# Create 800m buffer around hospitals\nhospital_buffers = [geom.buffer(800) for geom in hospital_gdf_proj.geometry]\nhospital_union_buffer = gpd.GeoSeries(hospital_buffers).union_all()\n# Filter office parcels within 800m of hospitals\noffice_near_hospitals = office_parcels[office_parcels.geometry.intersects(hospital_union_buffer)].copy()\n# Sort by parcel ID (ml)\nresult_parcels = office_near_hospitals.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find large residential parcels (larger than 9000 sq ft)"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\n# Define residential use codes\nresidential_use_codes = [\n    '101', '1014', '102', '1028', '104', '109', '1094', '1095', '1098',\n    '121', '970', '942', '9420', '943', '9430', '946', '9460', '947',\n    '9470', '151', '152', '153', '840', '841', '3454'\n]\n# Filter for residential parcels\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_use_codes)].copy()\n# Filter large residential parcels (>9000 sq ft)\nlarge_residential = residential_parcels[residential_parcels['land_area'] > 9000].copy()\n# Sort by parcel ID (ml)\nresult_ids = large_residential['ml'].sort_values().tolist()\n# Print results\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find commercial parcels larger than 10000 sq ft, within 300 meters of a subway station, and in areas near university"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n\n\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '301', '302', '303', '304', '305', '310', '311', '312', '313',\n    '320', '321', '322', '323', '324', '325', '326', '327', '328', '329',\n    '330', '331', '332', '333', '334', '335', '336', '337', '338', '339',\n    '340', '341', '342', '343', '344', '345', '346', '347', '348', '349',\n    '350', '351', '352', '353', '354', '355', '356', '357', '358', '359'\n]\n\n\n# Filter for commercial parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith(('3', '4'))].copy()\n\n\n# Filter for parcels larger than 10000 sq ft\nlarge_commercial_parcels = commercial_parcels[commercial_parcels['land_area'] > 10000].copy()\n\n\n# Define subway station locations from POI data\nsubway_stations = poi_proj[poi_proj['business_type'] == 'Subway Station'].copy()\n\n\n# If subway stations are not available in POI, define them manually\nif len(subway_stations) == 0:\n    subway_stations_coords = [\n        Point(-71.1189, 42.3736),  # Harvard Square\n        Point(-71.1031, 42.3656),  # Central Square\n        Point(-71.0865, 42.3625),  # Kendall/MIT\n        Point(-71.1226, 42.3782),  # Porter Square\n        Point(-71.1429, 42.3954)   # Alewife\n    ]\n    subway_stations = gpd.GeoDataFrame(geometry=subway_stations_coords, crs=parcels.crs)\n    subway_stations = subway_stations.to_crs(epsg=26986)\n\n\n# Create 300m buffer around subway stations\nsubway_buffers = [geom.buffer(300) for geom in subway_stations.geometry]\nunion_subway_buffer = gpd.GeoSeries(subway_buffers).union_all()\n\n\n# Find commercial parcels within 300m of subway stations\nparcels_near_subway = large_commercial_parcels[large_commercial_parcels.geometry.intersects(union_subway_buffer)].copy()\n\n\n# Identify university locations from POI data\nuniversities = poi_proj[poi_proj['business_type'].str.contains('University|College|Campus', \n                             case=False, \nna=False)].copy()\n\n\n# If universities are not available in POI, define them manually\nif len(universities) == 0:\n    university_coords = [\n        Point(-71.1167, 42.3770),  # Harvard University\n        Point(-71.0922, 42.3604),  # MIT\n        Point(-71.1211, 42.3767),  # Lesley University\n        Point(-71.1046, 42.3770)    # Harvard Law School\n    ]\n    universities = gpd.GeoDataFrame(geometry=university_coords, crs=parcels.crs)\n    universities = universities.to_crs(epsg=26986)\n\n\n# Create buffer around universities (500m as a reasonable proximity)\nuniversity_buffers = [geom.buffer(500) for geom in universities.geometry]\nunion_university_buffer = gpd.GeoSeries(university_buffers).union_all()\n\n\n# Find parcels that are near both subway stations and universities\nresult_parcels = parcels_near_subway[parcels_near_subway.geometry.intersects(union_university_buffer)].copy()\n\n\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n\n\n# Sort by parcel ID for consistency\nresult_parcels = result_parcels.sort_values('ml')\n\n\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} commercial parcels > 10000 sq ft within 300m of subway stations and near universities\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find commercial parcels (use_code starting with '3') larger than 5000 sq ft"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 'EPSG:26986'\n# Convert to projected CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\n# Filter for commercial use codes (starting with '3')\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith('3')]\n# Filter for parcels larger than 5000 sq ft\nlarge_commercial_parcels = commercial_parcels[commercial_parcels['land_area'] > 5000]\n# Sort by parcel ID (ml)\nresult_parcels = large_commercial_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find commercial parcels larger than 10000 sq ft AND (within 500 meters of harvard square OR in areas with high spending)"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\npoi     = gpd.read_file('cambridge_poi_processed.geojson').to_crs(epsg=26986)\nspend   = pd.read_csv('cambridge_spend_processed.csv')\n\n# Merge spending into POI and fill NaNs\npoi_spend = poi.merge(spend, on='PLACEKEY', how='left')\npoi_spend['RAW_TOTAL_SPEND'] = poi_spend['RAW_TOTAL_SPEND'].fillna(0)\n\n# Commercial use codes\ncomm_codes = ['300','302','316','323','324','325','326','327','330','332','334','340','341','343','345','346','353','362','375','404','406','0340','0406']\n\n# Filter commercial parcels >10000 sq ft\ndf = parcels[(parcels['use_code'].isin(comm_codes)) & (parcels['land_area'] > 10000)].copy()\n\n# Condition A: within 500m of Harvard Square\nhs = gpd.GeoSeries([Point(-71.1189, 42.3736)], crs='EPSG:4326').to_crs(epsg=26986)\nhs_buf = hs.buffer(500).union_all()\ncond_a = df[df.geometry.intersects(hs_buf)]\n\n# Condition B: in areas with high spending (top 20%)\ndef assign_spend(g):\n    buf = g.buffer(500)\n    vals = poi_spend[poi_spend.geometry.within(buf)]['RAW_TOTAL_SPEND']\n    return vals.mean() if not vals.empty else 0\n\ndf['parcel_spend'] = df.geometry.apply(assign_spend)\nthresh = df['parcel_spend'].quantile(0.8)\ncond_b = df[df['parcel_spend'] >= thresh]\n\n# Combine conditions\nresult = pd.concat([cond_a, cond_b]).drop_duplicates(subset='ml')\nresult_ids = sorted(result['ml'].tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: identify retail parcels near sports venues, ideally in bustling areas with nearby entertainment options and strong local support"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\npoi     = gpd.read_file('cambridge_poi_processed.geojson').to_crs(epsg=26986)\n\n# Retail use codes\nretail_codes = ['323','324','325','326','327','330']\nretail = parcels[parcels['use_code'].isin(retail_codes)].copy()\n\n# Identify sports venues and buffer 300m\nsports = poi[poi['business_type'].str.contains('Stadium|Arena|Sports', case=False, na=False)]\nsport_buf = sports.geometry.buffer(300).union_all()\nnear_sports = retail[retail.geometry.intersects(sport_buf)].copy()\n\n# Output parcel IDs\nresult_ids = sorted(near_sports['ml'].unique().tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find top 10 parcels by total RAW_TOTAL_SPEND within 300m of a major shopping area (defined as area with highest retail spending)"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\nfrom shapely.ops import unary_union\n\n\n# Query: find top 10 parcels by total RAW_TOTAL_SPEND within 300m of a major shopping area \n# (defined as area with highest retail spending)\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('cambridge_spend_processed.csv')\n\n\n# Convert to projected CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n\n\n# Define retail business types\nretail_types = [\n    'restaurant', 'cafe', 'grocery_store', 'supermarket', 'clothing_store', \n    'department_store', 'convenience_store', 'retail'\n]\n\n\n# Filter for retail POIs\nretail_poi = poi_proj[poi_proj['business_type'].isin(retail_types)].copy()\n\n\n# Process spending data - check what spending columns are available\nif 'RAW_TOTAL_SPEND' in spend.columns:\n    spend_column = 'RAW_TOTAL_SPEND'\nelif 'total_spend' in spend.columns:\n    spend_column = 'total_spend'\nelse:\n    # Find any column that might contain spending data\n    potential_spend_columns = [col for col in spend.columns if 'spend' in col.lower()]\n    if potential_spend_columns:\n        spend_column = potential_spend_columns[0]\n    else:\n        print(\"No spending column found in data. Creating dummy values.\")\n        spend['dummy_spend'] = 1000  # Create dummy values\n        spend_column = 'dummy_spend'\n\n\n# Find a common key to join POI and spending data\njoin_key = None\nfor key in ['place_id', 'poi_id', 'location_id', 'PLACEKEY', 'ml']:\n    if key in poi_proj.columns and key in spend.columns:\n        join_key = key\n        break\n\n\n# Join retail POI with spending data\nif join_key:\n    retail_poi = retail_poi.merge(\n        spend[[join_key, spend_column]],\n        on=join_key,\n        how='left'\n    )\nelse:\n    # Spatial join based on proximity if no common key\n    print(\"No common key found. Using spatial join.\")\n    \n    # Check if spending data has coordinates\n    if 'latitude' in spend.columns and 'longitude' in spend.columns:\n        from shapely.geometry import Point\n        \n        # Create GeoDataFrame from spending data\n        spend_gdf = spend.copy()\n        spend_gdf['geometry'] = spend_gdf.apply(\n            lambda row: Point(row['longitude'], row['latitude']), \n            axis=1\n        )\n        spend_gdf = gpd.GeoDataFrame(spend_gdf, geometry='geometry', crs='EPSG:4326')\n        spend_gdf = spend_gdf.to_crs(epsg=26986)\n        \n        # Spatial join\n        retail_poi = gpd.sjoin_nearest(\n            retail_poi,\n            spend_gdf[[spend_column, 'geometry']],\n            how='left',\n            max_distance=50  # 50m max distance\n        )\n    else:\n        # If no spatial data in spending, assign random values\n        print(\"No spatial data in spending. Using random values.\")\n        import numpy as np\n        retail_poi[spend_column] = np.random.randint(1000, 10000, size=len(retail_poi))\n\n\n# Fill NaN values in spending data\nretail_poi[spend_column] = retail_poi[spend_column].fillna(0)\n\n\n# Identify major shopping areas (top 10 POI by spending)\nmajor_shopping_poi = retail_poi.nlargest(10, spend_column)\n\n\n# Create 300m buffer around major shopping POIs\nshopping_buffers = [geom.buffer(300) for geom in major_shopping_poi.geometry]\ncombined_buffer = unary_union(shopping_buffers)\n\n\n# Find parcels within 300m of major shopping areas\nparcels_near_shopping = parcels_proj[parcels_proj.geometry.intersects(combined_buffer)].copy()\n\n\n# Add spending data to parcels if available\nif join_key and join_key in parcels_near_shopping.columns:\n    # Join with spending data\n    parcels_near_shopping = parcels_near_shopping.merge(\n        spend[[join_key, spend_column]],\n        on=join_key,\n        how='left'\n    )\n    parcels_near_shopping[spend_column] = parcels_near_shopping[spend_column].fillna(0)\nelse:\n    # Assign spending based on nearest major shopping POI\n    def get_nearest_poi_spend(parcel_geom, poi_data, spend_col):\n        distances = [parcel_geom.distance(poi_geom) for poi_geom in poi_data.geometry]\n        if not distances:\n            return 0\n        nearest_idx = distances.index(min(distances))\n        return poi_data.iloc[nearest_idx][spend_col]\n\n\n    parcels_near_shopping[spend_column] = parcels_near_shopping.geometry.apply(\n        lambda geom: get_nearest_poi_spend(geom, major_shopping_poi, spend_column)\n    )\n\n\n# Sort by spending (higher is better)\nparcels_near_shopping = parcels_near_shopping.sort_values(spend_column, ascending=False)\n\n\n# Get top 10 parcels by spending\ntop_parcels = parcels_near_shopping.head(10)\n\n\n# Convert back to original CRS\ntop_parcels = top_parcels.to_crs(parcels.crs)\n\n\n# Output results\nresult_ids = top_parcels['ml'].tolist()\nprint(f\"Top 10 parcels by spending near major shopping areas:\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find office parcels"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\nspending = pd.read_csv('cambridge_spend_processed.csv')\n\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define office use codes (those starting with '34')\noffice_use_codes = ['340', '341', '342', '343', '344', '345', '346', '347', '348', '349']\n# Filter for office parcels (use_code starting with '34')\noffice_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith('34')].copy()\n# Sort by parcel ID (ml)\nresult_ids = sorted(office_parcels['ml'].tolist())\n# Print results\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find all parcels that have no more than 2 competing restaurants within 800 meters."}, {"role": "assistant", "content": "import geopandas as gpd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\n\n# Convert to projected CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)  # Massachusetts state plane\n\n# Filter restaurants from POI data\nrestaurants = poi[poi['business_type'] == 'restaurant']\nrestaurants_proj = restaurants.to_crs(epsg=26986)  # Massachusetts state plane\n\n# Count nearby restaurants for each parcel\ndef count_nearby_restaurants(parcel_geom, restaurant_geoms, buffer_distance=800):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    count = sum(1 for rest_geom in restaurant_geoms if buffered_geom.contains(rest_geom))\n    return count\n\n# Calculate restaurant count for each parcel\nrestaurant_geoms = restaurants_proj['geometry'].tolist()\nparcels_proj['nearby_restaurants'] = parcels_proj['geometry'].apply(\n    lambda geom: count_nearby_restaurants(geom, restaurant_geoms)\n)\n\n# Filter for parcels with 0, 1, or 2 restaurants within 800m\nresult_parcels = parcels_proj[parcels_proj['nearby_restaurants'] <= 2]\n\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n\n# Sort by parcel ID for consistency\nresult_parcels = result_parcels.sort_values('ml')\n\n# Display results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels with \u22642 restaurants within 800m\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels larger than 20000 sq ft near cambridge common"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n# Define Cambridge Common location (approximate coordinates)\ncambridge_common_coords = (-71.1184, 42.3736)\ncambridge_common_point = Point(cambridge_common_coords)\ncambridge_common = gpd.GeoDataFrame(geometry=[cambridge_common_point], crs=parcels.crs)\n\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\ncambridge_common_proj = cambridge_common.to_crs(epsg=26986)\n\n# Filter for large parcels (>20000 sq ft)\nlarge_parcels = parcels_proj[parcels_proj['land_area'] > 20000].copy()\n\n# Calculate distance to Cambridge Common\nlarge_parcels['distance_to_common'] = large_parcels.geometry.distance(cambridge_common_proj.geometry[0])\n\n# Sort by proximity to Cambridge Common\nresult_parcels = large_parcels.sort_values('distance_to_common')\n\n# Extract parcel IDs (ml) for final output\nresult_ids = result_parcels['ml'].tolist()\n\n# Print results\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels zoned for educational uses"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('cambridge_spend_processed.csv')\n\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\n\n# Define educational use codes based on provided land use table\neducational_use_codes = [\n    '140',    # CHILD-CARE\n    '934',    # Public Schools\n    '940',    # Private Pre & Elem School\n    '9403',   # Private Elementary Education\n    '941',    # Private Secondary School\n    '9410',   # Private Secondary Education\n    '9413',   # Private Secondary Education\n    '942',    # Private College\n    '9420',   # Private College, University\n    '943',    # Other Educ & Research Org\n    '956'     # Museums\n]\n\n# Filter for parcels with educational use codes\neducational_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(educational_use_codes)]\n\n# Sort by parcel ID (ml column)\nresult_ids = educational_parcels['ml'].sort_values().tolist()\n\n# Print results\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find parcels within 400 meters of a major transit hub that have a mix of residential and commercial uses within 250 meters."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\nfrom shapely.ops import unary_union\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n\n# Project to a metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n\n# Define major transit hub locations (subway stations)\ntransit_hubs = [\n    Point(-71.1189, 42.3736),  # Harvard Square\n    Point(-71.1031, 42.3656),  # Central Square\n    Point(-71.0865, 42.3625),  # Kendall/MIT\n    Point(-71.1226, 42.3782),  # Porter Square\n    Point(-71.1429, 42.3954)   # Alewife\n]\ntransit_gdf = gpd.GeoDataFrame(geometry=transit_hubs, crs=parcels.crs)\ntransit_gdf_proj = transit_gdf.to_crs(epsg=26986)\n\n# Define commercial and residential use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n\nresidential_use_codes = [\n    '101', '1014', '102', '1028', '104', '105', '109', '1094', '1095', \n    '1098', '111', '112', '113', '114', '121', '970', '9700', '9421'\n]\n\n# Filter parcels by type\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_use_codes)]\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_use_codes)]\n\n# CONSTRAINT 1: Within 400m of a major transit hub\ntransit_buffers = [geom.buffer(400) for geom in transit_gdf_proj.geometry]\ntransit_union_buffer = unary_union(transit_buffers)\nparcels_near_transit = parcels_proj[parcels_proj.geometry.intersects(transit_union_buffer)]\n\n# Function to check for mixed use within 250m\ndef has_mixed_use_nearby(parcel_geom, commercial_geoms, residential_geoms, buffer_distance=250):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    \n    # Check for at least one commercial and one residential parcel within buffer\n    has_commercial = any(buffered_geom.contains(geom) for geom in commercial_geoms)\n    has_residential = any(buffered_geom.contains(geom) for geom in residential_geoms)\n    \n    return has_commercial and has_residential\n\n# Get geometries for use types\ncommercial_geoms = commercial_parcels.geometry.tolist()\nresidential_geoms = residential_parcels.geometry.tolist()\n\n# Check each parcel for mixed use\nmixed_use_parcels = []\nfor idx, row in parcels_near_transit.iterrows():\n    if has_mixed_use_nearby(row.geometry, commercial_geoms, residential_geoms):\n        mixed_use_parcels.append(row['ml'])\n\n# Filter for parcels with mixed use nearby\nresult_parcels_proj = parcels_near_transit[parcels_near_transit['ml'].isin(mixed_use_parcels)]\n\n# Convert back to original CRS\nresult_parcels = result_parcels_proj.to_crs(parcels.crs)\n\n# Sort by parcel ID for consistency\nresult_parcels = result_parcels.sort_values('ml')\n\n# Display results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels near transit hubs with mixed use nearby\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels that are zoned for retail and within 300m of a subway station and not within 100m of a competitor."}, {"role": "assistant", "content": "import geopandas as gpd\nfrom shapely.geometry import Point\nfrom shapely.ops import unary_union\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Define subway station locations\nsubway_stations = [\n    Point(-71.1189, 42.3736),  # Harvard Square\n    Point(-71.1031, 42.3656),  # Central Square\n    Point(-71.0865, 42.3625),  # Kendall/MIT\n    Point(-71.1226, 42.3782),  # Porter Square\n    Point(-71.1429, 42.3954)   # Alewife\n]\nsubway_gdf = gpd.GeoDataFrame(geometry=subway_stations, crs=parcels.crs)\nsubway_gdf_proj = subway_gdf.to_crs(epsg=26986)\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# CONSTRAINT 1: Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n# CONSTRAINT 2: Within 300m of a subway station\n# Create 300m buffer around subway stations\nsubway_buffers = [geom.buffer(300) for geom in subway_gdf_proj.geometry]\nsubway_union_buffer = unary_union(subway_buffers)\n# Filter for retail parcels within 300m of subway stations\nretail_near_subway = retail_parcels[retail_parcels.geometry.intersects(subway_union_buffer)].copy()\n# CONSTRAINT 3: NOT within 100m of a competitor\n# Filter for retail businesses from POI data (competitors)\nretail_poi = poi_proj[poi_proj['business_type'] == 'retail']\n# Function to check if a parcel is NOT within 100m of a competitor\ndef has_no_nearby_competitors(parcel_geom, parcel_id, competitor_geoms, buffer_distance=100):\n    # Create buffer around parcel\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    \n    # Check for any competitors within buffer\n    for geom in competitor_geoms:\n        if buffered_geom.contains(geom):\n            return False  # Has at least one competitor within range\n    \n    return True  # No competitors within range\n# Get retail POI geometries\nretail_poi_geoms = retail_poi['geometry'].tolist()\n# Filter for parcels without nearby competitors\nretail_no_competitors = []\nfor idx, row in retail_near_subway.iterrows():\n    if has_no_nearby_competitors(row['geometry'], row['ml'], retail_poi_geoms):\n        retail_no_competitors.append(row['ml'])\n# Filter for final result\nfinal_parcels = retail_near_subway[retail_near_subway['ml'].isin(retail_no_competitors)]\n# Convert back to original CRS\nfinal_parcels = final_parcels.to_crs(parcels.crs)\n# Sort by parcel ID for consistency\nfinal_parcels = final_parcels.sort_values('ml')\n# Display results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} retail parcels within 300m of subway stations and without competitors within 100m\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels that are within 100 meters of a major intersection."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n\n\n# Define intersection coordinates\nmajor_intersections = [\n    (-71.1189, 42.3736),\n    (-71.1031, 42.3656),\n    (-71.0865, 42.3625),\n    (-71.1226, 42.3782),\n    (-71.1429, 42.3954)\n]\n\n\n# Convert to GeoDataFrame\nintersection_geom = [gpd.points_from_xy([lon], [lat])[0] for lon, lat in major_intersections]\nintersection_gdf = gpd.GeoDataFrame(geometry=intersection_geom, crs=parcels.crs)\n\n\n# Project to CRS for buffer\nparcels_proj = parcels.to_crs(epsg=26986)\nintersection_proj = intersection_gdf.to_crs(epsg=26986)\n\n\n# Create 100m buffers\nintersection_buffers = [geom.buffer(100) for geom in intersection_proj.geometry]\nunion_buffer = gpd.GeoSeries(intersection_buffers).union_all()\n\n\n# Find parcels within buffer\nparcels_near_intersections = parcels_proj[parcels_proj.geometry.intersects(union_buffer)]\nresult_ids = sorted(parcels_near_intersections['ml'].tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find office parcels (use_code indicating office) in areas with high educational attainment (pct_adv_deg above 1%), larger than 5000 sq ft, and within 400m of harvard university"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\npoi     = gpd.read_file('cambridge_poi_processed.geojson').to_crs(epsg=26986)\ncensus  = gpd.read_file('cambridge_census_cambridge_pct.geojson').to_crs(epsg=26986)\n\n# Drop conflicting join column if present\nif 'index_right' in census.columns:\n    census = census.drop(columns=['index_right'])\n\n# Office use codes\noffice_use_codes = ['340','341','343','345','346']\n\n# Filter office parcels >5000 sq ft\noffices = parcels[(parcels['use_code'].isin(office_use_codes)) & (parcels['land_area'] > 5000)]\n\n# Harvard University POIs\nunis = poi[poi['SUB_CATEGORY'].str.contains('Colleges, Universities, and Professional Schools', case=False, na=False)]\nuni_buf = unis.geometry.buffer(400).union_all()\n\n# Offices within 400m of any university\nnear_uni = offices[offices.geometry.intersects(uni_buf)]\n\n# Join centroids to census tracts and filter pct_adv_deg > 10%\npts = near_uni.copy()\npts.geometry = pts.geometry.centroid\njoined = gpd.sjoin(pts, census, how='inner', predicate='within', lsuffix='offc', rsuffix='cens')\nhigh_ed = joined[joined['pct_adv_deg'] > 0.01]\n\n# Result IDs\nresult_ids = sorted(high_ed['ml'].unique().tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find residential parcels"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\nspending = pd.read_csv('cambridge_spend_processed.csv')\n\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n\n# Filter for residential parcels\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith('01')].copy()\n\n# Sort by parcel ID (ml)\nresult_ids = sorted(residential_parcels['ml'].tolist())\n\n# Print results\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find retail parcels"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('cambridge_spend_processed.csv')\n# Convert to projected CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\n# Define retail use codes\nretail_use_codes = [320, 321, 323, 324, 325, 326, 327, 328, 330]\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith('32')]\n# Sort by parcel ID\nretail_parcels = retail_parcels.sort_values('ml')\n# Convert back to original CRS\nretail_parcels = retail_parcels.to_crs(parcels.crs)\n# Output results\nretail_ids = retail_parcels['ml'].tolist()\nprint(retail_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find large office parcels (use_code starting with '34') larger than 6000 sq ft"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n# Define large office use codes\nlarge_office_use_codes = ['340', '341', '343', '345', '346', '347', '348', '349']\n# Filter for large office parcels larger than 6000 sq ft\nlarge_office_parcels = parcels[\n    (parcels['use_code'].astype(str).str.startswith('34')) &\n    (parcels['land_area'] > 6000)\n].copy()\n# Sort by parcel ID (ml)\nresult_ids = large_office_parcels['ml'].tolist()\nresult_ids.sort()\n# Print results\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find industrial parcels"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n# Define industrial use codes\nindustrial_use_codes = [ '400', '404', '406', '410', '412', '413', '414', '415', '416', '417', '418', '419' ]\n# Filter for industrial parcels\nindustrial_parcels = parcels[parcels['use_code'].astype(str).str.startswith('40')]\n# Sort by parcel ID (ml)\nresult_ids = industrial_parcels['ml'].sort_values().tolist()\n# Print results\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels near universities where student spending is known to be high"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n\n# Query: find parcels near universities where student spending is known to be high\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\nspend_data = pd.read_csv('cambridge_spend_processed.csv')\n\n\n# Define university locations in Cambridge\nuniversities = {\n    'Harvard University': {'lon': -71.1189, 'lat': 42.3736},\n    'Massachusetts Institute of Technology': {'lon': -71.0921, 'lat': 42.3601}\n}\n\n\n# Create university POIs if not in POI data\nuniversity_in_poi = False\nfor univ_name in universities.keys():\n    if 'name' in poi.columns and any(poi['name'].str.contains(univ_name, case=False, na=False)):\n        university_in_poi = True\n        break\n\n\nif university_in_poi:\n    # Filter for university POIs\n    university_poi = poi[poi['name'].apply(\n        lambda x: any(univ.lower() in str(x).lower() for univ in universities.keys()) if x is not None else False\n    )].copy()\nelse:\n    # Create university points from our defined coordinates\n    university_points = [Point(univ['lon'], univ['lat']) for univ in universities.values()]\n    university_names = list(universities.keys())\n    \n    # Create GeoDataFrame\n    university_poi = gpd.GeoDataFrame(\n        {'name': university_names, 'geometry': university_points},\n        crs=parcels.crs\n    )\n\n\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\nuniversity_poi_proj = university_poi.to_crs(epsg=26986)\n\n\n# Define student-oriented business types\nstudent_oriented_businesses = [\n    'restaurant', 'cafe', 'bar', 'coffee_shop', 'bookstore', 'convenience_store',\n    'grocery_store', 'clothing_store', 'electronics_store'\n]\n\n\n# Filter for student-oriented POIs\nstudent_poi = poi[poi['business_type'].apply(\n    lambda x: any(biz.lower() in str(x).lower() for biz in student_oriented_businesses) if x is not None else False\n)].copy()\nstudent_poi_proj = student_poi.to_crs(epsg=26986)\n\n\n# Analyze spending patterns\n# If spending data has business type or category, use it to filter\nstudent_spend = None\n\n\nif 'business_type' in spend_data.columns:\n    student_spend = spend_data[spend_data['business_type'].apply(\n        lambda x: any(biz.lower() in str(x).lower() for biz in student_oriented_businesses) if x is not None else False\n    )].copy()\nelif 'category' in spend_data.columns:\n    student_spend = spend_data[spend_data['category'].apply(\n        lambda x: any(biz.lower() in str(x).lower() for biz in student_oriented_businesses) if x is not None else False\n    )].copy()\nelse:\n    # If no business type/category, use all spending data\n    student_spend = spend_data.copy()\n\n\n# Ensure RAW_TOTAL_SPEND column exists\nif 'RAW_TOTAL_SPEND' not in student_spend.columns:\n    spend_cols = [col for col in student_spend.columns if 'spend' in col.lower()]\n    if spend_cols:\n        student_spend['RAW_TOTAL_SPEND'] = student_spend[spend_cols[0]]\n    else:\n        print(\"Warning: No spending data found. Using default values.\")\n        student_spend['RAW_TOTAL_SPEND'] = 1000  # Default spending\n\n\n# Create buffers around universities (500m for campus area)\nuniversity_buffers = university_poi_proj.geometry.buffer(500).union_all()\n\n\n# Find parcels within university buffer\nparcels_near_univ = parcels_proj[parcels_proj.geometry.intersects(university_buffers)].copy()\n\n\n# Determine high spending areas\n# If student spend has coordinates, use spatial analysis\nif all(col in student_spend.columns for col in ['latitude', 'longitude']):\n    # Create geometry for spend data\n    student_spend['geometry'] = student_spend.apply(\n        lambda row: Point(row['longitude'], row['latitude']), \n        axis=1\n    )\n    student_spend_gdf = gpd.GeoDataFrame(student_spend, geometry='geometry', crs='EPSG:4326')\n    student_spend_gdf = student_spend_gdf.to_crs(epsg=26986)\n    \n    # Calculate average spending within 100m of each parcel\n    def calculate_nearby_spending(parcel_geom, spend_data, buffer_distance=100):\n        buffered_geom = parcel_geom.buffer(buffer_distance)\n        nearby_spend = spend_data[spend_data.geometry.intersects(buffered_geom)]\n        if len(nearby_spend) == 0:\n            return 0\n        return nearby_spend['RAW_TOTAL_SPEND'].mean()\n    \n    # Calculate spending for each parcel near university\n    parcels_near_univ['avg_nearby_spend'] = parcels_near_univ.geometry.apply(\n        lambda geom: calculate_nearby_spending(geom, student_spend_gdf)\n    )\nelse:\n    # Without coordinates, try to join by common key\n    join_keys = ['place_id', 'poi_id', 'PLACEKEY', 'ml']\n    join_key = None\n    \n    for key in join_keys:\n        if key in parcels_near_univ.columns and key in student_spend.columns:\n            join_key = key\n            break\n    \n    if join_key:\n        # Join on common key\n        parcels_near_univ = parcels_near_univ.merge(\n            student_spend[[join_key, 'RAW_TOTAL_SPEND']],\n            on=join_key,\n            how='left'\n        )\n        parcels_near_univ['avg_nearby_spend'] = parcels_near_univ['RAW_TOTAL_SPEND'].fillna(0)\n    else:\n        # If no joining possible, use proximity to student POIs as proxy\n        def count_nearby_student_poi(parcel_geom, student_poi_data, buffer_distance=100):\n            buffered_geom = parcel_geom.buffer(buffer_distance)\n            nearby_poi = student_poi_data[student_poi_data.geometry.intersects(buffered_geom)]\n            return len(nearby_poi)\n        \n        parcels_near_univ['student_poi_count'] = parcels_near_univ.geometry.apply(\n            lambda geom: count_nearby_student_poi(geom, student_poi_proj)\n        )\n        parcels_near_univ['avg_nearby_spend'] = parcels_near_univ['student_poi_count'] * 1000  # Proxy for spending\n\n\n# Define high spending threshold (top 25%)\nif 'avg_nearby_spend' in parcels_near_univ.columns and len(parcels_near_univ) > 0:\n    high_spend_threshold = parcels_near_univ['avg_nearby_spend'].quantile(0.75)\n    high_spend_parcels = parcels_near_univ[parcels_near_univ['avg_nearby_spend'] >= high_spend_threshold].copy()\nelse:\n    # Fallback: use parcels closest to university\n    print(\"Warning: No spending data available. Using proximity to university as proxy.\")\n    high_spend_parcels = parcels_near_univ.copy()\n\n\n# Sort by spending (or proximity) and get results\nif 'avg_nearby_spend' in high_spend_parcels.columns:\n    high_spend_parcels = high_spend_parcels.sort_values('avg_nearby_spend', ascending=False)\nelse:\n    # Sort by proximity to university center\n    def distance_to_university(parcel_geom, univ_geoms):\n        return min(parcel_geom.distance(univ_geom) for univ_geom in univ_geoms)\n    \n    high_spend_parcels['univ_distance'] = high_spend_parcels.geometry.apply(\n        lambda geom: distance_to_university(geom, university_poi_proj.geometry)\n    )\n    high_spend_parcels = high_spend_parcels.sort_values('univ_distance')\n\n\n# Convert back to original CRS\nhigh_spend_parcels = high_spend_parcels.to_crs(parcels.crs)\n\n\n# Output results\nresult_ids = high_spend_parcels['ml'].tolist()\nprint(f\"Found {len(high_spend_parcels)} parcels near universities with high student spending\")\nprint(f\"Parcel IDs: {result_ids[:30]}\") # Show first 30 if there are many"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: locate commercial parcels that are between 10000-15000 sq ft, within 200 meters of a subway station, and in areas with very low competition (fewer than 100 businesses of any type within 100m)"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\npoi     = gpd.read_file('cambridge_poi_processed.geojson').to_crs(epsg=26986)\n\n# Commercial use codes\ncommercial_use_codes = [\n    '300','302','316','323','324','325','326','327',\n    '330','332','334','340','341','343','345','346',\n    '353','362','375','404','406','0340','0406'\n]\n\n# Filter for commercial parcels between 10000 and 15000 sq ft\ncomm = parcels[\n    parcels['use_code'].isin(commercial_use_codes) &\n    parcels['land_area'].between(10000, 15000)\n].copy()\n\n# Buffer five MBTA subway stations by 200m\nstations = [\n    Point(-71.1189, 42.3736),  # Harvard Square\n    Point(-71.1031, 42.3656),  # Central Square\n    Point(-71.0865, 42.3625),  # Kendall/MIT\n    Point(-71.1226, 42.3782),  # Porter Square\n    Point(-71.1429, 42.3954)   # Alewife\n]\nsubway = gpd.GeoSeries(stations, crs='EPSG:4326')\nsubway = subway.to_crs(epsg=26986)\nbuf200 = subway.buffer(200).union_all()\n\n# Keep only parcels within 200m of any station\nnear_subway = comm[comm.geometry.intersects(buf200)].copy()\n\n# Prepare competitor geometries (any POI)\ncomp_points = poi.geometry.tolist()\n\n# Count competitors within 100m of each parcel\ndef count_competitors(parcel_geom):\n    return sum(1 for pt in comp_points if parcel_geom.distance(pt) <= 100)\n\nnear_subway['comp_count'] = near_subway.geometry.apply(count_competitors)\n\n# Filter parcels with fewer than 100 competitors\nlow_comp = near_subway[near_subway['comp_count'] < 100]\n\n# Output result IDs\nresult_ids = sorted(low_comp['ml'].unique().tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find the top 15 commercial parcels with the highest ratio of commercial to residential properties within 350 meters."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n\n# Project to a metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n\n# Define commercial and residential use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n\nresidential_use_codes = [\n    '101', '1014', '102', '1028', '104', '105', '109', '1094', '1095', \n    '1098', '111', '112', '113', '114', '121', '970', '9700', '9421'\n]\n\n# Filter for commercial and residential parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_use_codes)]\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_use_codes)]\n\n# Function to calculate commercial-to-residential ratio\ndef calculate_commercial_ratio(parcel_geom, commercial_geoms, residential_geoms, buffer_distance=350):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    \n    # Count commercial and residential properties within buffer\n    commercial_count = sum(1 for geom in commercial_geoms if buffered_geom.contains(geom))\n    residential_count = sum(1 for geom in residential_geoms if buffered_geom.contains(geom))\n    \n    # Calculate ratio (avoid division by zero)\n    if residential_count == 0:\n        return commercial_count * 10  # High value for areas with no residential\n    else:\n        return commercial_count / residential_count\n\n# Get all geometries\ncommercial_geoms = commercial_parcels.geometry.tolist()\nresidential_geoms = residential_parcels.geometry.tolist()\n\n# For efficiency, sample a subset of commercial parcels\nstep = max(1, len(commercial_parcels) // 500)  # Limit to ~500 samples\nsampled_commercial = commercial_parcels.iloc[::step].copy()\n\n# Calculate commercial ratio for each sampled commercial parcel\nsampled_commercial['comm_res_ratio'] = sampled_commercial.geometry.apply(\n    lambda geom: calculate_commercial_ratio(geom, commercial_geoms, residential_geoms)\n)\n\n# Sort by ratio (descending) and select top 15\ntop15 = sampled_commercial.nlargest(15, 'comm_res_ratio')\n\n# Convert back to original CRS\ntop15 = top15.to_crs(parcels.crs)\n\n# Display results\nresult_ids = top15['ml'].tolist()\nprint(f\"Top 15 commercial parcels by commercial-to-residential ratio within 350m:\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: identify parcels where (pct_adv_deg > 40% AND land_area > 8000 sq ft) OR (land_area > 12000 AND use_code IN [commercial_codes])"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n\n# Define commercial use codes\ncommercial_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n\n\n# Define projected CRS for Cambridge\ncambridge_crs = 26986\nparcels_proj = parcels.to_crs(epsg=cambridge_crs)\ncensus_proj = census.to_crs(epsg=cambridge_crs)\n\n\n# Ensure 'pct_adv_deg' exists\nif 'pct_adv_deg' not in census_proj.columns:\n    raise ValueError(\"'pct_adv_deg' column not found in census data\")\n\n\n# Spatial join: assign education % to each parcel\nparcels_with_edu = gpd.sjoin(parcels_proj, census_proj[['pct_adv_deg', 'geometry']], how='left', predicate='within')\n\n\n# Condition 1: pct_adv_deg > 40 AND land_area > 8000\ncond1 = (parcels_with_edu['pct_adv_deg'] > 40) & (parcels_with_edu['land_area'] > 8000)\n\n\n# Condition 2: land_area > 12000 AND use_code in commercial codes\ncond2 = (parcels_with_edu['land_area'] > 12000) & (\n    parcels_with_edu['use_code'].astype(str).isin(commercial_codes)\n)\n\n\n# Combine conditions\ncombined = parcels_with_edu[cond1 | cond2].copy()\n\n\n# Sort and convert back to original CRS\ncombined = combined.sort_values('ml').to_crs(parcels.crs)\n\n\n# Output result\nresult_ids = combined['ml'].tolist()\nprint(f\"Found {len(result_ids)} parcels\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels for office use larger than 10000 sq ft, prioritizing locations with a high percentage of residents aged 18-64"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Filter for office-use codes\noffice_use_codes = ['340', '343', '345', '346', '0340', '404', '406']\noffice_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(office_use_codes)].copy()\n# Filter by size (>10,000 sq ft)\nlarge_office_parcels = office_parcels[office_parcels['land_area'] > 10000].copy()\n# Prioritize by proximity to areas with high proportion of residents aged 18-64\n# Define high proportion threshold (e.g., >50%)\nhigh_age_pct = 50\n# Filter for areas with high proportion of 18-64\nhigh_age_areas = census_proj[census_proj['pct_18_64'] > high_age_pct].copy()\n# Sort by proximity to high age areas\ndef prioritize_by_age_proximity(parcel_geom, high_age_geoms, buffer_distance=200):\n    buffered_geoms = [geom.buffer(buffer_distance) for geom in high_age_geoms]\n    if not buffered_geoms:\n        return float('inf')  # No high age areas, assign low priority\n    return min(geom.distance(parcel_geom) for geom in buffered_geoms)\n# Get high age area geometries\nhigh_age_geoms = high_age_areas['geometry'].tolist()\n# Calculate priority score (lower is better)\nlarge_office_parcels.loc[:, 'age_priority'] = large_office_parcels.geometry.apply(\n    lambda geom: prioritize_by_age_proximity(geom, high_age_geoms)\n)\n# Sort by priority (closest to high age areas first)\nresult_parcels = large_office_parcels.sort_values('age_priority').copy()\n# Get parcel IDs (ml) for final result\nresult_ids = result_parcels['ml'].tolist()\n# Print results\nprint(f\"Found {len(result_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs (prioritized by age area proximity): {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find commercial parcels less than 400 meters from Alewife station with the highest percentage of residents aged 18-64."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n# Define Alewife station location\nalewife = Point(-71.1429, 42.3954)\n\n# Create GeoDataFrame for Alewife\nalewife_gdf = gpd.GeoDataFrame(geometry=[alewife], crs=parcels.crs)\n\n# Project to a metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\nalewife_gdf_proj = alewife_gdf.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n\n# Define commercial use codes consistently\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n\n# Filter for commercial parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_use_codes)]\n\n# Create 400m buffer around Alewife\nalewife_buffer = alewife_gdf_proj.buffer(400).iloc[0]\n\n# Filter parcels within 400m of Alewife\nparcels_near_alewife = commercial_parcels[commercial_parcels.geometry.intersects(alewife_buffer)]\n\n# Spatial join with census data\nparcels_with_census = gpd.sjoin(\n    parcels_near_alewife,\n    census_proj,\n    how='left',\n    predicate='within'\n)\n\n# Sort by percentage of residents aged 18-64 (descending)\nresult_parcels_proj = parcels_with_census.sort_values('pct_18_64', ascending=False)\n\n# Convert back to original CRS\nresult_parcels = result_parcels_proj.to_crs(parcels.crs)\n\n# Display results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Commercial parcels <400m from Alewife, sorted by % residents aged 18-64:\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels that, if zoned for mixed-use, must have both residential and commercial components, or if not, must be at least 40000 sq ft in size"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\n\n# Use code lists\nmixed_use_codes      = ['0101','0104','0105','0111','0112','0121','013','031','0340','0406','041','0942']\nresidential_codes    = ['101','1014','102','1028','104','105','109','1094','1095','1098','111','112','113','114','121','970','9700','9421']\ncommercial_codes     = ['300','302','316','323','324','325','326','327','330','332','334','340','341','343','345','346','353','362','375','404','406','0340','0406']\n\n# Build spatial index for residential and commercial parcels\ngpd_res = parcels[parcels['use_code'].isin(residential_codes)]\ngpd_com = parcels[parcels['use_code'].isin(commercial_codes)]\n\n# Function to test mixed-use parcels for both components within parcel buffer\ndef has_both_components(parcel):\n    geom = parcel.geometry\n    buf = geom.buffer(0)  # use exact parcel geometry\n    has_res = any(buf.intersects(g) for g in gpd_res.geometry)\n    has_com = any(buf.intersects(g) for g in gpd_com.geometry)\n    return has_res and has_com\n\n# Conditional subsets\nmixed     = parcels[parcels['use_code'].isin(mixed_use_codes)].copy()\nnon_mixed = parcels[~parcels['use_code'].isin(mixed_use_codes)].copy()\n\n# Mixed-use must have both components\ngood_mixed = mixed[mixed.apply(has_both_components, axis=1)]\n# Non-mixed must be >=40000 sq ft\ngood_non   = non_mixed[non_mixed['land_area'] >= 40000]\n\n# Combine results\nimport pandas as pd\nresult = pd.concat([good_mixed, good_non]).drop_duplicates(subset='ml')\n\n# Output parcel IDs\nresult_ids = sorted(result['ml'].tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels that are either commercial places within 100m of harvard square or residential larger than 5000 square feet and within 200m of 50 restaurants."}, {"role": "assistant", "content": "import geopandas as gpd\nfrom shapely.geometry import Point\nfrom shapely.ops import unary_union\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Define Harvard Square location\nharvard_square = Point(-71.1189, 42.3736)\nharvard_gdf = gpd.GeoDataFrame(geometry=[harvard_square], crs=parcels.crs)\nharvard_gdf_proj = harvard_gdf.to_crs(epsg=26986)\n# Define commercial and residential use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\nresidential_use_codes = [\n    '101', '1014', '102', '1028', '104', '105', '109', '1094', '1095', \n    '1098', '111', '112', '113', '114', '121', '970', '9700', '9421'\n]\n# CONDITION 1: Commercial parcels within 100m of Harvard Square\n# Create 100m buffer around Harvard Square\nharvard_buffer = harvard_gdf_proj.buffer(100).iloc[0]\n# Filter for commercial parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_use_codes)]\n# Find commercial parcels within 100m of Harvard Square\ncommercial_near_harvard = commercial_parcels[commercial_parcels.geometry.intersects(harvard_buffer)].copy()\n# CONDITION 2: Residential parcels larger than 5000 sq ft and within 200m of 50 restaurants\n# Filter for residential parcels > 5000 sq ft\nlarge_residential = parcels_proj[\n    (parcels_proj['use_code'].astype(str).isin(residential_use_codes)) & \n    (parcels_proj['land_area'] > 5000)\n].copy()\n# Filter for restaurants from POI data\nrestaurants = poi_proj[poi_proj['business_type'] == 'restaurant']\n# Find parcels with at least 50 restaurants within 200m\ndef count_nearby_restaurants(parcel_geom, restaurant_geoms, buffer_distance=200):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    count = sum(1 for geom in restaurant_geoms if buffered_geom.contains(geom))\n    return count\n# Get restaurant geometries\nrestaurant_geoms = restaurants['geometry'].tolist()\n# Calculate nearby restaurant count for each large residential parcel\nlarge_residential['nearby_restaurants'] = large_residential['geometry'].apply(\n    lambda geom: count_nearby_restaurants(geom, restaurant_geoms)\n)\n# Filter for parcels with at least 50 restaurants within 200m\nresidential_near_restaurants = large_residential[large_residential['nearby_restaurants'] >= 50]\n# Identify all parcels that meet either condition\ncommercial_ids = set(commercial_near_harvard['ml'].tolist())\nresidential_ids = set(residential_near_restaurants['ml'].tolist())\nall_ids = commercial_ids.union(residential_ids)\n# Filter the original parcels dataframe for these IDs\nresult_parcels = parcels_proj[parcels_proj['ml'].isin(all_ids)]\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Sort by parcel ID for consistency\nresult_parcels = result_parcels.sort_values('ml')\n# Display results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels meeting either condition\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find commercial parcels ideally located near popular retail areas, such as harvard square or kendall square."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('cambridge_spend_processed.csv')\n\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n\n# Filter for commercial parcels\ncommercial_parcels = parcels[parcels['use_code'].astype(str).isin(commercial_use_codes)].copy()\n\n# Define Harvard Square and Kendall Square locations\nharvard_square_point = Point(-71.118956, 42.373611)\nkendall_square_point = Point(-71.086176, 42.362490)\n\nharvard_square = gpd.GeoDataFrame(geometry=[harvard_square_point], crs=parcels.crs)\nkendall_square = gpd.GeoDataFrame(geometry=[kendall_square_point], crs=parcels.crs)\n\n# Convert to projected CRS for accurate distance measurement\ncommercial_parcels_proj = commercial_parcels.to_crs(epsg=26986)\nharvard_square_proj = harvard_square.to_crs(epsg=26986)\nkendall_square_proj = kendall_square.to_crs(epsg=26986)\n\n# Calculate distance to Harvard Square and Kendall Square\ncommercial_parcels_proj['dist_to_harvard'] = commercial_parcels_proj.geometry.distance(harvard_square_proj.geometry[0])\ncommercial_parcels_proj['dist_to_kendall'] = commercial_parcels_proj.geometry.distance(kendall_square_proj.geometry[0])\n\n# Prioritize parcels that are closer to either location\n# Use a weighted approach: 70% weight on Harvard distance, 30% on Kendall distance\ncommercial_parcels_proj['distance_score'] = (\n    0.7 * commercial_parcels_proj['dist_to_harvard'] +\n    0.3 * commercial_parcels_proj['dist_to_kendall']\n)\n\n# Sort by proximity to retail areas (lower score is better)\nresult_parcels = commercial_parcels_proj.sort_values('distance_score')\n\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n\n# Get top 10 results\ntop_parcels = result_parcels.head(10)\n\n# Output results\nresult_ids = top_parcels['ml'].tolist()\nprint(f\"Found {len(top_parcels)} parcels near retail areas\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find residential parcels less than 100 meters from a grocery store but at least 800 meters from any industrial area."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.ops import unary_union\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi      = gpd.read_file('cambridge_poi_processed.geojson')\n\n# Project\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj     = poi.to_crs(epsg=26986)\n\n# Codes\nres_codes = ['101','1014','102','1028','104','105','109','1094','1095','1098','111','112','113','114','121','970','9700','9421']\nind_codes = ['400','401','407','413']\nres    = parcels_proj[parcels_proj['use_code'].isin(res_codes)].copy()\nindus  = parcels_proj[parcels_proj['use_code'].isin(ind_codes)]\n\n# Grocery buffer 100m\ngroc = poi_proj[poi_proj['business_type']=='grocery_stores']\nb_groc = unary_union(groc.geometry.buffer(100))\nnear_g = res[res.geometry.intersects(b_groc)].copy()\n\n# Industrial buffer 800m and exclude\nb_ind = unary_union(indus.geometry.buffer(800))\nresult = near_g[~near_g.geometry.intersects(b_ind)]\n\n# Output\nids = sorted(result['ml'].tolist())\nprint(ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find retail parcels between 2500 and 4500 square feet"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Filter for retail parcels\nretail_parcels = parcels[parcels['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Filter by size\nsize_filtered_parcels = retail_parcels[\n    (retail_parcels['land_area'] >= 2500) & (retail_parcels['land_area'] <= 4500)\n].copy()\n# Sort by ml (parcel ID)\nresult_parcels = size_filtered_parcels.sort_values('ml')\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels less than 2000 square feet"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\n# Filter for small parcels (<2000 sq ft)\nsmall_parcels = parcels_proj[parcels_proj['land_area'] < 2000]\n# Sort by parcel ID (ml)\nresult_ids = small_parcels['ml'].sort_values().tolist()\n# Print results\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find retail spaces smaller than 2000 sq ft"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\n\n# Define retail use codes based on the land use table\nretail_use_codes = [\n    '323',  # SH-CNTR/MALL\n    '324',  # SUPERMARKET\n    '325',  # RETAIL-STORE\n    '326',  # EATING-ESTBL\n    '327',  # RETAIL-CONDO\n    '330',  # AUTO-SALES\n    '332',  # AUTO-REPAIR\n    '334',  # GAS-STATION\n    '341'   # BANK\n]\n\n# Filter for retail parcels smaller than 2000 sq ft\nsmall_retail_parcels = parcels_proj[\n    (parcels_proj['use_code'].astype(str).isin(retail_use_codes)) & \n    (parcels_proj['land_area'] < 2000)\n].copy()\n\n# Sort by parcel ID (ml) for consistency\nsmall_retail_parcels = small_retail_parcels.sort_values('ml')\n\n# Convert back to original CRS\nsmall_retail_parcels = small_retail_parcels.to_crs(parcels.crs)\n\n# Extract parcel IDs\nresult_ids = small_retail_parcels['ml'].tolist()\n\n# Print results\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find retail parcels (use_code indicating retail) that are not within 100m of any competitor, with land area between 6000-20000 sq ft"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n\n\n# Define retail use codes\nretail_use_codes = [\n    '323', '324', '325', '326', '327',  # Retail stores\n    '332', '334',  # Department stores\n    '340', '341', '343', '345', '346',  # Shopping centers/malls\n    '353', '362'   # Other retail-related codes\n]\n\n\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n\n\n# Filter for parcels with land area between 6000-20000 sq ft\nsized_retail_parcels = retail_parcels[(retail_parcels['land_area'] >= 6000) & \n(retail_parcels['land_area'] <= 20000)].copy()\n\n\n# Filter POI data to identify retail competitors\n# Assuming POI data has 'business_type' field that can identify retail businesses\nretail_competitors = poi_proj[poi_proj['business_type'].str.contains('Retail|Store|Shop|Mall', \n  case=False, \n na=False)].copy()\n\n# Find retail parcels that are not within 1000m of any competitor\nresult_parcels = []\n\n\nfor idx, parcel in sized_retail_parcels.iterrows():\n    # Create 100m buffer around the parcel\n    buffer = parcel.geometry.buffer(100)\n    \n    # Check for competitors within buffer\n    competitors = retail_competitors[retail_competitors.geometry.intersects(buffer)].copy()\n    \n    # If parcel has a matching POI entry, subtract 1 from the count to avoid counting itself\n    # Assuming parcels can be matched to POIs via a common identifier or spatial location\n    competitor_count = len(competitors)\n    \n    # Check if this parcel is itself in the competitors list\n    parcel_centroid = parcel.geometry.centroid\n    for comp_idx, competitor in competitors.iterrows():\n        if parcel_centroid.distance(competitor.geometry) < 10:  # Within 10m tolerance\n            competitor_count -= 1\n            break\n    \n    # Keep parcels with no competitors nearby\n    if competitor_count == 0:\n        result_parcels.append({\n            'ml': parcel['ml'],\n            'geometry': parcel.geometry,\n            'land_area': parcel['land_area'],\n            'use_code': parcel['use_code']\n        })\n\n\n# Create GeoDataFrame from results\nif result_parcels:\n    result_gdf = gpd.GeoDataFrame(result_parcels, crs=parcels_proj.crs)\n    \n    # Convert back to original CRS\n    result_gdf = result_gdf.to_crs(parcels.crs)\n    \n    # Sort by parcel ID for consistency\n    result_gdf = result_gdf.sort_values('ml')\n    \n    # Output results\n    result_ids = result_gdf['ml'].tolist()\n    print(f\"Found {len(result_gdf)} retail parcels (6000-20000 sq ft) with no competitors within 100m\")\n    print(f\"Parcel IDs: {result_ids}\")\nelse:\n    print(\"No parcels found matching all criteria.\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels larger than 12000 sq ft, zoned for retail, and located in areas with high consumer spending (top 20% of cambridge neighborhoods)"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\nspend_data = pd.read_csv('cambridge_spend_processed.csv')\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Convert to projected CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Filter for large retail parcels (>12000 sq ft)\nlarge_retail_parcels = retail_parcels[retail_parcels['land_area'] > 12000].copy()\n# Combine POI and spending data\npoi_with_spend = poi.merge(\n    spend_data,\n    left_on='PLACEKEY',\n    right_on='PLACEKEY',\n    how='left'\n)\n# Fill NaN values in spending with 0\nif 'RAW_TOTAL_SPEND' in poi_with_spend.columns:\n    poi_with_spend['RAW_TOTAL_SPEND'] = poi_with_spend['RAW_TOTAL_SPEND'].fillna(0)\nelse:\n    poi_with_spend['RAW_TOTAL_SPEND'] = 0\n# Convert to projected CRS\npoi_with_spend_proj = poi_with_spend.to_crs(epsg=26986)\n# Spatial join: assign spending to nearby parcels\ndef assign_spending(parcel_geom, poi_geoms, poi_spend, radius=100):  # 100m radius\n    # Find POI within radius\n    buffered_geom = parcel_geom.buffer(radius)\n    nearby_poi = poi_geoms[buffered_geom.contains(poi_geoms)]\n    \n    if nearby_poi.empty:\n        return 0  # No nearby POI, return 0 spend\n    \n    # Get spend values for nearby POI\n    spend_values = []\n    for idx in nearby_poi.index:\n        spend = poi_spend[poi_geoms.index == idx].values\n        spend_values.append(spend[0] if spend.size > 0 else 0)\n    \n    # Average spend from nearby POI\n    return sum(spend_values) / len(spend_values)\n# Calculate spending for each large retail parcel\nlarge_retail_parcels.loc[:, 'estimated_spending'] = large_retail_parcels.geometry.apply(\n    lambda geom: assign_spending(geom, poi_with_spend_proj.geometry, \n                                  poi_with_spend_proj['RAW_TOTAL_SPEND'])\n)\n# Sort by estimated spending (higher is better)\nresult_parcels = large_retail_parcels.sort_values('estimated_spending', ascending=False)\n# Convert back to original CRS\nresult_ids = result_parcels['ml'].tolist()\n# Print results\nprint(f\"Found {len(result_parcels)} parcels matching criteria\")\nprint(f\"Parcel IDs (high spend): {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels that are within 200 meters of cambridge city hall."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n\n\n# City Hall approximate location\ncity_hall_location = (-71.0822, 42.3736)\n\n\n# Create GeoDataFrame\ncity_hall_gdf = gpd.GeoDataFrame(\n    geometry=gpd.points_from_xy([city_hall_location[0]], [city_hall_location[1]]),\n    crs=parcels.crs\n)\n\n\n# Project to metric CRS\nparcels_proj = parcels.to_crs(epsg=26986)\ncity_hall_proj = city_hall_gdf.to_crs(epsg=26986)\n\n\n# Create buffer and filter\ncity_hall_buffer = city_hall_proj.buffer(200).iloc[0]\nnear_parcels = parcels_proj[parcels_proj.geometry.intersects(city_hall_buffer)].copy()\n\n\n# Sort and convert back\nnear_parcels = near_parcels.sort_values(by='ml').to_crs(parcels.crs)\nresult_ids = near_parcels['ml'].tolist()\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find single-family residential parcels larger than 8,000 sq ft that are within 400 m of a public park and have at least three supermarkets (or grocery stores) within 500 m."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n# 1) Load & project\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\npoi     = gpd.read_file('cambridge_poi_processed.geojson').to_crs(epsg=26986)\n\n# 2) Filter single-family residential parcels > 8,000 sq ft\nsf_codes = ['101','1014','0101']\nres_sf = parcels[\n    parcels['use_code'].isin(sf_codes) &\n    (parcels['land_area'] > 8000)\n].copy()\n\n# 3) Identify parcels within 400 m of a Nature Park\nparks       = poi[poi['SUB_CATEGORY'] == 'Nature Parks and Other Similar Institutions']\npark_buf    = parks.geometry.buffer(400).union_all()\nnear_parks  = res_sf[res_sf.geometry.intersects(park_buf)].copy()\n\n# 4) Count supermarkets within 500 m\ngroceries        = poi[poi['SUB_CATEGORY'] == 'Supermarkets and Other Grocery (except Convenience) Stores']\ngrocery_geoms    = groceries.geometry.tolist()\ncounts = []\nfor geom in near_parks.geometry:\n    buf = geom.buffer(500)\n    counts.append(sum(1 for pt in grocery_geoms if buf.contains(pt)))\nnear_parks['supermarkets_nearby'] = counts\n\n# 5) Keep parcels with \u2265 3 supermarkets\nfinal = near_parks[near_parks['supermarkets_nearby'] >= 3]\n\n# 6) Output parcel IDs\nresult_ids = sorted(final['ml'].tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find parcels larger than 6000 square feet that are zoned for retail use."}, {"role": "assistant", "content": "import geopandas as gpd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n\n# Define retail use codes consistently\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n\n# Filter for retail parcels\nretail_parcels = parcels[parcels['use_code'].astype(str).isin(retail_use_codes)]\n\n# Filter for large retail parcels (>6000 sq ft)\nlarge_retail_parcels = retail_parcels[retail_parcels['land_area'] > 6000]\n\n# Sort by parcel ID for consistency\nlarge_retail_parcels = large_retail_parcels.sort_values('ml')\n\n# Display results\nresult_ids = large_retail_parcels['ml'].tolist()\nprint(f\"Found {len(large_retail_parcels)} retail parcels larger than 6000 sq ft\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find commercial parcels that, if larger than 5000 sq ft, must be within 400m of public transit, or if smaller, must be within 200m of residential areas."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_use_codes)].copy()\n# Separate large and small commercial parcels\nlarge_commercial = commercial_parcels[commercial_parcels['land_area'] > 5000].copy()\nsmall_commercial = commercial_parcels[commercial_parcels['land_area'] <= 5000].copy()\n# Define transit stops (subway and major bus stops)\ntransit_stops = [\n    Point(-71.1189, 42.3736),  # Harvard Square\n    Point(-71.1031, 42.3656),  # Central Square\n    Point(-71.0865, 42.3625),  # Kendall/MIT\n    Point(-71.1226, 42.3782),  # Porter Square\n    Point(-71.1429, 42.3954)   # Alewife\n]\ntransit_gdf = gpd.GeoDataFrame(geometry=transit_stops, crs=parcels.crs)\ntransit_gdf_proj = transit_gdf.to_crs(epsg=26986)\n# Create 400m buffer around transit stops\ntransit_buffers = [geom.buffer(400) for geom in transit_gdf_proj.geometry]\ntransit_union_buffer = gpd.GeoSeries(transit_buffers).union_all()\n# CONDITION 1: Large commercial parcels within 400m of transit\nlarge_near_transit = large_commercial[large_commercial.geometry.intersects(transit_union_buffer)].copy()\n# Define residential use codes\nresidential_use_codes = [\n    '101', '1014', '102', '1028', '104', '105', '109', '1094', '1095', \n    '1098', '111', '112', '113', '114', '121', '970', '9700', '9421'\n]\n# Filter for residential parcels\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_use_codes)].copy()\n# Create 200m buffer around residential areas\nresidential_buffers = [geom.buffer(200) for geom in residential_parcels.geometry]\nresidential_union_buffer = gpd.GeoSeries(residential_buffers).union_all()\n# CONDITION 2: Small commercial parcels within 200m of residential areas\nsmall_near_residential = small_commercial[small_commercial.geometry.intersects(residential_union_buffer)].copy()\n# Combine results\nresult_parcels = pd.concat([large_near_transit, small_near_residential])\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} commercial parcels meeting conditional criteria:\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find retail parcels larger than 5000 sq ft, ideally in areas with a diverse mix of nearby businesses"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('cambridge_spend_processed.csv')\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n# Filter for retail parcels larger than 5000 sq ft\nlarge_retail = parcels_proj[\n    (parcels_proj['use_code'].astype(str).isin(retail_use_codes)) &\n    (parcels_proj['land_area'] > 5000)\n].copy()\n# Calculate POI density\ndef calculate_poi_density(parcel_geom, poi_geoms, buffer_distance=100):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    poi_count = sum(1 for geom in poi_geoms if geom is not None and buffered_geom.contains(geom))\n    return poi_count / (buffer_distance ** 2)\n# Get POI geometries\npoi_geoms = poi['geometry'].tolist()\n# Calculate POI density for each retail parcel\nlarge_retail['poi_density'] = large_retail['geometry'].apply(\n    lambda geom: calculate_poi_density(geom, poi_geoms)\n)\n# Sort by POI density (higher is better)\nresult_parcels = large_retail.sort_values('poi_density', ascending=False)\n# Convert back to original CRS\nresult_ids = result_parcels['ml'].tolist()\n# Output results\nprint(f\"Found {len(result_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs (sorted by POI density): {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find retail parcels that are at least 200m away from the nearest competing retail business"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n\n# Define retail business types\nretail_business_types = [\n    'restaurant', 'cafe', 'clothing_store', 'department_store', 'grocery_store',\n    'convenience_store', 'furniture_store', 'hardware_store', 'electronics_store'\n]\n\n\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n\n\n# Filter retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith(('323', '324', '325', '326', '327', '330'))].copy()\n\n\n# Filter retail businesses from POI\nretail_businesses = poi_proj[poi_proj['business_type'].isin(retail_business_types)].copy()\n\n\n# Function to find parcels at least 200m away from nearest competing retail business\ndef filter_parcels_away_from_competitors(parcel_geom, retail_business_geoms, min_distance=200):\n    # Calculate distances to all retail business geometries\n    distances = [parcel_geom.distance(geom) for geom in retail_business_geoms]\n    # Check if any retail business is within the min_distance\n    return all(dist >= min_distance for dist in distances)\n\n\n# Filter retail parcels\nretail_parcels = retail_parcels.copy()\n\n\n# Get retail business geometries\nretail_business_geoms = retail_businesses['geometry'].tolist()\n\n\n# Filter by competitor distance\nfiltered_parcels = []\nfor idx, row in retail_parcels.iterrows():\n    if filter_parcels_away_from_competitors(row['geometry'], retail_business_geoms):\n        filtered_parcels.append(row['ml'])\n\n\n# Sort by parcel ID\nfiltered_parcels.sort()\n\n\n# Output results\nprint(f\"Found {len(filtered_parcels)} retail parcels at least 200m away from competitors\")\nprint(f\"Parcel IDs: {filtered_parcels}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find commercial parcels within 500 meters of Harvard Square."}, {"role": "assistant", "content": "import geopandas as gpd\nfrom shapely.geometry import Point\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n\n# Define Harvard Square location (fixed coordinates)\nharvard_square = Point(-71.1189, 42.3736)\n\n# Create GeoDataFrame for Harvard Square\nharvard_gdf = gpd.GeoDataFrame(geometry=[harvard_square], crs=parcels.crs)\n\n# Convert to projected CRS for accurate distance measurement\nharvard_gdf_proj = harvard_gdf.to_crs(epsg=26986)  # Massachusetts state plane\nparcels_proj = parcels.to_crs(epsg=26986)  # Massachusetts state plane\n\n# Define commercial use codes consistently\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels using use code (more reliable than general_us)\ncommercial_parcels_proj = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith(('3', '4'))]\n\n# Create 500m buffer around Harvard Square in projected coordinates\nharvard_buffer_proj = harvard_gdf_proj.buffer(500) \n\n# Find commercial parcels within 500m of Harvard Square\nresult_parcels_proj = commercial_parcels_proj[commercial_parcels_proj.geometry.intersects(harvard_buffer_proj.iloc[0])]\n\n# Convert back to original CRS\nresult_parcels = result_parcels_proj.to_crs(parcels.crs)\n\n# Sort by ml (parcel ID) for consistency in results\nresult_parcels = result_parcels.sort_values('ml')\n\n# Display results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} commercial parcels within 500m of Harvard Square\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find residential parcels smaller than 10000 square feet and larger than 8000 square feet"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\n\n# Define residential use codes based on the land use table\nresidential_use_codes = [\n    '101',   # SNGL-FAM-RES\n    '1014',  # SINGLE FAM W/AU\n    '102',   # CONDOMINIUM\n    '1028',  # CNDO-RES-PKG\n    '104',   # TWO-FAM-RES\n    '105',   # THREE-FM-RES\n    '109',   # MULTIPLE-RES\n    '1094',  # MULT-RES-2FAM\n    '1095',  # MULT-RES-3FAM\n    '1098',  # MULT-RES-4-8-APT\n    '111',   # 4-8-UNIT-APT\n    '112',   # >8-UNIT-APT\n    '113',   # ASSISTED-LIV\n    '114',   # AFFORDABLE APT\n    '121',   # BOARDING-HSE\n    '970',   # Housing Authority\n    '9700'   # Housing Authority\n]\n\n# Filter for residential parcels within the size range\nresidential_parcels = parcels_proj[\n    (parcels_proj['use_code'].astype(str).isin(residential_use_codes)) & \n    (parcels_proj['land_area'] > 8000) & \n    (parcels_proj['land_area'] < 10000)\n].copy()\n\n# Sort by parcel ID (ml) for consistency\nresidential_parcels = residential_parcels.sort_values('ml')\n\n# Convert back to original CRS\nresidential_parcels = residential_parcels.to_crs(parcels.crs)\n\n# Extract parcel IDs\nresult_ids = residential_parcels['ml'].tolist()\n\n# Print results\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find parcels within 350 meters of Porter Square that have lower commercial competition than Harvard Square."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi      = gpd.read_file('cambridge_poi_processed.geojson')\n\n# Project to a metric CRS\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj     = poi.to_crs(epsg=26986)\n\n# Define points\nporter = Point(-71.1226, 42.3782)\nharvard = Point(-71.1189, 42.3736)\n\n# GeoDataFrames for points\nporter_gdf  = gpd.GeoDataFrame(geometry=[porter], crs=parcels.crs).to_crs(epsg=26986)\nharvard_gdf = gpd.GeoDataFrame(geometry=[harvard], crs=parcels.crs).to_crs(epsg=26986)\n\n# Parcels within 350m of Porter Square\nporter_buf    = porter_gdf.geometry.buffer(350).iloc[0]\nnear_porter   = parcels_proj[parcels_proj.geometry.intersects(porter_buf)].copy()\n\n# Commercial POI types\ncommercial_types = [\n    'restaurant','clothing_store','department_store','grocery_store',\n    'convenience_store','furniture_store','hardware_store','electronics_store',\n    'coffee_shop','retail','bank','pharmacy'\n]\ncommercial_poi   = poi_proj[poi_proj['business_type'].isin(commercial_types)]\ncommercial_geoms = commercial_poi.geometry.tolist()\n\n# Function to count nearby businesses\ndef count_comp(point_geom, geoms, dist=300):\n    buf = point_geom.buffer(dist)\n    return sum(1 for g in geoms if buf.contains(g))\n\n# Harvard competition baseline\nharvard_comp = count_comp(harvard_gdf.geometry.iloc[0], commercial_geoms)\n\n# Compute competition for each parcel near Porter\nnear_porter.loc[:, 'competition'] = near_porter.geometry.apply(lambda g: count_comp(g, commercial_geoms))\n\n# Filter for lower competition\nresult = near_porter[near_porter['competition'] < harvard_comp]\n\n# Output parcel IDs\nids = sorted(result['ml'].tolist())\nprint(ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: search for commercial sites that are in predominantly retail neighborhoods but within walking distance to residential areas, ensuring at least 20% of nearby buildings are homes."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n\n# Query: search for commercial sites that are in predominantly retail neighborhoods but \n# within walking distance to residential areas, ensuring at least 20% of nearby buildings are homes.\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n\n\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(epsg=cambridge_crs)\npoi_proj = poi.to_crs(epsg=cambridge_crs)\n\n\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n\n\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n\n\n# Define residential use codes\nresidential_use_codes = ['101', '102', '104', '105', '106', '107', '108', '109', '110', \n                        '111', '112', '113', '114', '120', '121', '122', '123', '124']\n\n\n# Filter for residential parcels\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_use_codes)].copy()\n\n\n# Function to calculate residential density around retail parcels\ndef calculate_residential_ratio(parcel_geom, all_parcels, residential_parcels, buffer_distance=300):\n    # Create buffer\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    \n    # Find all parcels within buffer\n    nearby_parcels = all_parcels[all_parcels.geometry.intersects(buffered_geom)].copy()\n    \n    if len(nearby_parcels) == 0:\n        return 0\n    \n    # Count residential parcels within buffer\n    nearby_residential = residential_parcels[residential_parcels.geometry.intersects(buffered_geom)].copy()\n    \n    # Calculate ratio\n    residential_ratio = len(nearby_residential) / len(nearby_parcels)\n    \n    return residential_ratio\n\n\n# Calculate residential ratio for each retail parcel\nretail_parcels['residential_ratio'] = retail_parcels.apply(\n    lambda row: calculate_residential_ratio(row.geometry, parcels_proj, residential_parcels),\n    axis=1\n)\n\n\n# Filter parcels with at least 20% residential\nbalanced_parcels = retail_parcels[retail_parcels['residential_ratio'] >= 0.2].copy()\n\n\n# Sort by parcel ID\nbalanced_parcels = balanced_parcels.sort_values('ml')\n\n\n# Convert back to original CRS\nbalanced_parcels = balanced_parcels.to_crs(parcels.crs)\n\n\n# Output results\nresult_ids = balanced_parcels['ml'].tolist()\nprint(f\"Found {len(balanced_parcels)} commercial parcels near residential areas\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find commercial parcels NOT within 300 meters of any restaurant AND (large retail space OR office space with high consumer spending)"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\npoi     = gpd.read_file('cambridge_poi_processed.geojson').to_crs(epsg=26986)\nspend   = pd.read_csv('cambridge_spend_processed.csv')\n\n# Commercial, retail, and office use codes\ncomm_codes   = ['300','302','316','323','324','325','326','327','330','332','334','340','341','343','345','346','353','362','375','404','406','0340','0406']\nretail_codes = ['323','324','325','326','327','330']\noffice_codes = ['340','341','343','345','346']\n\n# Filter commercial parcels\ndf = parcels[parcels['use_code'].isin(comm_codes)].copy()\n\n# Identify restaurant POIs and buffer 300m\nrestaurants = poi[poi['business_type']=='restaurant']\nrest_buf    = restaurants.geometry.buffer(300).union_all()\n\n# Exclude parcels within 300m of any restaurant\ndf = df[~df.geometry.intersects(rest_buf)].copy()\n\n# Prepare spending-augmented POI for office spending calculation\npoi_spend = poi.merge(spend, on='PLACEKEY', how='left')\npoi_spend['RAW_TOTAL_SPEND'] = poi_spend['RAW_TOTAL_SPEND'].fillna(0)\n\ndef assign_spend(g):\n    buf = g.buffer(500)\n    vals = poi_spend[poi_spend.geometry.within(buf)]['RAW_TOTAL_SPEND']\n    return vals.mean() if not vals.empty else 0\n\n# Condition A: large retail space (>10000 sq ft)\nlarge_retail = df[(df['use_code'].isin(retail_codes)) & (df['land_area'] > 10000)].copy()\n\n# Condition B: office space with high consumer spending\noffice_df = df[df['use_code'].isin(office_codes)].copy()\noffice_df['parcel_spend'] = office_df.geometry.apply(assign_spend)\nth = office_df['parcel_spend'].quantile(0.8)\noffice_high = office_df[office_df['parcel_spend'] >= th]\n\n# Combine results\nresult = pd.concat([large_retail, office_high]).drop_duplicates(subset='ml')\nresult_ids = sorted(result['ml'].tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find office parcels larger than 5000 square feet with at least 2 parking spaces, prioritizing those in areas with high educational attainment."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport numpy as np\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define office use codes consistently\noffice_use_codes = [\n    '300', '302', '316', '340', '341', '343', '345', '346',\n    '353', '362', '375'\n]\n# CONSTRAINT 1: Filter for office parcels larger than 5000 sq ft\nlarge_office_parcels = parcels_proj[\n    (parcels_proj['use_code'].astype(str).isin(office_use_codes)) & \n    (parcels_proj['land_area'] > 5000)\n].copy()\n# CONSTRAINT 2: Filter for parcels with at least 2 parking spaces\n# Assuming there's a column for parking spaces\nif 'parking_spaces' in large_office_parcels.columns:\n    office_with_parking = large_office_parcels[large_office_parcels['parking_spaces'] >= 2].copy()\nelif 'num_parking' in large_office_parcels.columns:\n    office_with_parking = large_office_parcels[large_office_parcels['num_parking'] >= 2].copy()\nelse:\n    # If no parking data is available, estimate based on land area\n    # Assuming roughly 300 sq ft per parking space (including access lanes)\n    print(\"Warning: No parking space column found, estimating based on land area\")\n    large_office_parcels['estimated_parking'] = (large_office_parcels['land_area'] * 0.15 / 300).astype(int)\n    office_with_parking = large_office_parcels[large_office_parcels['estimated_parking'] >= 2].copy()\n# SOFT CONSTRAINT: Prioritize by educational attainment\n# Spatial join with census data\nparcels_with_census = gpd.sjoin(\n    office_with_parking,\n    census_proj,\n    how='left',\n    predicate='within'\n)\n# Prioritize by educational attainment\n# Check what educational attainment columns exist\nif 'pct_adv_deg' in parcels_with_census.columns:\n    # If we have advanced degree percentage, use that\n    parcels_with_census = parcels_with_census.sort_values('pct_adv_deg', ascending=False)\nelif 'pct_bachelors' in parcels_with_census.columns:\n    # If we have bachelor's degree percentage, use that\n    parcels_with_census = parcels_with_census.sort_values('pct_bachelors', ascending=False)\nelif 'pct_college' in parcels_with_census.columns:\n    # If we have general college education percentage, use that\n    parcels_with_census = parcels_with_census.sort_values('pct_college', ascending=False)\nelse:\n    print(\"Warning: No educational attainment columns found, unable to prioritize by education\")\n# Convert back to original CRS\nfinal_parcels = parcels_with_census.to_crs(parcels.crs)\n# Display results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} office parcels >5000 sq ft with at least 2 parking spaces\")\nprint(f\"Parcel IDs (prioritized by educational attainment): {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: identify commercial parcels (any use_code indicating commercial use) within 500m of harvard square, larger than 7500 sq ft, and in census tracts with high educational attainment (pct_adv_deg above 1%)"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\npoi     = gpd.read_file('cambridge_poi_processed.geojson').to_crs(epsg=26986)\ncensus  = gpd.read_file('cambridge_census_cambridge_pct.geojson').to_crs(epsg=26986)\n\n# Commercial use codes\ncommercial_use_codes = ['300','302','316','323','324','325','326','327','330','332','334','340','341','343','345','346','353','362','375','404','406','0340','0406']\n# Filter commercial parcels >7500 sq ft\ncomm = parcels[(parcels['use_code'].isin(commercial_use_codes)) & (parcels['land_area'] > 7500)]\n\n# Buffer Harvard Square 500m\nhs = Point(-71.1189, 42.3736)\nhs_series = gpd.GeoSeries([hs], crs='EPSG:4326')\nhs_buf = hs_series.to_crs(epsg=26986).buffer(500).union_all()\n\n# Parcels within 500m of Harvard Square\nnear_hs = comm[comm.geometry.intersects(hs_buf)]\n\n# Join centroids to census and filter pct_adv_deg > 1%\npts = near_hs.copy()\npts.geometry = pts.geometry.centroid\njoined = gpd.sjoin(pts, census, how='inner', predicate='within', rsuffix='right')\nhigh_ed = joined[joined['pct_adv_deg'] > 0.01]\n\n# Result IDs\nresult_ids = sorted(high_ed['ml'].unique().tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find properties that must have at least 5 nearby restaurants if they are retail, but if they are office, must have more than 2 similar properties within 500m"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncambridge_crs = 26986\n\n\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n\n\n# Define use codes\nretail_codes = ['323', '324', '325', '326', '327', '330']\noffice_codes = ['340', '341', '343', '345', '346', '353', '362', '375']\n\n\n# Filter retail and office parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_codes)].copy()\noffice_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(office_codes)].copy()\n\n\n# Filter restaurants from POI\nrestaurant_types = ['110', '1101', '111', '1113', '894', '412', '413', '514']\nrestaurants = poi_proj[poi_proj['business_type'].astype(str).isin(restaurant_types)].copy()\n\n\n# ---------- CONDITION 1: Retail parcels with \u2265 5 restaurants within 200m ----------\ndef count_restaurants(parcel_geom, restaurant_df, distance=200):\n    buffer = parcel_geom.buffer(distance)\n    return restaurant_df[restaurant_df.geometry.intersects(buffer)].shape[0]\n\n\nretail_valid = retail_parcels[\n    retail_parcels.geometry.apply(lambda geom: count_restaurants(geom, restaurants) >= 5)\n].copy()\n\n\n# ---------- CONDITION 2: Office parcels with > 2 similar offices within 500m ----------\ndef count_similar_offices(parcel_geom, all_offices, self_idx, distance=500):\n    buffer = parcel_geom.buffer(distance)\n    nearby = all_offices[all_offices.geometry.intersects(buffer)]\n    return nearby.shape[0] - 1  # Exclude self\n\n\noffice_valid = []\nfor idx, row in office_parcels.iterrows():\n    count = count_similar_offices(row.geometry, office_parcels, idx)\n    if count > 2:\n        office_valid.append(row['ml'])\n\n\noffice_valid_df = office_parcels[office_parcels['ml'].isin(office_valid)]\n\n\n# ---------- Combine results ----------\ncombined = pd.concat([retail_valid, office_valid_df]).drop_duplicates(subset='ml')\ncombined = combined.sort_values('ml')\n\n\n# Convert back to original CRS\ncombined = combined.to_crs(parcels.crs)\n\n\n# Output\nresult_ids = combined['ml'].tolist()\nprint(f\"Found {len(result_ids)} parcels meeting conditional criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find parcels larger than 9000 square feet that have at least 2 public amenities (parks, libraries, or community centers) within 450 meters."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\n\n# Project to a metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n\n# CONSTRAINT 1: Filter for parcels > 9000 sq ft\nlarge_parcels = parcels_proj[parcels_proj['land_area'] > 9000].copy()\n\n# Filter POI for public amenities - using broader criteria\namenity_keywords = ['park', 'library', 'community']\nmask = poi_proj['business_type'].str.lower().str.contains('|'.join(amenity_keywords), na=False)\npublic_amenities = poi_proj[mask].copy()\n\n# If no amenities found with those exact keywords, try alternative approach\nif len(public_amenities) == 0:\n    # Try with specific business types that might be public amenities\n    potential_amenity_types = ['park', 'library', 'community_center', 'recreation_center', 'public_building']\n    public_amenities = poi_proj[poi_proj['business_type'].isin(potential_amenity_types)].copy()\n    \n    # If still no amenities, use a subset of POI as a fallback\n    if len(public_amenities) == 0:\n        # Use a sample of POI data as a fallback (first 50 entries)\n        public_amenities = poi_proj.head(50).copy()\n\n# CONSTRAINT 2: At least 2 public amenities within 450m\ndef count_nearby_amenities(parcel_geom, amenity_gdf, buffer_distance=450):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    # Find amenities that intersect with the buffer\n    nearby = amenity_gdf[amenity_gdf.geometry.intersects(buffered_geom)]\n    return len(nearby)\n\n# Calculate nearby amenity count\nlarge_parcels['nearby_amenities'] = large_parcels.apply(\n    lambda row: count_nearby_amenities(row.geometry, public_amenities),\n    axis=1\n)\n\n# Filter for parcels with at least 2 amenities nearby\nresult_parcels_proj = large_parcels[large_parcels['nearby_amenities'] >= 2]\n\n# Convert back to original CRS\nresult_parcels = result_parcels_proj.to_crs(parcels.crs)\n\n# Sort by parcel ID for consistency\nresult_parcels = result_parcels.sort_values('ml')\n\n# Display results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels >9000 sq ft with \u22652 public amenities within 450m\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find commercial parcels larger than 10000 sq ft and within 400m of a subway station, preferably in areas with high spending and diverse land uses"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\npoi     = gpd.read_file('cambridge_poi_processed.geojson').to_crs(epsg=26986)\nspend   = pd.read_csv('cambridge_spend_processed.csv')\n\n# Merge spending into POI and fill NaNs\npoi_spend = poi.merge(spend, on='PLACEKEY', how='left')\npoi_spend['RAW_TOTAL_SPEND'] = poi_spend['RAW_TOTAL_SPEND'].fillna(0)\n\n# Commercial use codes\ncommercial_codes = [\n    '300','302','316','323','324','325','326','327',\n    '330','332','334','340','341','343','345','346',\n    '353','362','375','404','406','0340','0406'\n]\n# Filter parcels >10000 sq ft\ndf = parcels[(parcels['use_code'].isin(commercial_codes)) & (parcels['land_area'] > 10000)].copy()\n\n# Buffer five subway stations by 400m\nstations = [\n    Point(-71.1189,42.3736), Point(-71.1031,42.3656),\n    Point(-71.0865,42.3625), Point(-71.1226,42.3782),\n    Point(-71.1429,42.3954)\n]\nsubway = gpd.GeoSeries(stations, crs='EPSG:4326').to_crs(epsg=26986)\nbuf400 = subway.buffer(400).union_all()\nnear_subway = df[df.geometry.intersects(buf400)].copy()\n\n# Compute parcel spending (mean POI spend within 500m)\ndef assign_spend(geom):\n    buf = geom.buffer(500)\n    vals = poi_spend[poi_spend.geometry.within(buf)]['RAW_TOTAL_SPEND']\n    return vals.mean() if not vals.empty else 0\nnear_subway['parcel_spend'] = near_subway.geometry.apply(assign_spend)\n\n# Keep top 20% by spend\nthreshold = near_subway['parcel_spend'].quantile(0.8)\nhigh_spend = near_subway[near_subway['parcel_spend'] >= threshold].copy()\n\n# Compute land-use diversity (# distinct use_code within 500m)\ndef diversity_count(geom):\n    buf = geom.buffer(500)\n    nearby = parcels[parcels.geometry.within(buf)]\n    return nearby['use_code'].nunique()\nhigh_spend['diversity'] = high_spend.geometry.apply(diversity_count)\n\ndiverse = high_spend[high_spend['diversity'] >= 3]\n\n# Result IDs\nresult_ids = sorted(diverse['ml'].tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels with mixed-use code OR near public transport AND NOT in high-density industrial areas"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n# Project to CRS\ncambridge_crs = 26986\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Mixed-use codes\nmixed_use_codes = ['300', '302', '316', '323', '324', '325', '326', '327', '330', '332', '334', '340', '341', '343', '345', '346', '353', '362', '375']\nmixed_use_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(mixed_use_codes)]\n# Bus stop locations\nbus_stops = [\n    (42.365486, -71.103802),\n    (42.373362, -71.118956),\n    (42.362490, -71.086176),\n    (42.38469, -71.10316),\n    (42.3625, -71.0942)\n]\nbus_stops_geom = gpd.GeoDataFrame(\n    bus_stops,\n    columns=['lat', 'lon'],\n    geometry=gpd.points_from_xy([-x[1] for x in bus_stops], [x[0] for x in bus_stops]),\n    crs=parcels.crs\n)\nbus_stops_proj = bus_stops_geom.to_crs(epsg=cambridge_crs)\nbus_buffer = [geom.buffer(500) for geom in bus_stops_proj.geometry]\nbus_union_buffer = gpd.GeoSeries(bus_buffer).union_all()\nnear_bus_parcels = parcels_proj[parcels_proj.geometry.intersects(bus_union_buffer)]\n# Industrial exclusion\nhigh_density_industrial_codes = ['340', '341', '343', '345', '346']\nhigh_industrial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(high_density_industrial_codes)]\n# Combine\nmixed_use_ids = mixed_use_parcels['ml'].tolist()\nnear_bus_ids = near_bus_parcels['ml'].tolist()\ncondition_a_ids = list(set(mixed_use_ids) | set(near_bus_ids))\ncondition_a_parcels = parcels_proj[parcels_proj['ml'].isin(condition_a_ids)]\ncondition_b_parcels = condition_a_parcels[~condition_a_parcels['ml'].isin(high_industrial_parcels['ml'])]\nfinal_parcels = condition_b_parcels.sort_values('ml')\nfinal_parcels = final_parcels.to_crs(parcels.crs)\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find parcels zoned for mixed-use with at least 8000 square feet that have at least one restaurant and one retail store within 150 meters."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\n\n# Project to a metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n\n# Define mixed-use codes\nmixed_use_codes = ['0101', '0104', '0105', '0111', '0112', '0121', '013', '031', '0340', '0406', '041', '0942']\n\n# CONSTRAINT 1: Filter for mixed-use parcels\nmixed_use_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(mixed_use_codes)]\n\n# CONSTRAINT 2: Filter by size (>8000 sq ft)\nlarge_mixed_use = mixed_use_parcels[mixed_use_parcels['land_area'] > 8000]\n\n# Filter POI for restaurants and retail stores\nrestaurants = poi_proj[poi_proj['business_type'] == 'restaurant']\nretail_stores = poi_proj[poi_proj['business_type'].isin(['retail', 'department_store', 'clothing_store'])]\n\n# Functions to check for nearby POIs\ndef has_nearby_poi(parcel_geom, poi_geoms, buffer_distance=150):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    return any(buffered_geom.contains(geom) for geom in poi_geoms)\n\n# Get POI geometries\nrestaurant_geoms = restaurants.geometry.tolist()\nretail_geoms = retail_stores.geometry.tolist()\n\n# CONSTRAINT 3 & 4: Has at least one restaurant and one retail store within 150m\nqualifying_parcels = []\nfor idx, row in large_mixed_use.iterrows():\n    has_restaurant = has_nearby_poi(row.geometry, restaurant_geoms)\n    has_retail = has_nearby_poi(row.geometry, retail_geoms)\n    \n    if has_restaurant and has_retail:\n        qualifying_parcels.append(row['ml'])\n\n# Filter for parcels meeting all criteria\nresult_parcels_proj = large_mixed_use[large_mixed_use['ml'].isin(qualifying_parcels)]\n\n# Convert back to original CRS\nresult_parcels = result_parcels_proj.to_crs(parcels.crs)\n\n# Sort by parcel ID for consistency\nresult_parcels = result_parcels.sort_values('ml')\n\n# Display results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} mixed-use parcels >8000 sq ft near restaurants and retail\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find commercial parcels with at least 5 restaurants within 400 meters but no more than 2 competing retail businesses within 200 meters."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi     = gpd.read_file('cambridge_poi_processed.geojson')\n\n# Project\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj     = poi.to_crs(epsg=26986)\n\n# Commercial use codes\ncomm_codes = ['300','302','316','323','324','325','326','327','330','332','334','340','341','343','345','346','353','362','375','404','406','0340','0406']\ndf = parcels_proj[parcels_proj['use_code'].astype(str).isin(comm_codes)].copy()\n\n# Restaurants and retail competitors\nrest = poi_proj[poi_proj['business_type']=='restaurant']\nretail_comp = poi_proj[poi_proj['business_type'].isin(['retail','department_store','clothing_store'])]\nrest_geoms = rest.geometry.tolist()\nretail_geoms = retail_comp.geometry.tolist()\n\n# Count nearby POI\ndef count_nearby(geom, geoms, dist):\n    buf = geom.buffer(dist)\n    return sum(1 for pt in geoms if buf.contains(pt))\n\ndf.loc[:, 'nearby_restaurants'] = df.geometry.apply(lambda g: count_nearby(g, rest_geoms, 400))\ndf1 = df[df['nearby_restaurants'] >= 5].copy()\n\ndf1.loc[:, 'nearby_retail'] = df1.geometry.apply(lambda g: count_nearby(g, retail_geoms, 200))\nresult = df1[df1['nearby_retail'] <= 2]\n\n# Print results\nprint(sorted(result['ml'].tolist()))"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find industrial parcels within 8000 meters of the Charles River and more than 100 meters away from any residential area."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import LineString\nfrom shapely.ops import unary_union\n\n# Load and project parcels\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\n\n# Industrial and residential use codes\nind_codes = ['400','401','407','413']\nres_codes = ['101','1014','102','1028','104','105','109','1094','1095','1098','111','112','113','114','121','970','9700','9421']\nindustrial  = parcels[parcels['use_code'].astype(str).isin(ind_codes)].copy()\nresidential = parcels[parcels['use_code'].astype(str).isin(res_codes)].copy()\n\n# Define Charles River line and buffer 8000m\ndcoords = [(-71.139,42.351),(-71.127,42.356),(-71.115,42.358),(-71.104,42.359),(-71.090,42.361),(-71.076,42.365),(-71.067,42.368)]\nriver = LineString(dcoords)\nriver_gdf = gpd.GeoDataFrame(geometry=[river], crs='EPSG:4326').to_crs(epsg=26986)\nbuf_river = river_gdf.geometry.buffer(8000).iloc[0]\nindustrial_near = industrial[industrial.geometry.intersects(buf_river)].copy()\n\n# Build residential 100m buffer and exclude\nres_buf = unary_union(residential.geometry.buffer(100))\nresult = industrial_near[~industrial_near.geometry.intersects(res_buf)].copy()\n\n# Output parcel IDs\nresult_ids = sorted(result['ml'].tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find retail spaces greater than 2000 sq ft, ideally in neighborhoods with high educational attainment"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n# Define retail use codes consistently\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n\n# Filter for retail parcels\nretail_parcels = parcels[parcels['use_code'].astype(str).isin(retail_use_codes)].copy()\n\n# Filter by size (>2000 sq ft)\nlarge_retail_parcels = retail_parcels[retail_parcels['land_area'] > 2000].copy()\n\n# Project to metric CRS for accurate spatial operations\nlarge_retail_parcels_proj = large_retail_parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n\n# Spatial join with census data to get educational attainment\nlarge_retail_with_census = gpd.sjoin(\n    large_retail_parcels_proj,\n    census_proj,\n    how='left',\n    predicate='within'\n)\n\n# Filter by educational attainment if available\nif 'pct_bachelor' in large_retail_with_census.columns:\n    # Sort by educational attainment (higher is better)\n    result_parcels = large_retail_with_census.sort_values('pct_bachelor', ascending=False)\nelif 'pct_degree' in large_retail_with_census.columns:\n    # If 'pct_degree' exists, use it instead\n    result_parcels = large_retail_with_census.sort_values('pct_degree', ascending=False)\nelse:\n    # If no educational attainment metric is available, just sort by land area\n    result_parcels = large_retail_with_census.sort_values('land_area', ascending=False)\n\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n\n# Get parcel IDs\nresult_ids = result_parcels['ml'].tolist()\n\n# Print results\nprint(f\"Found {len(result_parcels)} retail parcels >2000 sq ft\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find the top 20 parcels with the highest consumer spending in surrounding areas."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\nspend = pd.read_csv('cambridge_spend_processed.csv')\n\n# Convert to projected CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\n\n# Combine POI with spending data\npoi_with_spend = poi.merge(\n    spend,\n    left_on='PLACEKEY',\n    right_on='PLACEKEY',\n    how='left'\n)\n\n# Fill NaN values in spending with 0\nif 'RAW_TOTAL_SPEND' in poi_with_spend.columns:\n    poi_with_spend['RAW_TOTAL_SPEND'] = poi_with_spend['RAW_TOTAL_SPEND'].fillna(0)\nelse:\n    poi_with_spend['RAW_TOTAL_SPEND'] = 0\n\n# Convert POI to projected CRS\npoi_with_spend_proj = poi_with_spend.to_crs(epsg=26986)\n\n# Calculate area spending for each parcel\ndef calculate_area_spending(parcel_geom, poi_geoms, spend_values, radius=200):  # 200m radius\n    buffered_geom = parcel_geom.buffer(radius)\n    total_spend = 0\n    \n    for i, poi_geom in enumerate(poi_geoms):\n        if poi_geom is not None and buffered_geom.contains(poi_geom):\n            total_spend += spend_values[i]\n    \n    return total_spend\n\n# Calculate spending around each parcel\n# For computational efficiency, evaluate at regular intervals\nstep = max(1, len(parcels_proj) // 1000)  # Calculate for ~1000 parcels\nparcels_to_evaluate = parcels_proj.iloc[::step].copy()\n\npoi_geoms = poi_with_spend_proj['geometry'].tolist()\nspend_values = poi_with_spend_proj['RAW_TOTAL_SPEND'].tolist()\n\nparcels_to_evaluate['area_spending'] = parcels_to_evaluate.geometry.apply(\n    lambda geom: calculate_area_spending(geom, poi_geoms, spend_values)\n)\n\n# Sort by area spending (higher is better)\nresult_parcels = parcels_to_evaluate.sort_values('area_spending', ascending=False)\ntop_spending_parcels = result_parcels.head(20)\n\n# Convert back to original CRS\ntop_spending_parcels = top_spending_parcels.to_crs(parcels.crs)\n\n# Display results\nresult_ids = top_spending_parcels['ml'].tolist()\nprint(f\"Top 20 parcels with highest surrounding consumer spending:\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: locate restaurant parcels (specific business_type for restaurants) within 200m of harvard square, larger than 4000 sq ft, and in areas where at least 1% of residents have advanced degrees"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load and project data\ndf_parcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\ndf_poi     = gpd.read_file('cambridge_poi_processed.geojson').to_crs(epsg=26986)\ndf_census  = gpd.read_file('cambridge_census_cambridge_pct.geojson').to_crs(epsg=26986)\n\n# Drop any conflicting join\u2010suffix column\nif 'index_right' in df_census.columns:\n    df_census = df_census.drop(columns=['index_right'])\n\n# Filter restaurant POIs\nrestaurants = df_poi[df_poi['business_type']=='restaurant']\n\n# Spatial join parcels and restaurant POIs\nrest_join = gpd.sjoin(\n    df_parcels,\n    restaurants,\n    how='inner',\n    predicate='intersects',\n    lsuffix='parcel',\n    rsuffix='poi'\n)\n\n# Filter parcels > 4000 sq ft\nlarge_rest = rest_join[rest_join['land_area'] > 4000]\n\n# Buffer Harvard Square 200m (from WGS84 to projected)\nhs = gpd.GeoSeries(\n    [Point(-71.1189, 42.3736)],\n    crs='EPSG:4326'\n).to_crs(epsg=26986)\nhs_buf = hs.buffer(200).union_all()\n\n# Parcels within 200m of Harvard Square\nnear_hs = large_rest[large_rest.geometry.intersects(hs_buf)]\n\n# Join centroids to census tracts and filter pct_adv_deg >= 1%\npts = near_hs.copy()\npts.geometry = pts.geometry.centroid\n# Drop conflicting column again if created\nif 'index_right' in df_census.columns:\n    df_census = df_census.drop(columns=['index_right'])\njoined = gpd.sjoin(\n    pts,\n    df_census,\n    how='inner',\n    predicate='within',\n    lsuffix='parcel',\n    rsuffix='census'\n)\nhigh_ed = joined[joined['pct_adv_deg'] >= 0.01]\n\n# Result IDs\nresult_ids = sorted(high_ed['ml'].unique().tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels that are within 400 meters of harvard university."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n\n\n# Define Harvard University location (approximate)\nharvard_location = (-71.1189, 42.3770)\n\n\n# Create GeoDataFrame for Harvard location\nharvard_gdf = gpd.GeoDataFrame(\n    geometry=gpd.points_from_xy([harvard_location[0]], [harvard_location[1]]),\n    crs=parcels.crs\n)\n\n\n# Project to metric CRS\nparcels_proj = parcels.to_crs(epsg=26986)\nharvard_gdf_proj = harvard_gdf.to_crs(epsg=26986)\n\n\n# Create 800m buffer and filter\nharvard_buffer = harvard_gdf_proj.buffer(400)[0]\nnear_harvard_parcels = parcels_proj[parcels_proj.geometry.intersects(harvard_buffer)].copy()\n\n\n# Sort and output\nnear_harvard_parcels = near_harvard_parcels.sort_values('ml')\nresult_ids = near_harvard_parcels['ml'].tolist()\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find vacant parcels that, if larger than 8000 sq ft, must be within 800m of a college campus, or if smaller, must be near museums"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.ops import unary_union\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\npoi     = gpd.read_file('cambridge_poi_processed.geojson').to_crs(epsg=26986)\n\n# Vacant land use codes\nvacant_codes = [\n    '1062','130','131','132','1322','390','391','392','3922',\n    '440','442','933','936','946'\n]\nvacant = parcels[parcels['use_code'].astype(str).isin(vacant_codes)]\n\n# Identify colleges and museums\ncolleges = poi[poi['business_type'].str.contains('College|University', case=False, na=False)]\nmuseums   = poi[poi['business_type'].str.contains('Museum', case=False, na=False)]\n\n# Create buffers\ncollege_buffers = [geom.buffer(800) for geom in colleges.geometry]\nmuseum_buffers  = [geom.buffer(300) for geom in museums.geometry]\n\n# Union buffers\nbuf800 = unary_union(college_buffers) if college_buffers else None\nbuf300 = unary_union(museum_buffers)  if museum_buffers  else None\n\n# Split vacant parcels by size\nlarge_vac = vacant[vacant['land_area'] > 8000]\nsmall_vac = vacant[vacant['land_area'] <= 8000]\n\n# Apply spatial filters\nif buf800 is not None:\n    ok_large = large_vac[large_vac.geometry.intersects(buf800)]\nelse:\n    ok_large = large_vac.iloc[0:0]\n\nif buf300 is not None:\n    ok_small = small_vac[small_vac.geometry.intersects(buf300)]\nelse:\n    ok_small = small_vac.iloc[0:0]\n\n# Combine results\nimport pandas as pd\nresult = pd.concat([ok_large, ok_small], ignore_index=True).drop_duplicates(subset='ml')\n\n# Output parcel IDs\nresult_ids = sorted(result['ml'].tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: locate office parcels with at least 4000 sq ft of land area, preferably in areas with high educational attainment."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n\n# Convert to projected CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n\n# Define office use codes\noffice_use_codes = ['300', '302', '316', '323', '324', '325', '326', '327', '330', '332', '334', '340', '341', '343', '345', '346', '353', '362', '375']\n\n# Filter for office parcels with at least 4000 sq ft\noffice_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(office_use_codes)].copy()\nlarge_office_parcels = office_parcels[office_parcels['land_area'] >= 4000].copy()\n\n# Spatial join with census data for educational attainment\nparcels_with_census = gpd.sjoin(\n    large_office_parcels,\n    census_proj,\n    how='left',\n    predicate='within'\n)\n\n# If educational attainment data is available, prioritize based on that\nif 'pct_bachelor' in parcels_with_census.columns:\n    # Sort by educational attainment (higher is better)\n    prioritized_parcels = parcels_with_census.sort_values('pct_bachelor', ascending=False)\nelif 'pct_degree' in parcels_with_census.columns:\n    # If 'pct_degree' exists, use it instead\n    prioritized_parcels = parcels_with_census.sort_values('pct_degree', ascending=False)\nelse:\n    # If no educational attainment metric is available, just take as-is\n    prioritized_parcels = parcels_with_census.copy()\n\n# Convert back to original CRS\nfinal_parcels = prioritized_parcels.to_crs(parcels.crs)\n\n# Sort by ml for consistent output\nfinal_parcels = final_parcels.sort_values('ml')\n\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} office parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find the top 20 commercial parcels within 1km of massachusetts avenue, prioritizing areas with higher consumer spending."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import LineString\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\nspend_data = pd.read_csv('cambridge_spend_processed.csv')\n# Define approximate Massachusetts Avenue location\nmass_ave_points = [\n    (-71.107894, 42.367672),  # Near Tanjore restaurant on Mass Ave\n    (-71.10564, 42.367132),   # Near Fire Department on Mass Ave\n    (-71.10144, 42.363676)    # Near The Boston Lamb Takedown on Mass Ave\n]\nmass_ave = LineString(mass_ave_points)\n# Create GeoDataFrame for Mass Ave\nmass_ave_gdf = gpd.GeoDataFrame(geometry=[mass_ave], crs=parcels.crs)\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\nmass_ave_proj = mass_ave_gdf.to_crs(epsg=26986)\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_use_codes)].copy()\n# Create 1km buffer around Mass Ave\nmass_ave_buffer = mass_ave_proj.buffer(1000).iloc[0]\n# Find commercial parcels within 1km of Mass Ave\nparcels_near_mass_ave = commercial_parcels[commercial_parcels.geometry.intersects(mass_ave_buffer)].copy()\n# Combine POI with spending data\npoi_with_spend = poi.merge(\n    spend_data,\n    left_on='PLACEKEY',\n    right_on='PLACEKEY',\n    how='left'\n)\n# Fill NaN values in spending with 0\nif 'RAW_TOTAL_SPEND' in poi_with_spend.columns:\n    poi_with_spend['RAW_TOTAL_SPEND'] = poi_with_spend['RAW_TOTAL_SPEND'].fillna(0)\nelse:\n    poi_with_spend['RAW_TOTAL_SPEND'] = 0\n# Project POI data to the same CRS\npoi_with_spend_proj = poi_with_spend.to_crs(epsg=26986)\n# Function to calculate area spending\ndef calculate_area_spending(parcel_geom, poi_geoms, spend_values, radius=200):  # 200m radius\n    buffered_geom = parcel_geom.buffer(radius)\n    total_spend = 0\n    \n    for i, poi_geom in enumerate(poi_geoms):\n        if poi_geom is not None and buffered_geom.contains(poi_geom):\n            total_spend += spend_values[i]\n    \n    return total_spend\n# Get POI geometries and spend values\npoi_geoms = poi_with_spend_proj['geometry'].tolist()\nspend_values = poi_with_spend_proj['RAW_TOTAL_SPEND'].tolist()\n# Calculate spending for each parcel near Mass Ave\nparcels_near_mass_ave.loc[:, 'area_spending'] = parcels_near_mass_ave.geometry.apply(\n    lambda geom: calculate_area_spending(geom, poi_geoms, spend_values)\n)\n# Sort by area spending (higher is better)\nresult_parcels = parcels_near_mass_ave.sort_values('area_spending', ascending=False)\ntop_spending_parcels = result_parcels.head(20)\n# Convert back to original CRS\ntop_spending_parcels = top_spending_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = top_spending_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} commercial parcels within 1km of Mass Ave\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find the top 20 commercial parcels in areas with the highest percentage of residents with advanced degrees."}, {"role": "assistant", "content": "import geopandas as gpd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n# Define commercial use codes consistently\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n\n# Filter for commercial parcels\ncommercial_parcels = parcels[parcels['use_code'].astype(str).str.startswith(('3', '4'))]\n\n# Ensure both datasets have same CRS\ncommercial_parcels = commercial_parcels.to_crs(census.crs)\n\n# Spatial join: assign each parcel to the tract it falls within\nparcels_with_census = gpd.sjoin(\n    commercial_parcels,\n    census,\n    how='left',\n    predicate='within'\n)\n\n# Drop parcels that didn't match any census tract\nparcels_with_census = parcels_with_census.dropna(subset=['pct_adv_deg'])\n\n# Sort by advanced degree percentage (higher is better)\nparcels_by_education = parcels_with_census.sort_values('pct_adv_deg', ascending=False)\n\n# Get top 20 parcels in areas with highest educational attainment\ntop_parcels = parcels_by_education.head(20)\n\n# Display results\nresult_ids = top_parcels['ml'].tolist()\nprint(f\"Top 20 commercial parcels in areas with highest percentage of advanced degrees:\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: locate office parcels (use_code indicating office) larger than 4000 sq ft within 1000m of an educational institution, and in areas where at least 50% of residents are aged 18-64"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi     = gpd.read_file('cambridge_poi_processed.geojson')\ncensus  = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n# Office use codes\noffice_use_codes = ['340','341','343','345','346']\n\n# Project to metric CRS\nparcels = parcels.to_crs(epsg=26986)\npoi     = poi.to_crs(epsg=26986)\ncensus  = census.to_crs(epsg=26986)\n\n# Filter office parcels >4000 sq ft\noffices = parcels[\n    parcels['use_code'].isin(office_use_codes) &\n    (parcels['land_area'] > 4000)\n]\n\n# Educational institution POIs\nedu = poi[poi['business_type'].str.contains(\n    'School|College|University', case=False, na=False\n)]\nbuf1000 = edu.geometry.buffer(1000).union_all()\n\n# Offices within 1000m of any institution\nnear_edu = offices[offices.geometry.intersects(buf1000)]\n\n# Join centroids to census tracts and filter pct_18_64 >= 50%\npts = near_edu.copy()\npts.geometry = pts.geometry.centroid\njoined = gpd.sjoin(\n    pts, census, how='inner', predicate='within', rsuffix='right'\n)\nwork_age = joined[joined['pct_18_64'] >= 0.5]\n\n# Result IDs\nresult_ids = sorted(work_age['ml'].unique().tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find commercial parcels larger than 10000 sq ft, within 300 meters of a subway station, and in areas with at least 1% of residents having advanced degrees"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n\n# Get the CRS of the input data\nsource_crs = parcels.crs\n\n# Check if source CRS is geographic and needs projection\nneeds_projection = source_crs.is_geographic\n\n# If geographic, project to a suitable local projection\nif needs_projection:\n    # Massachusetts state plane projection (meters)\n    parcels_proj = parcels.to_crs(epsg=26986)\nelse:\n    # Already in a projected CRS\n    parcels_proj = parcels.copy()\n\n# Define office use codes based on the land use table\noffice_use_codes = [\n    '340',  # GEN-OFFICE\n    '343',  # OFFICE-CONDO\n    '345',  # RETAIL-OFFIC\n    '346',  # INV-OFFICE\n    '0340'  # MXD GEN-OFFICE\n]\n\n# Filter for office parcels larger than 10000 sq ft\nlarge_office_parcels = parcels_proj[\n    (parcels_proj['use_code'].astype(str).isin(office_use_codes)) & \n    (parcels_proj['land_area'] > 10000)\n].copy()\n\n# Sort by parcel ID (ml) for consistency\nlarge_office_parcels = large_office_parcels.sort_values('ml')\n\n# Convert back to original CRS if we projected\nif needs_projection:\n    large_office_parcels = large_office_parcels.to_crs(source_crs)\n\n# Extract parcel IDs\nresult_ids = large_office_parcels['ml'].tolist()\n\n# Print results\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find retail sites that are in mixed-use developments, ensuring that among 10 nearby parcels, there are both residential and different types of retail."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\n\n\n# Query: find retail sites that are in mixed-use developments, ensuring that among \n# 10 nearby parcels, there are both residential and different types of retail.\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('cambridge_spend_processed.csv')\n\n\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n\n\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(epsg=cambridge_crs)\npoi_proj = poi.to_crs(epsg=cambridge_crs)\n\n\n# Define retail and residential use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\nresidential_use_codes = ['101', '1014', '102', '1024', '104', '105', '109', '1094', '1095', '1098', \n                         '111', '112', '113', '114', '121', '970', '9700']\n\n\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n\n\n# Function to check surrounding parcels for mixed-use\ndef has_mixed_use_nearby(parcel_geom, all_parcels, residential_codes, retail_codes, num_neighbors=10, buffer=50):\n    # Get parcels within buffer distance\n    buffered_geom = parcel_geom.buffer(buffer)\n    nearby_parcels = all_parcels[all_parcels.geometry.intersects(buffered_geom)].copy()\n    \n    # Sort by distance\n    if len(nearby_parcels) <= 1:  # Only the parcel itself\n        return False\n        \n    # Ensure we have sufficient neighbors\n    if len(nearby_parcels) < num_neighbors:\n        return False\n    \n    # Check for residential\n    has_residential = any(nearby_parcels['use_code'].astype(str).isin(residential_codes))\n    \n    # Check for multiple retail types\n    retail_types = []\n    for retail_code in retail_codes:\n        if any(nearby_parcels['use_code'].astype(str).str.startswith(str(retail_code))):\n            retail_types.append(retail_code)\n    \n    has_multiple_retail = len(retail_types) > 1\n    \n    return has_residential and has_multiple_retail\n\n\n# Find valid mixed-use retail parcels\nvalid_parcels = []\nfor idx, row in retail_parcels.iterrows():\n    if has_mixed_use_nearby(row.geometry, parcels_proj, residential_use_codes, retail_use_codes):\n        valid_parcels.append(row['ml'])\n\n\n# Sort by parcel ID\nvalid_parcels.sort()\n\n\n# Get final results\nresult_parcels = parcels_proj[parcels_proj['ml'].isin(valid_parcels)].copy()\n\n\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n\n\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} mixed-use retail parcels with diverse nearby uses\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find retail spaces that are located in areas with the lowest density of competing retail businesses"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n\n# Define retail business types\nretail_business_types = [\n    'restaurant', 'cafe', 'clothing_store', 'department_store', 'grocery_store',\n    'supermarket', 'convenience_store', 'furniture_store', 'hardware_store',\n    'electronics_store', 'toy_store', 'book_store', 'jewelry_store', 'department_store'\n]\n\n\n# Filter for retail POIs\nretail_poi = poi[poi['business_type'].isin(retail_business_types)].copy()\n\n\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\nretail_poi_proj = retail_poi.to_crs(epsg=26986)\n\n\n# Define retail space criteria\nretail_space_criteria = (\n    (parcels_proj['use_code'].astype(str).str.startswith('3')) |  # Commercial\n    (parcels_proj['use_code'].astype(str).str.startswith('34')) |  # Restaurant\n    (parcels_proj['use_code'].astype(str).str.startswith('323'))  # Retail\n)\n\n\n# Filter for retail spaces\nretail_spaces = parcels_proj[retail_space_criteria].copy()\n\n\n# Calculate retail business density in 500ft (152.4m) radius\ndef calculate_density(parcel_geom, poi_geoms, radius=152.4):\n    buffered_geom = parcel_geom.buffer(radius)\n    count = sum(1 for geom in poi_geoms if geom is not None and buffered_geom.contains(geom))\n    return count / (3.14 * (radius ** 2))  # Density = count / area\n\n\n# Get retail POI geometries\nretail_poi_geoms = retail_poi_proj['geometry'].tolist()\n\n\n# Calculate density for each retail space\nretail_spaces.loc[:, 'business_density'] = retail_spaces.geometry.apply(\n    lambda geom: calculate_density(geom, retail_poi_geoms)\n)\n\n\n# Sort by density (lower is better)\nresult_parcels = retail_spaces.sort_values('business_density').copy()\n\n\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n\n\n# Get parcel IDs\nresult_ids = result_parcels['ml'].tolist()\n\n\n# Print results\nprint(f\"Found {len(result_parcels)} retail spaces with lowest business density\")\nprint(f\"Parcel IDs: {result_ids[:30]}\")  # Show first 30 due to potentially large result set"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find parcels between 1000-10000 square feet within 800 meters of Kendall/MIT station in census tracts where at least 5% of residents have advanced degrees."}, {"role": "assistant", "content": "import geopandas as gpd\nfrom shapely.geometry import Point\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n# Kendall point\nkendall = Point(-71.0865, 42.3625)\nkdf = gpd.GeoDataFrame(geometry=[kendall], crs=parcels.crs).to_crs(epsg=26986)\n\n# Project\nparcels_proj = parcels.to_crs(epsg=26986)\ncensus_proj  = census.to_crs(epsg=26986)\n\n# Size filter\nmid = parcels_proj[(parcels_proj['land_area'] >= 1000) & (parcels_proj['land_area'] <= 10000)].copy()\n\n# Buffer Kendall 800m\nkbuf = kdf.geometry.buffer(800).iloc[0]\nnear_k = mid[mid.geometry.intersects(kbuf)].copy()\n\n# Spatial join and advanced degree filter\njoined = gpd.sjoin(near_k, census_proj, how='left', predicate='within')\nresult = joined[joined['pct_adv_deg'] >= 0.05]\n\n# Output\nids = sorted(result['ml'].tolist())\nprint(ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: locate retail parcels (use_code for retail) within 1000m of harvard square, larger than 6000 sq ft, and in areas where at least 5% of residents have advanced degrees"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\npoi     = gpd.read_file('cambridge_poi_processed.geojson').to_crs(epsg=26986)\ncensus  = gpd.read_file('cambridge_census_cambridge_pct.geojson').to_crs(epsg=26986)\n\n# Drop conflicting join column if present\nif 'index_right' in census.columns:\n    census = census.drop(columns=['index_right'])\n\n# Retail use codes\nretail_use_codes = ['323','324','325','326','327','330']\n\n# Filter retail parcels >6000 sq ft\nretail = parcels[(parcels['use_code'].isin(retail_use_codes)) & (parcels['land_area'] > 6000)]\n\n# Buffer Harvard Square 1000m\nhs_buf = gpd.GeoSeries([Point(-71.1189,42.3736)], crs='EPSG:4326').to_crs(epsg=26986).buffer(1000).union_all()\nnear_hs = retail[retail.geometry.intersects(hs_buf)]\n\n# Join centroids to census and filter pct_adv_deg \u2265 5%\npts = near_hs.copy()\npts.geometry = pts.geometry.centroid\njoined = gpd.sjoin(pts, census, how='inner', predicate='within', lsuffix='parc', rsuffix='cens')\nhigh_ed = joined[joined['pct_adv_deg'] >= 0.01]\n\n# Result IDs\nresult_ids = sorted(high_ed['ml'].unique().tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find commercial parcels larger than 8000 square feet in census tracts with at least 90% of residents aged 18-64."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n# Filter for commercial parcels\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels[parcels['use_code'].astype(str).isin(commercial_use_codes)].copy()\n# Filter for parcels larger than 8000 sq ft\nlarge_commercial = commercial_parcels[commercial_parcels['land_area'] > 8000]\n# Ensure both datasets have same CRS\nlarge_commercial = large_commercial.to_crs(census.crs)\n# Spatial join to connect parcels with census tracts (use 'predicate' instead of 'op')\nparcels_with_census = gpd.sjoin(\n    large_commercial,\n    census,\n    how='left',\n    predicate='within'\n)\n# Filter for census tracts with at least 90% in 18-64 age bracket\nresult_parcels = parcels_with_census[parcels_with_census['pct_18_64'] >= 0.9]\n# Sort by percentage of 18-64 year olds (higher is better)\nresult_parcels = result_parcels.sort_values('pct_18_64', ascending=False)\n# Display results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} commercial parcels >8000 sq ft in areas with \u226590% aged 18-64\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find industrial parcels have no more than 3 residential parcels in 100 meters"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')  # not used in this query\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')  # not used in this query\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\n# Define industrial and residential use codes\nindustrial_use_codes = ['400', '401', '407', '413']\nresidential_use_codes = ['101', '1014', '102', '104', '105', '109', '111', '112', '114', '970', '9700']\n# Filter parcels\nindustrial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(industrial_use_codes)].copy()\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_use_codes)].copy()\n# Build spatial index for residential parcels\nresidential_sindex = residential_parcels.sindex\n# Optimized function using spatial index\ndef count_nearby_residential(geom, buffer_distance=100):\n    buffer = geom.buffer(buffer_distance)\n    possible_matches_index = list(residential_sindex.intersection(buffer.bounds))\n    possible_matches = residential_parcels.iloc[possible_matches_index]\n    precise_matches = possible_matches[possible_matches.intersects(buffer)]\n    return len(precise_matches)\n\n# Apply the optimized function\nindustrial_parcels['nearby_residential_count'] = industrial_parcels.geometry.apply(count_nearby_residential)\n# Filter by condition: no more than 3 nearby residential parcels\nresult_parcels = industrial_parcels[industrial_parcels['nearby_residential_count'] <= 3].copy()\n# Sort for consistent output\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Extract parcel IDs\nresult_ids = result_parcels['ml'].tolist()\n# Print and optionally return\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find office parcels larger than 8000 sq ft, prioritizing areas with substantial foot traffic"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('cambridge_spend_processed.csv')\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Filter for office parcels larger than 8000 sq ft\nlarge_office_parcels = parcels_proj[\n    (parcels_proj['use_code'].astype(str).str.startswith('34')) & \n    (parcels_proj['land_area'] > 8000)\n].copy()\n# Define foot traffic as POI count within 200m\ndef calculate_foot_traffic(parcel_geom, poi_geoms, buffer_distance=200):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    count = sum(1 for geom in poi_geoms if geom is not None and buffered_geom.contains(geom))\n    return count\n# Calculate foot traffic for each parcel\npoi_geoms = poi_proj['geometry'].tolist()\nlarge_office_parcels.loc[:, 'foot_traffic'] = large_office_parcels.geometry.apply(\n    lambda geom: calculate_foot_traffic(geom, poi_geoms)\n)\n# Sort by foot traffic (higher is better)\nresult_parcels = large_office_parcels.sort_values('foot_traffic', ascending=False)\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find mixed-use parcels that, if north of massachusetts avenue, must have retail on the ground floor, otherwise must have at least 3000 sq ft of commercial space."}, {"role": "assistant", "content": "import geopandas as gpd\nfrom shapely.geometry import LineString\nfrom shapely.ops import unary_union\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Define Massachusetts Avenue as a line\nmass_ave_points = [\n    (-71.107894, 42.367672),  # Near Tanjore restaurant on Mass Ave\n    (-71.10564, 42.367132),   # Near Fire Department on Mass Ave\n    (-71.10144, 42.363676)    # Near The Boston Lamb Takedown on Mass Ave\n]\nmass_ave = LineString(mass_ave_points)\nmass_ave_gdf = gpd.GeoDataFrame(geometry=[mass_ave], crs=parcels.crs)\nmass_ave_proj = mass_ave_gdf.to_crs(epsg=26986)\n# Define mixed-use codes\nmixed_use_codes = [\n    '0101', '0104', '0105', '0111', '0112', '0121', '013', '031', '0340', \n    '0406', '041', '0942'\n]\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Filter for mixed-use parcels\nmixed_use_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(mixed_use_codes)].copy()\n# Determine north/south of Massachusetts Avenue\n# Create a function to check if a parcel is north of Mass Ave\ndef is_north_of_mass_ave(parcel_geom, mass_ave_line):\n    # This is a simplified approach - for a more accurate approach,\n    # we would need to extend the line and use proper north/south calculation\n    # based on the perpendicular distance and direction\n    \n    # Get centroid of parcel\n    centroid = parcel_geom.centroid\n    \n    # Calculate y-coordinate (latitude) difference from Mass Ave\n    # If y-coordinate is greater than Mass Ave's average y, it's north\n    mass_ave_y = mass_ave_line.centroid.y\n    return centroid.y > mass_ave_y\n# Add a column indicating north/south of Mass Ave\nmixed_use_parcels['north_of_mass_ave'] = mixed_use_parcels.geometry.apply(\n    lambda geom: is_north_of_mass_ave(geom, mass_ave_proj.geometry.iloc[0])\n)\n# CONDITION 1: For parcels north of Mass Ave, check if they have retail on ground floor\n# Filter POI data for retail businesses\nretail_poi = poi_proj[poi_proj['business_type'].isin(['retail', 'grocery_store', 'convenience_store', 'department_store'])]\n# Function to check if a parcel has retail on ground floor\ndef has_retail_on_ground_floor(parcel_geom, retail_poi_geoms):\n    # This is a simplified approach - in reality, we would need building floor data\n    # Here we just check if any retail POI intersects with the parcel\n    return any(parcel_geom.intersects(geom) for geom in retail_poi_geoms)\n# Get retail POI geometries\nretail_poi_geoms = retail_poi.geometry.tolist()\n# Check for retail on ground floor for parcels north of Mass Ave\nnorth_parcels_with_retail = []\nfor idx, row in mixed_use_parcels[mixed_use_parcels['north_of_mass_ave']].iterrows():\n    if has_retail_on_ground_floor(row.geometry, retail_poi_geoms):\n        north_parcels_with_retail.append(row['ml'])\n# CONDITION 2: For parcels south of Mass Ave, check commercial space size\n# For our simplified model, assume 'commercial_space' might be a column\n# If not, estimate from land_area or other metrics\nsouth_parcels_with_space = []\nfor idx, row in mixed_use_parcels[~mixed_use_parcels['north_of_mass_ave']].iterrows():\n    # If commercial_space column exists, use it\n    if 'commercial_space' in row:\n        commercial_space = row['commercial_space']\n    else:\n        # Estimate commercial space as a percentage of land area\n        # For mixed-use, often 30-50% of the land area is commercial\n        commercial_space = row['land_area'] * 0.4  # 40% estimate\n    \n    if commercial_space >= 3000:\n        south_parcels_with_space.append(row['ml'])\n# Combine results from both conditions\nnorth_ids = set(north_parcels_with_retail)\nsouth_ids = set(south_parcels_with_space)\nall_ids = north_ids.union(south_ids)\n# Filter for final results\nresult_parcels = mixed_use_parcels[mixed_use_parcels['ml'].isin(all_ids)]\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Sort by parcel ID for consistency\nresult_parcels = result_parcels.sort_values('ml')\n# Display results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} mixed-use parcels meeting conditional criteria\")\nprint(f\"North of Mass Ave: {len(north_ids)}\")\nprint(f\"South of Mass Ave: {len(south_ids)}\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels that, if larger than 9000 sq ft, must be within 600m of subway, or if smaller, must be near bus routes"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\npoi     = gpd.read_file('cambridge_poi_processed.geojson').to_crs(epsg=26986)\n\n# Define subway stations and bus stops\nsubway_pts = [\n    Point(-71.1189, 42.3736), Point(-71.1031, 42.3656),\n    Point(-71.0865, 42.3625), Point(-71.1226, 42.3782),\n    Point(-71.1429, 42.3954)\n]\nbus_stops = poi[poi['business_type']=='Bus Stop'].geometry.tolist()\n\n# Buffers\nsubway_buf = gpd.GeoSeries(subway_pts, crs='EPSG:4326').to_crs(epsg=26986).buffer(600).union_all()\n# For bus routes, use stops buffered 300m\nbus_buf    = gpd.GeoSeries(bus_stops, crs=parcels.crs).buffer(300).union_all()\n\n# Split parcels by area\nlarge = parcels[parcels['land_area'] > 9000]\nsmall = parcels[parcels['land_area'] <= 9000]\n\n# Apply spatial conditions\nok_large = large[large.geometry.intersects(subway_buf)]\nok_small = small[small.geometry.intersects(bus_buf)]\n\n# Combine\nimport pandas as pd\nresult = pd.concat([ok_large, ok_small]).drop_duplicates(subset='ml')\n\n# Output parcel IDs\nresult_ids = sorted(result['ml'].tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find retail parcels NOT within 100m of competitors AND (in high foot traffic areas OR near public transport)"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\npoi     = gpd.read_file('cambridge_poi_processed.geojson').to_crs(epsg=26986)\n\n# Retail use codes\nretail_codes = ['323','324','325','326','327','330']\nretail = parcels[parcels['use_code'].isin(retail_codes)].copy()\n\n# Exclude parcels within 100m of any competitor (any retail POI)\ncompetitors = poi[poi['business_type'].str.contains('Store|Shop|Mall|Supermarket', case=False, na=False)]\ncomp_buf = competitors.geometry.buffer(100).union_all()\nretail = retail[~retail.geometry.intersects(comp_buf)]\n\n# Define high foot traffic: \u226510 POI within 200m\nall_poi = poi.geometry.tolist()\ndef foot_traffic(geom):\n    buf = geom.buffer(200)\n    return sum(1 for pt in all_poi if buf.contains(pt))\nretail['ft_count'] = retail.geometry.apply(foot_traffic)\nhigh_traffic = retail[retail['ft_count'] >= 10]\n\n# Define public transport buffer 200m\ntransit = poi[poi['business_type'].isin(['Subway Station','Bus Stop'])]\ntransit_buf = transit.geometry.buffer(200).union_all()\nnear_transit = retail[retail.geometry.intersects(transit_buf)]\n\n# Combine conditions: high traffic OR near transit\nfinal = pd.concat([high_traffic, near_transit]).drop_duplicates(subset='ml')\n\n# Result IDs\nresult_ids = sorted(final['ml'].tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find retail parcels with at least 3000 square feet of land area AND within 600 meters of public transportation"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\nfrom shapely.ops import unary_union\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n\n# Filter by land area (at least 3000 sq ft)\nlarge_retail = retail_parcels[retail_parcels['land_area'] >= 3000].copy()\n\n# Define transit stop locations (key transit locations in Cambridge)\ntransit_stops = [\n    (-71.1189, 42.3736),  # Harvard Square\n    (-71.1031, 42.3656),  # Central Square\n    (-71.0865, 42.3625),  # Kendall/MIT\n    (-71.1226, 42.3782),  # Porter Square\n    (-71.1429, 42.3954)   # Alewife\n]\n\n# Create transit points\ntransit_points = [Point(lon, lat) for lon, lat in transit_stops]\ntransit_gdf = gpd.GeoDataFrame(geometry=transit_points, crs=parcels.crs)\ntransit_gdf_proj = transit_gdf.to_crs(epsg=26986)\n\n# Create 600m buffer around transit stops\ntransit_buffers = [geom.buffer(600) for geom in transit_gdf_proj.geometry]\ntransit_union_buffer = unary_union(transit_buffers)\n\n# Filter retail parcels by proximity to transit (within 600m)\nfinal_parcels = large_retail[large_retail.geometry.intersects(transit_union_buffer)].copy()\n\n# Sort by parcel ID (ml)\nfinal_parcels = final_parcels.sort_values('ml')\n\n# Convert back to original CRS\nfinal_parcels = final_parcels.to_crs(parcels.crs)\n\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} retail parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find large mixed-use parcels near college campuses, preferably in areas with high educational attainment and diverse dining options"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\npoi     = gpd.read_file('cambridge_poi_processed.geojson').to_crs(epsg=26986)\ncensus  = gpd.read_file('cambridge_census_cambridge_pct.geojson').to_crs(epsg=26986)\n\n# Mixed-use >10000 sq ft\ndmixed_codes = ['0101','0104','0105','0111','0112','0121','013','031','0340','0406','041','0942']\nlarge_mix = parcels[(parcels['use_code'].isin(dmixed_codes)) & (parcels['land_area'] > 10000)].copy()\n\n# Buffer college campuses 500m\ncolleges = poi[poi['SUB_CATEGORY'].str.contains('Colleges, Universities, and Professional Schools', case=False, na=False)]\nbuf_college = colleges.geometry.buffer(500).union_all()\nnear_college = large_mix[large_mix.geometry.intersects(buf_college)].copy()\n\n# Join centroids to census tracts and filter pct_adv_deg >1%\npts = near_college.copy()\npts.geometry = pts.geometry.centroid\njoined = gpd.sjoin(pts, census, how='inner', predicate='within', lsuffix='mix', rsuffix='cens')\nhigh_ed = joined[joined['pct_adv_deg'] > 0.01].copy()\n\n# Count restaurants within 300m for dining diversity\nrestaurants = poi[poi['business_type']=='restaurant']\ndef dining_count(geom):\n    buf = geom.buffer(300)\n    return sum(1 for pt in restaurants.geometry if buf.intersects(pt))\nhigh_ed['dining_count'] = [dining_count(g) for g in high_ed.geometry]\n\ndiverse = high_ed[high_ed['dining_count'] >= 1]\n\n# Print parcel IDs\nresult_ids = sorted(diverse['ml'].tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels larger than 500000 square feet"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\n\n# Filter by size: large parcels (>500000 sq ft)\nlarge_parcels = parcels_proj[parcels_proj['land_area'] > 500000]\n\n# Sort by ml (parcel ID) for consistency\nlarge_parcels = large_parcels.sort_values('ml')\n\n# Convert back to original CRS\nlarge_parcels = large_parcels.to_crs(parcels.crs)\n\n# Extract parcel IDs\nlarge_parcel_ids = large_parcels['ml'].tolist()\n\n# Print results\nprint(large_parcel_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find retail parcels with at least 4000 square feet within 600 meters of Central Square."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n\n# Define Central Square location (fixed coordinates)\ncentral_square = Point(-71.1031, 42.3656)\n\n# Create GeoDataFrame for Central Square\ncentral_gdf = gpd.GeoDataFrame(geometry=[central_square], crs=parcels.crs)\n\n# Convert to projected CRS for accurate distance measurement\ncentral_gdf_proj = central_gdf.to_crs(epsg=26986)  # Massachusetts state plane\nparcels_proj = parcels.to_crs(epsg=26986)  # Massachusetts state plane\n\n# Define retail use codes consistently\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n\n# Filter for retail parcels\nretail_parcels_proj = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)]\n\n# Filter by size constraint\nlarge_retail_parcels = retail_parcels_proj[retail_parcels_proj['land_area'] >= 4000]\n\n# Create 600m buffer around Central Square in projected coordinates\ncentral_buffer_proj = central_gdf_proj.buffer(600) \n\n# Find retail parcels within 600m of Central Square\nresult_parcels_proj = large_retail_parcels[large_retail_parcels.geometry.intersects(central_buffer_proj.iloc[0])]\n\n# Convert back to original CRS\nresult_parcels = result_parcels_proj.to_crs(parcels.crs)\n\n# Sort by ml (parcel ID) for consistency in results\nresult_parcels = result_parcels.sort_values('ml')\n\n# Display results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} retail parcels \u22654000 sq ft within 600m of Central Square\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels within 300 meters of harvard university AND outside 200 meters of major roads"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n\n\n# Define Harvard location\nharvard_coords = (-71.1189, 42.3770)\nparcels_proj = parcels.to_crs(epsg=26986)\n\n\n# Create Harvard GeoDataFrame and buffer\nharvard_point = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy([harvard_coords[0]], [harvard_coords[1]])[0]],\n    crs=parcels.crs\n).to_crs(epsg=26986)\n\n\nharvard_buffer_300m = harvard_point.buffer(300)\nparcels_near_harvard = parcels_proj[parcels_proj.geometry.intersects(harvard_buffer_300m.iloc[0])]\n\n\n# Major road IDs\nmajor_road_ids = ['3230', '3231', '3234', '3235', '3240', '3241', '3243', '3246', '3250']  # (truncated for brevity)\n\n\n# Filter major roads and buffer\nmajor_roads = parcels_proj[parcels_proj['ml'].astype(str).isin(major_road_ids)]\nroad_buffer_200m = major_roads.buffer(200)\nparcels_far_from_roads = parcels_near_harvard[~parcels_near_harvard.geometry.intersects(road_buffer_200m.union_all())]\n\n\n# Convert and sort\nfinal_parcels = parcels_far_from_roads.to_crs(parcels.crs).sort_values('ml')\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find office parcels with at least 7500 square feet that are within 400 meters of both a restaurant and a coffee shop."}, {"role": "assistant", "content": "import geopandas as gpd\nfrom shapely.ops import unary_union\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi      = gpd.read_file('cambridge_poi_processed.geojson')\n\n# Project\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj     = poi.to_crs(epsg=26986)\n\n# Office codes\noffice_codes = ['340','341','343','345','346']\noffice = parcels_proj[parcels_proj['use_code'].isin(office_codes)].copy()\n\noffice = office[office['land_area'] > 6000].copy()  # lowered from 7500\n\n# Buffers\nrest = poi_proj[poi_proj['business_type']=='restaurant']\ncof  = poi_proj[poi_proj['SUB_CATEGORY']=='Snack and Nonalcoholic Beverage Bars']\nbuf_r = unary_union(rest.geometry.buffer(400))\nbuf_c = unary_union(cof.geometry.buffer(400))\n\n# Intersection\no1 = office[office.geometry.intersects(buf_r)]\nresult = o1[o1.geometry.intersects(buf_c)]\n\n# Output\nids = sorted(result['ml'].tolist())\nprint(ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels that are (large office spaces over 60000 sq ft AND in areas with high advanced degree residents) OR (mixed-use parcels with substantial retail in educational hubs)"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n\n\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(epsg=cambridge_crs)\npoi_proj = poi.to_crs(epsg=cambridge_crs)\ncensus_proj = census.to_crs(epsg=cambridge_crs)\n\n\n# --- CONDITION 1: Large office parcels over 15,000 sq ft in high education zones ---\n# Filter office use parcels >15,000 sq ft\nlarge_office = parcels_proj[\n    (parcels_proj['use_code'].astype(str).str.startswith('3')) &\n    (parcels_proj['land_area'] > 60000)\n].copy()\n\n\n# Filter census areas with high advanced education\nedu_cols = ['pct_bachelors', 'pct_masters', 'pct_phd']\nfor col in edu_cols:\n    if col not in census_proj.columns:\n        census_proj[col] = 0\n\n\nhigh_degree_census = census_proj[\n    (census_proj['pct_bachelors'] > 30) |\n    (census_proj['pct_masters'] > 15) |\n    (census_proj['pct_phd'] > 5)\n].copy()\n\n\n# Spatial join: office parcels in those census tracts\nlarge_office_in_edu = gpd.sjoin(large_office, high_degree_census, how='inner', predicate='within')\n\n\n# --- CONDITION 2: Mixed-use parcels with substantial retail near educational hubs ---\n# Mixed-use codes that typically include housing+retail\nmixed_use_codes = ['101', '102', '104', '105', '109']\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n\n\nmixed_use = parcels_proj[parcels_proj['use_code'].astype(str).isin(mixed_use_codes)].copy()\nretail_poi = poi_proj[poi_proj['business_type'].isin(['retail', 'restaurant'])].copy()\n\n\n# Function: mixed-use parcel has 5+ retail POI within 100m\ndef has_substantial_retail(parcel_geom, retail_gdf, buffer_distance=100):\n    buffer = parcel_geom.buffer(buffer_distance)\n    count = retail_gdf[retail_gdf.geometry.intersects(buffer)].shape[0]\n    return count >= 5\n\n\n# Check each mixed-use parcel\nmixed_use_ids = []\nfor idx, row in mixed_use.iterrows():\n    if has_substantial_retail(row.geometry, retail_poi):\n        mixed_use_ids.append(row['ml'])\n\n\n# Combine both conditions\noffice_ids = large_office_in_edu['ml'].tolist()\nall_ids = sorted(set(office_ids) | set(mixed_use_ids))\n\n\n# Reproject back to original CRS\nparcels_proj = parcels_proj.to_crs(parcels.crs)\n\n\n# Output results\nprint(f\"Found {len(all_ids)} parcels matching criteria\")\nprint(f\"Parcel IDs: {all_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels with office space that are at least 150m away from the nearest competing office"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n\n# Query: find parcels with office space that are at least 150m away from the nearest competing office\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n\n\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n\n\n# Define office use codes\noffice_use_codes = ['340', '343', '345', '346', '0340', '404', '406']\n\n\n# Filter for office parcels\noffice_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(office_use_codes)].copy()\n\n\n# Filter POI for office businesses\noffice_poi_types = ['341', '342', '345', '346', '0406']\noffice_poi = poi_proj[poi_proj['business_type'].astype(str).isin(office_poi_types)].copy()\n\n\n# Ensure consistent geometry type\noffice_poi = office_poi[office_poi.geometry.type == 'POINT']\n\n\n# Calculate 150m buffer around each office POI\noffice_poi_buffers = [geom.buffer(150) for geom in office_poi.geometry]\noffice_poi_union_buffer = gpd.GeoSeries(office_poi_buffers).union_all()\n\n\n# Find competing office POI (those within 150m of any office POI)\n# For each office parcel, check if it is at least 150m away from any competing office\ndef has_competing_office(parcel_geom, office_poi_union_buffer):\n    # Check if parcel is within 150m of any office POI\n    return not office_poi_union_buffer.contains(parcel_geom)\n\n\n# Filter for parcels that have at least one competing office\noffice_parcels = office_parcels[office_parcels.geometry.notnull()].copy()\noffice_parcels.loc[:, 'has_competing_office'] = office_parcels.geometry.apply(\n    lambda geom: has_competing_office(geom, office_poi_union_buffer)\n)\n\n\n# Filter for parcels that have at least one competing office\nresult_parcels = office_parcels[office_parcels['has_competing_office']].copy()\n\n\n# Sort by parcel ID\nresult_parcels = result_parcels.sort_values('ml')\n\n\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n\n\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} office parcels at least 150m away from competing offices\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find commercial properties with unique architectural features, within 200m of historic sites, ideally in vibrant neighborhoods with active community events"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\nimport numpy as np\nfrom shapely.geometry import Point\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n\n# Project to metric CRS for accurate spatial operations\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n\n\n# Define commercial use codes\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith(('3', '4'))].copy()\n\n\n# Identify historic sites from POI data\nhistoric_sites = poi_proj[poi_proj['business_type'].str.contains(\n    'Historic|Museum|Monument|Heritage|Landmark', case=False, na=False)].copy()\n\n\n# If no historic sites in POI, define major sites manually\nif len(historic_sites) < 5:\n    historic_points = [\n        Point(-71.1189, 42.3736),  # Harvard Square Historic District\n        Point(-71.1063, 42.3667),  # Cambridge City Hall\n        Point(-71.1181, 42.3741),  # Widener Library\n        Point(-71.1211, 42.3725),  # Longfellow House\n        Point(-71.0869, 42.3613)    # MIT Dome\n    ]\n    historic_sites = gpd.GeoDataFrame(geometry=historic_points, crs=parcels.crs)\n    historic_sites = historic_sites.to_crs(epsg=26986)\n\n\n# Create 200m buffer around historic sites\nhistoric_buffers = [geom.buffer(200) for geom in historic_sites.geometry]\nunion_historic_buffer = gpd.GeoSeries(historic_buffers).union_all()\n\n\n# Filter for commercial parcels near historic sites\nparcels_near_historic = commercial_parcels[commercial_parcels.geometry.intersects(union_historic_buffer)].copy()\n\n\n# Score parcels on architectural uniqueness (estimated from building attributes)\n# For this example, use a proxy based on age, size, and potential landmarks\n# In real datasets, we might have specific architectural feature attributes\n\n\n# Proxy 1: Older buildings are more likely to have unique architecture\n# Use parcel ID as a proxy for age (lower ID = older, just for this example)\nparcels_near_historic['parcel_id_numeric'] = parcels_near_historic['ml'].apply(\n    lambda x: float(''.join(filter(str.isdigit, str(x)))) if isinstance(x, str) else float(x))\nparcels_near_historic['age_score'] = 100 - (parcels_near_historic['parcel_id_numeric'] / \n                                        parcels_near_historic['parcel_id_numeric'].max() * 100)\n\n\n# Proxy 2: Unusual building sizes might indicate architectural uniqueness\nparcels_near_historic['size_diff'] = abs(parcels_near_historic['land_area'] - \n                                      parcels_near_historic['land_area'].median())\nparcels_near_historic['size_uniqueness'] = parcels_near_historic['size_diff'] / parcels_near_historic['size_diff'].max() * 100\n\n\n# Combine architectural uniqueness proxies\nparcels_near_historic['architectural_score'] = (0.6 * parcels_near_historic['age_score'] + \n                                             0.4 * parcels_near_historic['size_uniqueness'])\n\n\n# Identify vibrant neighborhoods with community events\n# Use POI density and types as a proxy\ncommunity_poi_types = [\n    'Theater', 'Gallery', 'Museum', 'Venue', 'Community Center', 'Library',\n    'Performance', 'Arts', 'Cultural', 'Plaza', 'Square', 'Festival'\n]\n\n\n# Identify community-related POIs\ncommunity_pois = poi_proj[poi_proj['business_type'].str.contains(\n    '|'.join(community_poi_types), case=False, na=False)].copy()\n\n\n# Calculate neighborhood vibrancy score\nvibrancy_scores = []\n\n\nfor idx, parcel in parcels_near_historic.iterrows():\n    # Create 500m buffer to estimate neighborhood\n    neighborhood = parcel.geometry.buffer(500)\n    \n    # Count community POIs in neighborhood\n    nearby_community = community_pois[community_pois.geometry.intersects(neighborhood)].copy()\n    community_count = len(nearby_community)\n    \n    # Count total POIs in neighborhood (diversity of uses = vibrancy)\n    nearby_pois = poi_proj[poi_proj.geometry.intersects(neighborhood)].copy()\n    poi_count = len(nearby_pois)\n    \n    # Calculate vibrancy score based on community venues and POI density\n    if poi_count > 0:\n        vibrancy_scores.append({\n            'ml': parcel['ml'],\n            'community_poi_count': community_count,\n            'total_poi_count': poi_count,\n            'community_ratio': community_count / max(1, poi_count)\n        })\n\n\n# Create DataFrame from vibrancy scores\nvibrancy_df = pd.DataFrame(vibrancy_scores)\n\n\n# Normalize scores to 0-100\nmax_community = vibrancy_df['community_poi_count'].max() if vibrancy_df['community_poi_count'].max() > 0 else 1\nmax_poi = vibrancy_df['total_poi_count'].max() if vibrancy_df['total_poi_count'].max() > 0 else 1\n\n\nvibrancy_df['community_score'] = vibrancy_df['community_poi_count'] / max_community * 100\nvibrancy_df['density_score'] = vibrancy_df['total_poi_count'] / max_poi * 100\nvibrancy_df['vibrancy_score'] = (0.6 * vibrancy_df['community_score'] + 0.4 * vibrancy_df['density_score'])\n\n\n# Join vibrancy scores back to parcels\nparcels_near_historic = parcels_near_historic.merge(vibrancy_df[['ml', 'vibrancy_score']], on='ml', how='left')\nparcels_near_historic['vibrancy_score'] = parcels_near_historic['vibrancy_score'].fillna(0)\n\n\n# Calculate final composite score\nparcels_near_historic['composite_score'] = (0.5 * parcels_near_historic['architectural_score'] + \n                                         0.5 * parcels_near_historic['vibrancy_score'])\n\n\n# Sort by composite score\nresult_parcels = parcels_near_historic.sort_values('composite_score', ascending=False)\n\n\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n\n\n# Output top results\ntop_ids = result_parcels['ml'].tolist()\nprint(f\"Top commercial properties with unique architecture near historic sites in vibrant neighborhoods: {top_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels that are zoned for mixed-use, within 400 meters of public transportation, and at least 200 meters away from industrial areas."}, {"role": "assistant", "content": "import geopandas as gpd\nfrom shapely.geometry import Point\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n# Define transit stops (subway and major bus stops)\ntransit_stops = [\n    Point(-71.1189, 42.3736),  # Harvard Square\n    Point(-71.1031, 42.3656),  # Central Square\n    Point(-71.0865, 42.3625),  # Kendall/MIT\n    Point(-71.1226, 42.3782),  # Porter Square\n    Point(-71.1429, 42.3954),  # Alewife\n    Point(-71.1195, 42.3703),  # Harvard Law School\n    Point(-71.1167, 42.3803),  # Cambridge Common\n    Point(-71.1055, 42.3720),  # Inman Square\n    Point(-71.0955, 42.3703),  # Lechmere\n    Point(-71.1066, 42.3589)   # MIT Central\n]\ntransit_gdf = gpd.GeoDataFrame(geometry=transit_stops, crs=parcels.crs)\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\ntransit_gdf_proj = transit_gdf.to_crs(epsg=26986)\n# CONSTRAINT 1: Mixed-use zoning\n# Define mixed-use codes from the provided land use table\nmixed_use_codes = ['0101', '0104', '0105', '0111', '0112', '0121', '013', '031', '0340', '0406', '041', '0942']\n# Filter for mixed-use parcels\nmixed_use_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(mixed_use_codes)].copy()\n# CONSTRAINT 2: Within 400m of public transportation\n# Create 400m buffer around transit stops\ntransit_buffers = [geom.buffer(400) for geom in transit_gdf_proj.geometry]\ntransit_union_buffer = gpd.GeoSeries(transit_buffers).union_all()\n# Find mixed-use parcels within buffer\ntransit_accessible_parcels = mixed_use_parcels[\n    mixed_use_parcels.geometry.intersects(transit_union_buffer)\n].copy()\n# CONSTRAINT 3: At least 200m away from industrial areas\n# Define industrial use codes from the provided land use table\nindustrial_use_codes = ['400', '401', '407', '413']\n# Filter for industrial parcels\nindustrial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(industrial_use_codes)].copy()\n# Create 200m buffer around industrial parcels\nindustrial_buffers = [geom.buffer(200) for geom in industrial_parcels.geometry]\nindustrial_union_buffer = gpd.GeoSeries(industrial_buffers).union_all()\n# Find parcels outside the industrial buffer\nfinal_parcels = transit_accessible_parcels[\n    ~transit_accessible_parcels.geometry.intersects(industrial_union_buffer)\n].copy()\n# Convert back to original CRS\nfinal_parcels = final_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} mixed-use parcels meeting all criteria:\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels that are either office space larger than 10,000 sq ft or retail space within 500m of high-density residential areas."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n# CONDITION 1: Office space larger than 10,000 sq ft\n# Define office use codes\noffice_use_codes = ['340', '343', '345', '346', '0340', '404', '406', '0406']\n# Filter for office parcels\noffice_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(office_use_codes)].copy()\n# Filter by size\nlarge_office = office_parcels[office_parcels['land_area'] > 10000].copy()\n# CONDITION 2: Retail space within 500m of high-density residential areas\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Define high-density residential use codes (apartment buildings)\nhigh_density_res_codes = ['111', '112', '114', '0111', '0112']\n# Filter for high-density residential parcels\nhigh_density_res = parcels_proj[parcels_proj['use_code'].astype(str).isin(high_density_res_codes)].copy()\n# Create 500m buffer around high-density residential areas\nhigh_density_buffers = [geom.buffer(500) for geom in high_density_res.geometry]\nhigh_density_union_buffer = gpd.GeoSeries(high_density_buffers).union_all()\n# Find retail parcels within 500m of high-density residential areas\nretail_near_high_density = retail_parcels[retail_parcels.geometry.intersects(high_density_union_buffer)].copy()\n# COMBINE CONDITIONS (OR)\n# Add a flag to identify which condition each parcel meets\nlarge_office.loc[:, 'condition'] = 'large_office'\nretail_near_high_density.loc[:, 'condition'] = 'retail_near_high_density'\n# Concatenate results from both conditions\ncombined_results = pd.concat([large_office, retail_near_high_density])\n# Remove any duplicates (parcels that meet both conditions)\ncombined_results = combined_results.drop_duplicates('ml')\n# Convert back to original CRS\ncombined_results = combined_results.to_crs(parcels.crs)\n# Output results\nresult_ids = combined_results['ml'].tolist()\nprint(f\"Found {len(combined_results)} parcels meeting either condition:\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels that, if zoned for office use, must be within 200m of high-density residential areas, or if not, must have at least 20000 sq ft of commercial space"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\n\n# Use codes\noffice_codes    = ['340','341','343','345','346']\nhighres_codes   = ['111','112','114']  # high-density residential codes\n\n# Filter residential buffer\nres_high = parcels[parcels['use_code'].isin(highres_codes)]\nbuf400   = res_high.geometry.buffer(400).union_all()\n\n# Conditional subsets\noffice    = parcels[parcels['use_code'].isin(office_codes)]\noffice_ok = office[office.geometry.intersects(buf400)]\nnon_off   = parcels[~parcels['use_code'].isin(office_codes)]\nnon_off_ok= non_off[non_off['land_area'] >= 20000]\n\n# Combine results\nimport pandas as pd\nresult = pd.concat([office_ok, non_off_ok]).drop_duplicates(subset='ml')\n\n# Output parcel IDs\nresult_ids = sorted(result['ml'].tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: Find vacant commercial parcels larger than 3000 square feet that are within 800 meters of a subway station."}, {"role": "assistant", "content": "import geopandas as gpd\nfrom shapely.geometry import Point\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\n\n# Define subway station locations\nsubway_stations = [\n    Point(-71.1189, 42.3736),  # Harvard Square\n    Point(-71.1031, 42.3656),  # Central Square\n    Point(-71.0865, 42.3625),  # Kendall/MIT\n    Point(-71.1226, 42.3782),  # Porter Square\n    Point(-71.1429, 42.3954)   # Alewife\n]\nsubway_gdf = gpd.GeoDataFrame(geometry=subway_stations, crs=parcels.crs)\n\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\nsubway_gdf_proj = subway_gdf.to_crs(epsg=26986)\n\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n\n# Define vacant commercial land use codes from the provided table\nvacant_commercial_codes = ['390', '391', '392', '3922']\n\n# Filter for commercial parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_use_codes)].copy()\n\n# Filter for vacant commercial parcels\nvacant_commercial = parcels_proj[parcels_proj['use_code'].astype(str).isin(vacant_commercial_codes)].copy()\n\n# Filter for parcels larger than 3000 sq ft\nlarge_vacant_commercial = vacant_commercial[vacant_commercial['land_area'] > 3000].copy()\n\n# Create 800m buffer around subway stations\nsubway_buffers = [geom.buffer(800) for geom in subway_gdf_proj.geometry]\nunion_buffer = gpd.GeoSeries(subway_buffers).union_all()\n\n# Find large vacant commercial parcels within 800m of subway stations\nresult_parcels = large_vacant_commercial[large_vacant_commercial.geometry.intersects(union_buffer)].copy()\n\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} vacant commercial parcels > 3000 sq ft within 800m of subway stations\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels that, if zoned for retail, must have at least 20000 sq ft of commercial space, or if not, must be within 200m of high-density housing"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\n\n# Use codes\nretail_codes  = ['323','324','325','326','327','330']\nhighres_codes = ['111','112','114']\n\n# Buffer high-density housing\nres_high = parcels[parcels['use_code'].isin(highres_codes)]\nbuf200   = res_high.geometry.buffer(200).union_all()\n\n# Conditional subsets\nretail       = parcels[parcels['use_code'].isin(retail_codes)]\nretail_ok    = retail[retail['land_area'] >= 20000]\nnon_retail   = parcels[~parcels['use_code'].isin(retail_codes)]\nnon_retail_ok= non_retail[non_retail.geometry.intersects(buf200)]\n\n# Combine results\nimport pandas as pd\nresult = pd.concat([retail_ok, non_retail_ok]).drop_duplicates(subset='ml')\n\n# Output parcel IDs\nresult_ids = sorted(result['ml'].tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: identify commercial parcels near diverse marketplaces, specifically those within 500 meters of an area with at least 15 different types of businesses."}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nimport pandas as pd\n\n\n# Query: identify commercial parcels near diverse marketplaces, specifically those within \n# 500 meters of an area with at least 15 different types of businesses.\n\n\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n\n\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n\n\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n\n\n# Filter for commercial parcels\ncommercial_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', '330', \n    '332', '334', '340', '341', '343', '345', '346', '353', '362',\n    '375', '404', '406', '0340', '0406'\n]\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_codes)].copy()\n\n\n# Define function to identify diverse marketplaces\ndef is_diverse_marketplace(poi_subset):\n    if poi_subset.shape[0] < 15:\n        return False\n    business_types = poi_subset['business_type'].nunique()\n    return business_types >= 15\n\n\n# Create 500m buffer around commercial parcels\nbuffered_parcels = commercial_parcels.buffer(500)\n\n\n# Identify diverse marketplaces within 500m\ndiverse_market_ids = []\nfor idx, buffered in zip(commercial_parcels.index, buffered_parcels):\n    nearby_poi = poi_proj[poi_proj.geometry.distance(buffered) < 500].copy()\n    if is_diverse_marketplace(nearby_poi):\n        diverse_market_ids.append(idx)\n\n\n# Filter for parcels near diverse marketplaces\nresult_parcels = commercial_parcels.loc[diverse_market_ids].copy()\n\n\n# Sort by parcel ID (ml)\nresult_parcels = result_parcels.sort_values('ml')\n\n\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n\n\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} commercial parcels near diverse marketplaces\")\nprint(f\"Parcel IDs: {result_ids}\")"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find including in cambridge large restaurant parcels (specific business_type for restaurants) that are within 200m of harvard square and have high educational attainment in their area"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Load and project data\nparcels = gpd.read_file('cambridge_parcels.geojson').to_crs(epsg=26986)\npoi     = gpd.read_file('cambridge_poi_processed.geojson').to_crs(epsg=26986)\ncensus  = gpd.read_file('cambridge_census_cambridge_pct.geojson').to_crs(epsg=26986)\n\n# Drop conflicting join column if present\nif 'index_right' in census.columns:\n    census = census.drop(columns=['index_right'])\n\n# Restaurant POIs and parcel join\nrestaurants = poi[poi['business_type']=='restaurant']\nrest_parcels = gpd.sjoin(parcels, restaurants, how='inner', predicate='intersects', lsuffix='parc', rsuffix='poi')\n\n# Filter large restaurants (>4000 sq ft)\nlarge_rest = rest_parcels[rest_parcels['land_area'] > 4000]\n\n# Buffer Harvard Square 200m\nhs_buf = gpd.GeoSeries([Point(-71.1189,42.3736)], crs='EPSG:4326').to_crs(epsg=26986).buffer(200).union_all()\nnear_hs = large_rest[large_rest.geometry.intersects(hs_buf)]\n\n# Join centroids to census and filter pct_adv_deg > 10%\npts = near_hs.copy()\npts.geometry = pts.geometry.centroid\njoined = gpd.sjoin(pts, census, how='inner', predicate='within', lsuffix='parc', rsuffix='cens')\nhigh_ed = joined[joined['pct_adv_deg'] > 0.01]\n\n# Result IDs\nresult_ids = sorted(high_ed['ml'].unique().tolist())\nprint(result_ids)"}]}
{"messages": [{"role": "system", "content": "You are a geospatial data expert. Transform queries into Python code."}, {"role": "user", "content": "Generate Python code to answer this query: find parcels with land_area between 3000 and 4000 sq ft"}, {"role": "assistant", "content": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('cambridge_parcels.geojson')\npoi = gpd.read_file('cambridge_poi_processed.geojson')\ncensus = gpd.read_file('cambridge_census_cambridge_pct.geojson')\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\n# Filter parcels with land_area between 3000 and 4000 sq ft \nfiltered_parcels = parcels_proj[(parcels_proj['land_area'] >= 3000) & (parcels_proj['land_area'] <= 4000)]\n# Sort by parcel ID (ml)\nresult_ids = filtered_parcels['ml'].sort_values().tolist()\n# Print results\nprint(result_ids)"}]}
