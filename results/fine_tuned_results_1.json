[
  {
    "exact_match": 1.0,
    "result_match_rate": 1.0,
    "precision": 1.0,
    "recall": 1.0,
    "f1_score": 1.0,
    "generated_count": 93,
    "ground_truth_count": 93,
    "correct_count": 93,
    "query": "find commercial parcels within 500 meters of harvard square.",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": true,
    "code": "import geopandas as gpd\nfrom shapely.geometry import Point\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define Harvard Square location\nharvard_square = Point(-71.1189, 42.3736)\n# Create GeoDataFrame for Harvard Square\nharvard_gdf = gpd.GeoDataFrame(geometry=[harvard_square], crs=parcels.crs)\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\nharvard_proj = harvard_gdf.to_crs(epsg=26986)\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith(('3', '4'))].copy()\n# Create 500m buffer around Harvard Square\nharvard_buffer = harvard_proj.buffer(500) \n# Find parcels within 500m of Harvard Square\nnear_harvard = commercial_parcels[commercial_parcels.geometry.intersects(harvard_buffer.iloc[0])].copy()\n# Sort by parcel ID (ml)\nnear_harvard = near_harvard.sort_values('ml')\n# Convert back to original CRS\nnear_harvard = near_harvard.to_crs(parcels.crs)\n# Output results\nresult_ids = near_harvard['ml'].tolist()\nprint(f\"Found {len(near_harvard)} commercial parcels within 500m of Harvard Square\")\nprint(f\"Parcel IDs: {result_ids}\")",
    "generated_ids": [
      "133-12",
      "133-14",
      "133-15",
      "133-20",
      "133-23",
      "133-27",
      "133-28",
      "133-36",
      "133-48",
      "133-49",
      "133-51",
      "133-52",
      "133-54",
      "133-56",
      "134-7",
      "135-123",
      "136-15",
      "137-13",
      "159-2",
      "160-11",
      "160-14",
      "160-48",
      "160-57",
      "160-58",
      "160-59",
      "160-63",
      "160-64",
      "160-66",
      "160-67",
      "160-69",
      "160-71",
      "160-72",
      "160-76",
      "160-77",
      "160-83",
      "160-84",
      "160-85",
      "161-92",
      "162-17",
      "162-18",
      "162-19",
      "162-26",
      "162-29",
      "162-36",
      "162-54",
      "162-64",
      "162-65",
      "162-66",
      "162-67",
      "162-68",
      "162-73",
      "165-34",
      "165-53",
      "165-55",
      "165-57",
      "165-60",
      "166-24",
      "166-31",
      "166-33",
      "166-35",
      "166-37",
      "166-52",
      "166-77",
      "168-13",
      "168-20",
      "168-21",
      "168-22",
      "168-25",
      "168-33",
      "168-36",
      "168-41",
      "168-48",
      "168-49",
      "168-59",
      "168-60",
      "168-64",
      "169-100",
      "169-102",
      "169-42",
      "169-46",
      "169-47",
      "169-50",
      "169-67",
      "169-68",
      "169-7",
      "169-81",
      "169-82",
      "169-84",
      "169-86",
      "169-93",
      "169-98",
      "169-99",
      "170-39"
    ]
  },
  {
    "exact_match": 1.0,
    "result_match_rate": 1.0,
    "precision": 1.0,
    "recall": 1.0,
    "f1_score": 1.0,
    "generated_count": 81,
    "ground_truth_count": 81,
    "correct_count": 81,
    "query": "find parcels larger than 6000 square feet that are zoned for retail use.",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": true,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Filter for retail parcels\nretail_parcels = parcels[parcels['use_code'].astype(str).isin(retail_use_codes)]\n# Filter for large retail parcels (>6000 sq ft)\nlarge_retail_parcels = retail_parcels[retail_parcels['land_area'] > 6000]\n# Sort by parcel ID (ml)\nresult_parcels = large_retail_parcels.sort_values('ml')\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(result_ids)",
    "generated_ids": [
      "100-62",
      "105-68",
      "105-82",
      "106-124",
      "107-117",
      "107-9",
      "109-50",
      "110-91",
      "116-12",
      "120-48",
      "125-73",
      "128-63",
      "128-72",
      "134-33",
      "136-15",
      "140-148",
      "152-25",
      "156-25",
      "157-26",
      "16-11",
      "162-26",
      "162-54",
      "169-46",
      "169-47",
      "174-37",
      "175-37",
      "175-75",
      "175-84",
      "176-15",
      "176-64",
      "179-87",
      "18-64",
      "18-65",
      "180-57",
      "182-88",
      "183-100",
      "184-159",
      "189-72",
      "191-65",
      "191-85",
      "192-121",
      "192-177",
      "196-154",
      "199-30",
      "199-31",
      "199-67",
      "1A-189",
      "1A-192",
      "1A-211",
      "20-75",
      "200-22",
      "21-121",
      "226-46",
      "229-117",
      "230-71",
      "234-178",
      "236-95",
      "252-172",
      "260-46",
      "260-76",
      "265B-26",
      "265B-28",
      "265B-61",
      "265C-25",
      "267E-234",
      "268B-15",
      "273-2",
      "273-20",
      "34-8",
      "70-91",
      "70-92",
      "74-1",
      "8-88",
      "81-100",
      "83-80",
      "84-101",
      "84-91",
      "90-155",
      "90-162",
      "92-88",
      "93-78"
    ]
  },
  {
    "query": "find all parcels that have no more than 2 competing restaurants within 800 meters.",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\n# Define restaurant POI types\nrestaurant_types = ['restaurant', 'fast_food', 'cafe', 'diner', 'pizzeria']\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Filter for restaurants\nrestaurants = poi_proj[poi_proj['poi_type'].isin(restaurant_types)].copy()\n# Function to count nearby restaurants\ndef count_nearby_restaurants(parcel_geom, restaurants, buffer_distance=800):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    nearby_restaurants = restaurants[restaurants.geometry.intersects(buffered_geom)]\n    return len(nearby_restaurants)\n# Calculate restaurant count for each parcel\nparcels_proj['restaurant_count'] = parcels_proj.geometry.apply(\n    lambda geom: count_nearby_restaurants(geom, restaurants)\n)\n# Filter for parcels with no more than 2 competing restaurants\nresult_parcels = parcels_proj[parcels_proj['restaurant_count'] <= 2].copy()\n# Sort by parcel ID\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(result_ids)"
  },
  {
    "query": "find the top 20 parcels in cambridge with the most diverse mix of residential and commercial land uses within 500 meters.",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define project CRS for Cambridge\ncambridge_crs = 26986\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Filter for residential parcels\nresidential_codes = [\n    '101', '1014', '102', '1024', '1025', '103', '104', '109', '1094', '1095',\n    '1098', '110', '111', '112', '113', '114', '121', '970', '9700', '9424'\n]\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_codes)].copy()\n# Filter for commercial parcels\ncommercial_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', '330', '332', '334',\n    '340', '341', '343', '345', '346', '353', '362', '375', '404', '406', '0340'\n]\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_codes)].copy()\n# Function to calculate land use diversity\ndef land_use_diversity(parcel_geom, poi_geoms, buffer_distance=500):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    # Filter POI within buffered area\n    poi_within = poi_geoms[poi_geoms.geometry.intersects(buffered_geom)].copy()\n    # Define commercial use types\n    commercial_types = [\n        'restaurant', 'grocery_store', 'clothing_store', 'department_store',\n        'furniture_store', 'hardware_store', 'hotel', 'motel', 'office', 'bank'\n    ]\n    # Count residential and commercial POI\n    if not poi_within.empty:\n        # Use 'business_type' if available, otherwise use 'poi_type'\n        if 'business_type' in poi_within.columns:\n            poi_within['type'] = poi_within['business_type'].astype(str).str.lower()\n        else:\n            poi_within['type'] = poi_within['poi_type'].astype(str).str.lower()\n        \n        residential_count = poi_within[~poi_within['type'].isin(commercial_types)].shape[0]\n        commercial_count = poi_within[poi_within['type'].isin(commercial_types)].shape[0]\n    else:\n        residential_count = 0\n        commercial_count = 0\n    \n    # Calculate diversity score\n    return 1 + (residential_count + commercial_count) / 2\n# Calculate diversity for each residential parcel\ndiversity_scores = []\nfor idx, parcel in residential_parcels.iterrows():\n    score = land_use_diversity(parcel.geometry, poi_proj.geometry)\n    diversity_scores.append(score)\n    # Print progress\n    if (idx + 1) % 50 == 0:\n        print(f'Processed {idx + 1}/{len(residential_parcels)} parcels')\n# Assign scores to parcels\nresidential_parcels.loc[:, 'diversity_score'] = diversity_scores\n# Sort by diversity score (higher is better)\nresult_parcels = residential_parcels.sort_values('diversity_score', ascending=False)\n# Get top 20\ntop20_parcels = result_parcels.head(20)\n# Convert back to original CRS\ntop20_parcels = top20_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = top20_parcels['ml'].tolist()\nprint(f'Found {len(top20_parcels)} parcels')\nprint(f'Parcel IDs: {result_ids}')"
  },
  {
    "query": "find the top 20 commercial parcels in areas with the highest percentage of residents with advanced degrees.",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels[parcels['use_code'].astype(str).isin(commercial_use_codes)].copy()\n# Project to metric CRS for accurate buffering\ncommercial_parcels_proj = commercial_parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Sort by educational attainment (advanced degrees) in descending order\ncensus_sorted = census_proj.sort_values('pct_adv_deg', ascending=False)\n# Get top 20 areas with highest advanced degree percentage\ntop_educational_areas = census_sorted.head(20)['geoid'].tolist()\n# Filter by location\nparcels_in_top_areas = []\nfor area in top_educational_areas:\n    # Get approximate location of area (census tract centroid)\n    area_geom = census_proj[census_proj['geoid'] == area].geometry.values[0]\n    # Find parcels within 200m of area\n    buffered_area = area_geom.buffer(200)  # 200m buffer\n    nearby_parcels = commercial_parcels_proj[commercial_parcels_proj.geometry.intersects(buffered_area)].copy()\n    # Add to list\n    parcels_in_top_areas.append(nearby_parcels)\n# Concatenate results\nall_nearby_parcels = pd.concat(parcels_in_top_areas)\n# Remove duplicates\nall_nearby_parcels = all_nearby_parcels.drop_duplicates()\n# Sort by educational area (to maintain consistency)\ndef get_area_rank(parcel, top_areas):\n    for i, area in enumerate(top_areas):\n        if parcel in area_parcel_ids[area]:\n            return i\n    return len(top_areas)  # If not found, assign low rank\nall_nearby_parcels['area_rank'] = all_nearby_parcels['ml'].apply(lambda x: get_area_rank(x, top_educational_areas))\nall_nearby_parcels = all_nearby_parcels.sort_values('area_rank')\n# Get parcel IDs\nresult_ids = all_nearby_parcels['ml'].tolist()\n# Print results\nprint(f"
  },
  {
    "query": "\u201cfind the top 20 parcels with the highest consumer spending in surrounding areas.\u201d",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\nspend_data = pd.read_csv('../data/cambridge_spend_processed.csv')\n# Convert to projected CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Merge spending data with parcels\nparcels_with_spend = parcels_proj.merge(\n    spend_data,\n    left_on='ml',\n    right_on='ml',\n    how='left'\n)\n# Fill NaN values in spending with 0\nparcels_with_spend['total_spend'] = parcels_with_spend['total_spend'].fillna(0)\n# Sort by spending (higher is better)\nparcels_by_spend = parcels_with_spend.sort_values('total_spend', ascending=False)\n# Get top 20 parcels by spending\ntop_spend_parcels = parcels_by_spend.head(20)\n# Get POI data within 400m of each top spending parcel\ndef get_poi_near_parcel(parcel_geom, poi_geoms, buffer_distance=400):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    return poi_geoms[poi_geoms.intersects(buffered_geom)].copy()\n# Get POI geometries\npoi_geoms = poi_proj['geometry'].tolist()\n# Calculate POI for each top spending parcel\ntop_spend_parcels.loc[:, 'nearby_poi'] = top_spend_parcels['geometry'].apply(\n    lambda geom: get_poi_near_parcel(geom, poi_geoms)\n)\n# Calculate spending in surrounding areas\ndef calculate_area_spend(parcel_geom, poi_spend, buffer_distance=400):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    # Get POI within buffer\n    nearby_poi = poi_spend[poi_spend['geometry'].intersects(buffered_geom)].copy()\n    # Calculate total spend from nearby POI\n    if not nearby_poi.empty:\n        return nearby_poi['total_spend'].sum()\n    return 0\n# Calculate area spend for each top parcel\ntop_spend_parcels.loc[:, 'area_spend'] = top_spend_parcels.apply(\n    lambda row: calculate_area_spend(row['geometry'], poi_spend, buffer_distance=400),\n    axis=1\n)\n# Sort by area spend (higher is better)\nresult_parcels = top_spend_parcels.sort_values('area_spend', ascending=False)\n# Get parcel IDs\nresult_ids = result_parcels['ml'].tolist()\n# Print results\nprint(f\"Top 20 parcels with highest area spending: {result_ids}\")"
  },
  {
    "query": "find vacant commercial parcels larger than 3000 square feet that are within 800 meters of a subway station.",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define subway station locations in Cambridge, MA\nsubway_stations = [\n    (-71.1189, 42.3736),  # Harvard Square\n    (-71.1032, 42.3656),  # Central Square\n    (-71.0865, 42.3625),  # Kendall/MIT\n    (-71.1226, 42.3782),  # Porter Square\n    (-71.1429, 42.3954)   # Alewife\n]\n# Convert subway station coordinates to GeoDataFrame\nstation_geom = [Point(lon, lat) for lon, lat in subway_stations]\nsubway_gdf = gpd.GeoDataFrame(geometry=station_geom, crs=parcels.crs)\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\nsubway_gdf_proj = subway_gdf.to_crs(epsg=26986)\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for vacant commercial parcels larger than 3000 sq ft\nvacant_commercial = parcels_proj[\n    (parcels_proj['use_code'].astype(str).str.startswith(('3', '4'))) & \n    (parcels_proj['ml'].astype(str).str.startswith('0')) & \n    (parcels_proj['land_area'] > 3000)\n].copy()\n# Calculate 800m buffer around subway stations\nsubway_buffers = [geom.buffer(800) for geom in subway_gdf_proj.geometry]\nunion_buffer = unary_union(subway_buffers)\n# Filter for parcels within 800m of subway stations\nresult_parcels = vacant_commercial[vacant_commercial.geometry.intersects(union_buffer)].copy()\n# Sort by parcel ID\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f"
  },
  {
    "query": "find commercial parcels zoned for retail use with fewer than 3 competing retail businesses within 300 meters.",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Filter POI for retail businesses\nretail_poi = poi[poi['business_type'].isin(['retail', 'restaurant'])]\n# Function to count nearby retail businesses\ndef count_nearby_retail(parcel_geom, retail_poi, buffer_distance=300):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    # Filter retail POI within buffer\n    nearby_retail = retail_poi[retail_poi.geometry.intersects(buffered_geom)]\n    return len(nearby_retail)\n# Calculate retail competition for each parcel\nretail_parcels.loc[:, 'competitor_count'] = retail_parcels.geometry.apply(\n    lambda geom: count_nearby_retail(geom, retail_poi)\n)\n# Filter for parcels with fewer than 3 competitors\nresult_parcels = retail_parcels[retail_parcels['competitor_count'] < 3].copy()\n# Sort by parcel ID\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f"
  },
  {
    "query": "find the top 20 commercial parcels within 1km of massachusetts avenue, prioritizing areas with higher consumer spending.",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\nspend_data = pd.read_csv('../data/cambridge_spend_processed.csv')\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels[parcels['use_code'].astype(str).isin(commercial_use_codes)].copy()\n# Set CRS for accurate distance measurement\ncommercial_parcels = commercial_parcels.to_crs(epsg=26986)\n# Define Massachusetts Avenue location\nmass_ave = gpd.GeoSeries([\n    # Approximate line for Massachusetts Avenue\n    # Start point\n    (-71.1056, 42.3676), \n    # End point\n    (-71.0942, 42.3655)\n]).set_crs(epsg=4326).to_crs(epsg=26986)\n# Calculate spending per capita\ncensus = census.merge(spend_data, on='GEOID', how='left')\ncensus['spend_per_capita'] = census['total_spend'] / census['population']\n# Fill NaN values with 0\ncensus['spend_per_capita'] = census['spend_per_capita'].fillna(0)\n# Project to metric CRS\npoi = poi.to_crs(epsg=26986)\ncensus = census.to_crs(epsg=26986)\n# Create 1km buffer around Massachusetts Avenue\nmass_ave_buffer = mass_ave.buffer(1000).iloc[0]\n# Filter parcels within 1km of Massachusetts Avenue\nparcels_near_mass_ave = commercial_parcels[commercial_parcels.geometry.intersects(mass_ave_buffer)].copy()\n# Prioritize areas with higher consumer spending\n# Spatial join with census data\nparcels_with_spending = gpd.sjoin(\n    parcels_near_mass_ave,\n    census,\n    how='left',\n    predicate='within'\n)\n# Sort by spending (higher is better)\nresult_parcels = parcels_with_spending.sort_values('spend_per_capita', ascending=False)\n# Get top 20 parcels\ntop_spending_parcels = result_parcels.head(20)\n# Convert back to original CRS\ntop_spending_parcels = top_spending_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = top_spending_parcels['ml'].tolist()\nprint(result_ids)"
  },
  {
    "query": "find commercial parcels larger than 8000 square feet in census tracts with at least 90% of residents aged 18-64.",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels[parcels['use_code'].astype(str).isin(commercial_use_codes)].copy()\n# Filter by size (>8000 sq ft)\nlarge_commercial_parcels = commercial_parcels[commercial_parcels['land_area'] > 8000].copy()\n# Project to metric CRS for accurate spatial analysis\nlarge_commercial_parcels_proj = large_commercial_parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Define age group filter (90% of residents aged 18-64)\n# Calculate number of residents in age group\ncensus_proj['total_population'] = (\n    census_proj['pct_18_24'] + census_proj['pct_25_34'] + \n    census_proj['pct_35_44'] + census_proj['pct_45_54'] + \n    census_proj['pct_55_64']\n) * census_proj['total_population'] / 100\n# Calculate number of residents outside age group\ncensus_proj['pct_under_18'] = census_proj['pct_under_18'].fillna(0)\ncensus_proj['pct_over_64'] = census_proj['pct_over_64'].fillna(0)\ncensus_proj['total_population'] = census_proj['total_population'].fillna(census_proj['total_population'])\ncensus_proj['residents_outside_age_group'] = (\n    census_proj['pct_under_18'] + census_proj['pct_over_64']\n) * census_proj['total_population'] / 100\n# Calculate percentage of residents aged 18-64\ncensus_proj['pct_18_64'] = (\n    100 - (census_proj['pct_under_18'].fillna(0) + census_proj['pct_over_64'].fillna(0))\n)\n# Filter for tracts with at least 90% of residents aged 18-64\ncensus_age_filtered = census_proj[census_proj['pct_18_64'] >= 90].copy()\n# Find large commercial parcels in eligible tracts\ndef parcel_in_census(parcel_geom, parcel_tract, census_geoms, census_tracts):\n    for geom, tract in zip(census_geoms, census_tracts):\n        if parcel_geom.intersects(geom):\n            return tract\n    return None\n# Get eligible tract IDs\neligible_tracts = census_age_filtered['tract'].tolist()\n# Filter by tract\nlarge_parcels_in_eligible_tracts = large_commercial_parcels_proj[\n    large_commercial_parcels_proj['ml'].apply(\n        lambda x: parcel_in_census(\n            large_commercial_parcels_proj.loc[large_commercial_parcels_proj['ml'] == x].geometry.values[0],\n            x,\n            census_proj['geometry'].tolist(),\n            census_proj['tract'].tolist()\n        )\n    ).isin(eligible_tracts)\n].copy()\n# Sort by parcel ID\nresult_parcels = large_parcels_in_eligible_tracts.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"
  },
  {
    "query": "find commercial parcels that are between 5000-10000 square feet, within 500 meters of a subway station, and have no more than 1 competitor within 500 meters.",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define subway station locations\nsubway_stations = [\n    (-71.1189, 42.3736),  # Harvard Square\n    (-71.1032, 42.3656),  # Central Square\n    (-71.0865, 42.3625),  # Kendall/MIT\n    (-71.1226, 42.3782),  # Porter Square\n    (-71.1429, 42.3954)   # Alewife\n]\nsubway_gdf = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy([lon], [lat])[0] for lon, lat in subway_stations],\n    crs=parcels.crs\n)\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\nsubway_gdf_proj = subway_gdf.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Filter for commercial parcels (use specific codes for commercial)\ncommercial_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith(('3', '4'))]\n# Filter by size (5000-10000 sq ft)\nsize_filtered = commercial_parcels[\n    (commercial_parcels['land_area'] >= 5000) & \n    (commercial_parcels['land_area'] <= 10000)\n]\n# Filter by proximity to subway stations (within 500m)\n# Use buffered subway stations for proximity\nsubway_buffers = [geom.buffer(500) for geom in subway_gdf_proj.geometry]\nsubway_union_buffer = gpd.GeoSeries(subway_buffers).unary_union\nsize_filtered_within_500m_subway = size_filtered[\n    size_filtered.geometry.intersects(subway_union_buffer)\n]\n# Competitor analysis\n# Define commercial POI types (restaurants, cafes, etc.)\ncommercial_poi_types = [\n    'restaurant', 'cafe', 'fast_food_restaurant', 'bakery', 'bar', \n    'grocery_store', 'convenience_store', 'department_store', \n    'clothing_store', 'furniture_store', 'hardware_store', 'liquor_store'\n]\n# Filter POI for commercial types\ncommercial_poi = poi_proj[poi_proj['poi_type'].isin(commercial_poi_types)]\n# Function to count competitors within 500m\ndef count_competitors(parcel_geom, parcel_id, poi_geoms, buffer_distance=500):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    # Count POI within buffer\n    count = sum(1 for geom in poi_geoms if geom is not None and buffered_geom.contains(geom))\n    return count\n# Get POI geometries\ncommercial_poi_geoms = commercial_poi['geometry'].tolist()\n# Calculate competitor count for each parcel\ncompetitor_counts = []\nfor idx, row in size_filtered_within_500m_subway.iterrows():\n    count = count_competitors(row['geometry'], row['ml'], commercial_poi_geoms)\n    competitor_counts.append(count)\n# Filter for parcels with at most 1 competitor\nresult_parcels = size_filtered_within_500m_subway[\n    [count <= 1 for count in competitor_counts]\n]\n# Sort by parcel ID (ml)\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels meeting all criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"
  },
  {
    "query": "find parcels that are zoned for mixed-use, within 400 meters of public transportation, and at least 200 meters away from industrial areas.",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Filter for mixed-use parcels (business and residential combined)\nmixed_use_codes = ['323', '324', '345', '346', '353', '362', '375', '404', '406']\nmixed_use_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(mixed_use_codes)].copy()\n# Filter for public transportation (subway stations and major bus stops)\nsubway_stations = poi_proj[poi_proj['poi_type'] == 'subway_station'].copy()\nbus_stops = poi_proj[poi_proj['poi_type'] == 'bus_stop'].copy()\n# Combine subway stations and bus stops\ntransportation_points = pd.concat([subway_stations, bus_stops]).drop_duplicates().copy()\n# Function to check proximity to transportation\ndef is_near_transport(parcel_geom, transportation_geoms, buffer_distance=400):\n    buffered_geoms = [geom.buffer(buffer_distance) for geom in transportation_geoms]\n    return any(parcel_geom.intersects(bg) for bg in buffered_geoms)\n# Get transportation geometries\ntransportation_geoms = transportation_points['geometry'].tolist()\n# Filter for parcels near transportation (within 400m)\nnear_transport_parcels = mixed_use_parcels[mixed_use_parcels.geometry.apply(\n    lambda geom: is_near_transport(geom, transportation_geoms)\n)].copy()\n# Filter for industrial parcels (use codes 300-399)\nindustrial_codes = ['302', '316', '318', '323', '324', '325', '326', '327', '330', '332', '334', '340', '341', '343', '345', '346', '347', '350', '351', '352', '362']\nindustrial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(industrial_codes)].copy()\n# Function to check distance from industrial areas\ndef is_away_from_industrial(parcel_geom, industrial_geoms, min_distance=200):\n    buffered_geoms = [geom.buffer(-min_distance) for geom in industrial_geoms]\n    return all(not parcel_geom.intersects(bg) for bg in buffered_geoms)\n# Get industrial geometries\nindustrial_geoms = industrial_parcels['geometry'].tolist()\n# Filter for parcels at least 200m away from industrial areas\nfinal_parcels = near_transport_parcels[near_transport_parcels.geometry.apply(\n    lambda geom: is_away_from_industrial(geom, industrial_geoms)\n)].copy()\n# Sort by parcel ID (ml column)\nfinal_parcels = final_parcels.sort_values('ml')\n# Convert back to original CRS\nfinal_parcels = final_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} parcels meeting all criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"
  },
  {
    "query": "find retail parcels between 2000-5000 square feet within 500m of a residential area, prioritizing locations with high foot traffic and in census tracts with median income above $30,000.",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Convert to projected CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Filter retail parcels (use specific retail use codes for Cambridge)\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Filter by size (2000-5000 sq ft)\nretail_parcels = retail_parcels[(retail_parcels['land_area'] >= 2000) & (retail_parcels['land_area'] <= 5000)].copy()\n# Define residential use codes\nresidential_use_codes = ['101', '1014', '102', '104', '105', '109', '1094', '1095', '1098', '111', '112', '113', '114', '121', '970', '9700']\n# Identify residential parcels\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_use_codes)].copy()\n# Create 500m buffer around residential areas\nresidential_buffers = [geom.buffer(500) for geom in residential_parcels.geometry]\nresidential_union_buffer = gpd.GeoSeries(residential_buffers).unary_union\n# Filter retail parcels within 500m of residential areas\nretail_near_residential = retail_parcels[retail_parcels.geometry.intersects(residential_union_buffer)].copy()\n# Prioritize by foot traffic (use POI data)\n# Function to calculate foot traffic based on POI density\ndef calculate_foot_traffic(parcel_geom, poi_geoms, buffer_distance=100):\n    buffer = parcel_geom.buffer(buffer_distance)\n    # Count POI within buffer (more POI = higher foot traffic)\n    poi_count = sum(1 for geom in poi_geoms if buffer.contains(geom))\n    return poi_count\n# Get all POI geometries\npoi_geoms = poi_proj['geometry'].tolist()\n# Calculate foot traffic for each parcel\nretail_near_residential.loc[:, 'foot_traffic'] = retail_near_residential.geometry.apply(\n    lambda geom: calculate_foot_traffic(geom, poi_geoms)\n)\n# Sort by foot traffic (higher is better)\nretail_near_residential = retail_near_residential.sort_values('foot_traffic', ascending=False)\n# Filter by income (census tract level)\n# First, assign each retail parcel to a census tract\n# Convert to census tract geometries\ncensus_tracts = census_proj['geometry'].tolist()\ncensus_tract_ids = census_proj['tract'].tolist()\n# Function to find census tract for a given parcel\ndef find_census_tract(parcel_geom, tract_geoms, tract_ids):\n    for i, geom in enumerate(tract_geoms):\n        if geom.contains(parcel_geom):\n            return tract_ids[i]\n    return None\n# Assign census tract to each parcel\nretail_near_residential.loc[:, 'census_tract'] = retail_near_residential.geometry.apply(\n    lambda geom: find_census_tract(geom, census_tracts, census_tract_ids)\n)\n# Filter for parcels in high-income areas (median income > $30,000)\n# First, merge with census data to get income\nparcels_with_income = retail_near_residential.merge(\n    census_proj,\n    left='census_tract',\n    right='tract',\n    how='left'\n)\n# Filter for high-income areas\nif 'median_income' in parcels_with_income.columns:\n    high_income_parcels = parcels_with_income[parcels_with_income['median_income'] > 30000].copy()\nelse:\n    # If median_income is not available, use another income metric\n    high_income_parcels = parcels_with_income.copy()\n    if 'avg_income' in parcels_with_income.columns:\n        high_income_parcels = high_income_parcels[high_income_parcels['avg_income'] > 30000].copy()\n    elif 'income' in parcels_with_income.columns:\n        high_income_parcels = high_income_parcels[high_income_parcels['income'] > 30000].copy()\n# Sort by foot traffic (higher is better)\nhigh_income_parcels = high_income_parcels.sort_values('foot_traffic', ascending=False)\n# Get parcel IDs (ml column) for final result\nresult_ids = high_income_parcels['ml'].tolist()\n# Convert back to original CRS\nresult_parcels = high_income_parcels.to_crs(parcels.crs)\n# Print results\nprint(f\"Found {len(high_income_parcels)} parcels meeting all criteria\")\nprint(f\"Parcel IDs (ml) sorted by foot traffic:\")\nprint(result_ids)"
  },
  {
    "query": "find office parcels larger than 5000 square feet with at least 2 parking spaces, prioritizing those in areas with high educational attainment.",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Filter for office parcels (use use_code for more accurate filtering)\noffice_use_codes = ['340', '343', '345', '346', '0340', '0343', '0345', '0346']\noffice_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith(('34', '040'))]\n# Filter for parcels larger than 5000 sq ft\nlarge_office_parcels = office_parcels[office_parcels['land_area'] > 5000]\n# Filter for parcels with at least 2 parking spaces\n# Estimate parking spaces from POI data (if available)\n# For simplicity, assume each office parcel has a certain number of parking spaces\n# This is a rough estimate and may not be accurate\n# For more accurate results, we would need detailed parking data\n# For now, let's assume a fixed ratio of 1 space per 300 sq ft of building area\n# This is a common estimate for office buildings\n# Calculate estimated parking spaces\nlarge_office_parcels = large_office_parcels.copy()\nlarge_office_parcels['estimated_parking'] = large_office_parcels['gross_area'] / 300\n# Filter for parcels with at least 2 parking spaces\nlarge_office_with_parking = large_office_parcels[large_office_parcels['estimated_parking'] >= 2]\n# Spatial join with census data to get educational attainment\n# Use centroid of parcel for more accurate join\nparcels_with_centroid = large_office_with_parking.copy()\nparcels_with_centroid['geometry'] = parcels_with_centroid.centroid\nparcels_with_centroid = parcels_with_centroid.set_geometry('geometry')\n# Perform spatial join\njoined = gpd.sjoin(parcels_with_centroid, census_proj, how='left', predicate='within')\n# Prioritize by educational attainment (higher is better)\n# Check if educational attainment column exists\nif 'pct_bachelors' in joined.columns:\n    # If we have pct_bachelors, use that\n    prioritized = joined.sort_values('pct_bachelors', ascending=False)\nelif 'pct_degree' in joined.columns:\n    # If we have pct_degree, use that\n    prioritized = joined.sort_values('pct_degree', ascending=False)\nelse:\n    # If we don't have educational attainment data, just use original order\n    prioritized = joined\n# Convert back to original CRS\nfinal_parcels = prioritized.to_crs(parcels.crs)\n# Sort by parcel ID for consistency\nfinal_parcels = final_parcels.sort_values('ml')\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} parcels meeting all criteria\")\nprint(f\"Parcel IDs (prioritized by educational attainment): {result_ids}\")"
  },
  {
    "query": "find parcels that are either commercial places within 100m of harvard square or residential larger than 5000 square feet and within 200m of 50 restaurants.",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define Harvard Square location\nharvard_square = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy(-71.1189, 42.3736)],\n    crs=parcels.crs\n)\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\nharvard_square_proj = harvard_square.to_crs(epsg=26986)\n# CONDITION 1: Commercial parcels within 100m of Harvard Square\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_use_codes)].copy()\n# Filter by proximity to Harvard Square\ncommercial_near_harvard = commercial_parcels[commercial_parcels.geometry.distance(harvard_square_proj.iloc[0]) <= 100].copy()\n# CONDITION 2: Residential parcels larger than 5000 sqft within 200m of 50 restaurants\n# Define residential use codes\nresidential_use_codes = [\n    '101', '1014', '102', '1028', '104', '105', '109', '1094', '1095', '1098',\n    '942', '9420', '943', '9430', '950', '951', '952', '970', '9700', '971', '972'\n]\n# Filter for residential parcels\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_use_codes)].copy()\n# Filter for restaurants from POI data\nrestaurant_poi = poi[poi['business_type'] == 'restaurant'].copy()\n# Get 50 random restaurants\nrestaurant_ids = restaurant_poi.sample(50, random_state=42)['place_id'].tolist()\n# Filter for specific restaurants\nspecific_restaurants = restaurant_poi[restaurant_poi['place_id'].isin(restaurant_ids)].copy()\n# Filter by proximity to restaurants\ndef near_restaurants(parcel_geom, restaurant_geoms, buffer_distance=200):\n    buffered_restaurants = [geom.buffer(buffer_distance) for geom in restaurant_geoms]\n    return any(parcel_geom.intersects(br) for br in buffered_restaurants)\n# Get restaurant geometries\nrestaurant_geoms = specific_restaurants['geometry'].tolist()\n# Filter residential parcels by restaurant proximity\nresidential_near_restaurants = []\nfor idx, row in residential_parcels.iterrows():\n    if near_restaurants(row.geometry, restaurant_geoms):\n        residential_near_restaurants.append(row['ml'])\nresidential_near_restaurants = set(residential_near_restaurants)\n# Filter for large residential parcels (over 5000 sqft)\nlarge_residential = parcels_proj[\n    (parcels_proj['ml'].isin(residential_near_restaurants)) & \n    (parcels_proj['land_area'] > 5000)\n].copy()\n# COMBINE CONDITIONS (OR)\n# Mark commercial near Harvard\nfor idx in commercial_near_harvard['ml']:\n    parcels_proj.loc[parcels_proj['ml'] == idx, 'condition'] = 'commercial_near_harvard'\n# Mark large residential near restaurants\nfor idx in large_residential['ml']:\n    parcels_proj.loc[parcels_proj['ml'] == idx, 'condition'] = 'large_residential_near_restaurants'\n# Filter for any parcels that meet either condition\nresult_parcels = parcels_proj[parcels_proj.get('condition').notnull()].copy()\n# Sort by parcel ID\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels meeting either condition\")\nprint(f\"Parcel IDs: {result_ids}\")"
  },
  {
    "query": "find parcels that are zoned for retail and within 300m of a subway station and not within 100m of a competitor.",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('../data/cambridge_spend_processed.csv')\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Filter subway POIs\nsubway_pois = poi[poi['business_type'] == 'subway'].copy()\n# Project POIs to same CRS\nsubway_pois_proj = subway_pois.to_crs(parcels_proj.crs)\n# Define function to check competitor distance\ndef has_no_nearby_competitor(parcel_geom, parcel_type, poi_geoms, poi_types, buffer_distance=100):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    for poi_geom, poi_type in zip(poi_geoms, poi_types):\n        if poi_type in ['restaurant', 'grocery_store', 'convenience_store', 'department_store']:\n            if poi_geom is not None and buffered_geom.contains(poi_geom):\n                return False\n    return True\n# Filter for retail competitors\nretail_competitor_types = ['restaurant', 'grocery_store', 'convenience_store', 'department_store']\n# Filter subway POIs\nsubway_pois = poi[poi['business_type'] == 'subway'].copy()\n# Project POIs to same CRS\nsubway_pois_proj = subway_pois.to_crs(parcels_proj.crs)\n# Find retail parcels within 300m of subway stations\ndef is_near_subway(parcel_geom, subway_geoms, threshold=300):\n    if parcel_geom is None:\n        return False\n    for geom in subway_geoms:\n        if geom is not None and parcel_geom.distance(geom) <= threshold:\n            return True\n    return False\n# Get subway geometries\nsubway_geoms = subway_pois_proj['geometry'].tolist()\n# Filter for retail parcels near subway\nretail_near_subway = retail_parcels[retail_parcels.geometry.apply(lambda x: is_near_subway(x, subway_geoms))].copy()\n# Filter for parcels without nearby retail competitors\n# Get POI geometries and types\npoi_geoms = poi['geometry'].tolist()\npoi_types = poi['business_type'].tolist()\n# Check for competitors\nretail_no_competitor = []\nfor idx, row in retail_near_subway.iterrows():\n    if has_no_nearby_competitor(row['geometry'], row['use_code'], poi_geoms, poi_types):\n        retail_no_competitor.append(row['ml'])\n# Sort by parcel ID\nretail_no_competitor.sort()\n# Convert back to original CRS\nresult_parcels = parcels.loc[parcels_proj.loc[retail_no_competitor].index].copy()\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"
  },
  {
    "query": "find parcels that are either office space larger than 10,000 sq ft or retail space within 500m of high-density residential areas.",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Filter for office space (use specific use codes for offices)\noffice_use_codes = ['340', '343', '345', '346', '0340', '404', '406']  # Common office use codes\nlarge_offices = parcels_proj[parcels_proj['use_code'].astype(str).isin(office_use_codes) & (parcels_proj['land_area'] > 10000)]\n# Filter for high-density residential areas (use specific residential codes)\nhigh_density_res_codes = ['111', '112', '114', '123', '0111', '0112', '0114', '0123']  # Common high-density residential codes\nhigh_density_res = parcels_proj[parcels_proj['use_code'].astype(str).isin(high_density_res_codes)]\n# Create 500m buffer around high-density residential parcels\nhigh_density_buffers = [geom.buffer(500) for geom in high_density_res.geometry]\nhigh_density_union_buffer = gpd.GeoSeries(high_density_buffers).unary_union\n# Filter retail space (use specific retail use codes)\nretail_use_codes = ['323', '324', '325', '326', '327', '330']  # Common retail use codes\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)]\n# Filter retail that is within 500m of high-density residential areas\nretail_near_high_density = retail_parcels[retail_parcels.geometry.intersects(high_density_union_buffer)]\n# Combine both criteria (offices larger than 10,000 sq ft OR retail near high-density residential)\ncombined_ids = pd.concat([large_offices['ml'], retail_near_high_density['ml']])\n# Remove duplicates\ncombined_ids = combined_ids.unique()\n# Sort by parcel ID\ncombined_ids.sort()\n# Print results\nprint(f\"Found {len(combined_ids)} parcels matching either criterion\")\nprint(f\"Parcel IDs: {combined_ids.tolist()}\")"
  },
  {
    "query": "find commercial parcels that, if larger than 5000 sq ft, must be within 400m of public transit, or if smaller, must be within 200m of residential areas.",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(cambridge_crs)\n# Filter for commercial parcels\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_use_codes)].copy()\n# Separate large and small commercial parcels\nlarge_commercial = commercial_parcels[commercial_parcels['land_area'] > 5000].copy()\nsmall_commercial = commercial_parcels[commercial_parcels['land_area'] <= 5000].copy()\n# Define transit POI types (subway stations, bus stations, etc.)\ntransit_poi_types = ['subway', 'bus', 'train']\n# Filter for transit POIs\ntransit_poi = poi[poi['poi_type'].isin(transit_poi_types)].copy()\n# Ensure POIs have geometry\ntransit_poi = transit_poi[transit_poi.geometry.notnull()]\n# Create 400m buffer around transit POIs for large commercial parcels\ntransit_buffers = [geom.buffer(400) for geom in transit_poi.geometry]\ntransit_union_buffer = gpd.GeoSeries(transit_buffers).unary_union\n# CONDITION 1: Large commercial parcels within 400m of transit\nlarge_near_transit = large_commercial[large_commercial.geometry.intersects(transit_union_buffer)].copy()\n# Filter for residential areas in census data\n# Assume residential areas have a high percentage of residential units\n# This is a heuristic approach since we don't have direct land use data\n# We'll use areas with >50% residential units as a proxy for residential neighborhoods\nresidential_census = census[census['pct_residential_units'] > 50].copy()\n# Create 200m buffer around residential areas for small commercial parcels\nresidential_buffers = [geom.buffer(200) for geom in residential_census.geometry]\nresidential_union_buffer = gpd.GeoSeries(residential_buffers).unary_union\n# CONDITION 2: Small commercial parcels within 200m of residential areas\nsmall_near_residential = small_commercial[small_commercial.geometry.intersects(residential_union_buffer)].copy()\n# Combine results from both conditions\ncombined_results = pd.concat([large_near_transit, small_near_residential])\n# Sort by parcel ID (ml)\nfinal_ids = combined_results['ml'].sort_values().tolist()\n# Output results\nprint(final_ids)"
  },
  {
    "query": "find parcels that are: if zoned for commercial, must be larger than 8000 sq ft; if zoned for residential, must have less than 2 similar properties within 1000m",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(epsg=cambridge_crs)\npoi_proj = poi.to_crs(epsg=cambridge_crs)\ncensus_proj = census.to_crs(epsg=cambridge_crs)\n# Filter commercial parcels (use specific commercial use codes)\ncommercial_use_codes = ['300', '302', '316', '323', '324', '325', '326', '327', '330', '332', '334', '340', '341', '343', '345', '346', '353', '362', '375', '404', '406']\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_use_codes)].copy()\n# Filter residential parcels (use specific residential use codes)\nresidential_use_codes = ['101', '1014', '102', '1024', '104', '109', '1094', '1095', '1098', '111', '112', '113', '114', '121', '970', '9700']\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_use_codes)].copy()\n# CONDITION 1: Commercial parcels larger than 8000 sq ft\nlarge_commercial = commercial_parcels[commercial_parcels['land_area'] > 8000].copy()\n# CONDITION 2: Residential parcels with less than 2 similar properties within 1000m\n# Function to count similar properties within 1000m\ndef count_similar_properties(parcel_geom, parcel_type, all_parcels, buffer_distance=1000):\n    # Get the specific residential type\n    specific_type = str(parcel_type)\n    \n    # Find similar properties (same type)\n    similar_parcels = all_parcels[all_parcels['use_code'].astype(str) == specific_type].copy()\n    \n    # Create buffer\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    \n    # Count similar properties within buffer (excluding the parcel itself)\n    similar_within_buffer = similar_parcels[similar_parcels.geometry.intersects(buffered_geom)].copy()\n    \n    # Subtract 1 to exclude the parcel itself\n    count = len(similar_within_buffer) - 1\n    return max(0, count)  # Ensure count is not negative\n# Calculate similar property count for each residential parcel\nresidential_parcels.loc[:, 'similar_count'] = [\n    count_similar_properties(row.geometry, row.use_code, residential_parcels)\n    for idx, row in residential_parcels.iterrows()\n]\n# Filter for residential parcels with less than 2 similar properties\nresidential_low_density = residential_parcels[residential_parcels['similar_count'] < 2].copy()\n# COMBINE RESULTS\n# Add a flag to identify which condition each parcel meets\nlarge_commercial.loc[:, 'condition'] = 'large_commercial'\nresidential_low_density.loc[:, 'condition'] = 'low_density_residential'\ncombined = pd.concat([large_commercial, residential_low_density])\n# Sort by parcel ID (ml column)\ncombined = combined.sort_values('ml')\n# Convert back to original CRS\ncombined = combined.to_crs(parcels.crs)\n# Output results\nresult_ids = combined['ml'].tolist()\nprint(result_ids)"
  },
  {
    "query": "find mixed-use parcels that, if north of massachusetts avenue, must have retail on the ground floor, otherwise must have at least 3000 sq ft of commercial space.",
    "method": "fine-tuned",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define retail business codes\nretail_bcodes = ['101', '1011', '102', '1021', '103', '104', '105', '106', '107', '109', \n                '202', '212', '213', '314', '315', '316', '323', '324', '325', '326', \n                '327', '330', '332', '334', '335', '336', '337', '338', '340', '341', \n                '343', '345', '346', '347', '350', '351', '353', '362', '375']\n# Filter for mixed-use parcels\nmu_parcels = parcels[parcels['use_code'].astype(str).str.startswith(('3', '4'))].copy()\n# Project to metric CRS for accurate spatial analysis\nmu_parcels_proj = mu_parcels.to_crs(epsg=26986)\n# Define Massachusetts Avenue line\nmass_ave_coords = [(-71.106398, 42.3676), (-71.105, 42.3673), (-71.104, 42.3669), \n                   (-71.103, 42.3665), (-71.102, 42.3661), (-71.101, 42.3657), \n                   (-71.100, 42.3653), (-71.099, 42.365)]\nmass_ave_line = gpd.GeoSeries([gpd.LineString(mass_ave_coords)], crs=mu_parcels.crs).to_crs(epsg=26986)\n# Determine which parcels are north of Massachusetts Avenue\nmu_parcels_proj['north_of_mass_ave'] = mu_parcels_proj.geometry.apply(\n    lambda geom: geom.centroid.y > mass_ave_line.iloc[0].bounds[1]\n)\n# CONDITION 1: If north of Mass Ave, must have retail on ground floor\n# Filter POI for retail businesses\nretail_poi = poi[poi['business_code'].astype(str).isin(retail_bcodes)].copy()\n# Spatial join to get retail businesses on ground floor for each parcel\nretail_on_ground_floor = gpd.sjoin(\n    mu_parcels_proj[mu_parcels_proj['north_of_mass_ave']],\n    retail_poi,\n    how='left',\n    predicate='intersects'\n)\n# CONDITION 2: If not north of Mass Ave, must have at least 3000 sq ft of commercial space\n# For mixed-use parcels, estimate commercial space from existing data\n# Assuming commercial space is a percentage of total area\n# For '3' use codes (multifamily), typically 30-40% is commercial\n# For '4' use codes (commercial), typically 100% is commercial\ndef estimate_commercial_space(use_code, total_area):\n    use_code = str(use_code)\n    if use_code.startswith('3'):\n        return total_area * 0.35  # 35% for multifamily\n    elif use_code.startswith('4'):\n        return total_area  # 100% for commercial\n    return 0\n# Calculate estimated commercial space\nmu_parcels_proj['estimated_commercial_space'] = mu_parcels_proj.apply(\n    lambda row: estimate_commercial_space(row['use_code'], row['land_area']), axis=1\n)\n# Filter for parcels not north of Mass Ave and with sufficient commercial space\nsouth_of_mass_ave = mu_parcels_proj[~mu_parcels_proj['north_of_mass_ave']].copy()\nsouth_condition = south_of_mass_ave[south_of_mass_ave['estimated_commercial_space'] >= 3000]\n# Combine conditions\nfinal_parcels = pd.concat([\n    retail_on_ground_floor.dropna(subset=['business_code']),\n    south_condition\n])\n# Sort by parcel ID\nfinal_parcels = final_parcels.sort_values('ml')\n# Convert back to original CRS\nfinal_parcels = final_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"
  }
]