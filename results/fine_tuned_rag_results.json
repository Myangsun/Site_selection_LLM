[
  {
    "query": "find commercial parcels within 500 meters of harvard square.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define Harvard Square location (approximate)\nharvard_square = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy(-71.1189, 42.3736)],\n    crs=parcels.crs\n)\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\nharvard_square_proj = harvard_square.to_crs(epsg=26986)\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).str.startswith(('3', '4'))]\n# Create 500m buffer around Harvard Square\nharvard_buffer = harvard_square_proj.buffer(500)\n# Find commercial parcels within 500m of Harvard Square\nresult_parcels = commercial_parcels[commercial_parcels.geometry.intersects(harvard_buffer.iloc[0])]\n# Sort by parcel ID (ml)\nresult_ids = result_parcels['ml'].tolist()\nresult_ids.sort()\n# Print results\nprint(f"
  },
  {
    "exact_match": 1.0,
    "result_match_rate": 1.0,
    "precision": 1.0,
    "recall": 1.0,
    "f1_score": 1.0,
    "generated_count": 81,
    "ground_truth_count": 81,
    "correct_count": 81,
    "query": "find parcels larger than 6000 square feet that are zoned for retail use.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": true,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\n# Define retail use codes consistently\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Filter for retail parcels\nretail_parcels = parcels[parcels['use_code'].astype(str).isin(retail_use_codes)]\n# Filter for large retail parcels (>6000 sq ft)\nlarge_retail_parcels = retail_parcels[retail_parcels['land_area'] > 6000]\n# Sort by parcel ID (ml)\nresult_parcels = large_retail_parcels.sort_values('ml')\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(result_ids)",
    "generated_ids": [
      "100-62",
      "105-68",
      "105-82",
      "106-124",
      "107-117",
      "107-9",
      "109-50",
      "110-91",
      "116-12",
      "120-48",
      "125-73",
      "128-63",
      "128-72",
      "134-33",
      "136-15",
      "140-148",
      "152-25",
      "156-25",
      "157-26",
      "16-11",
      "162-26",
      "162-54",
      "169-46",
      "169-47",
      "174-37",
      "175-37",
      "175-75",
      "175-84",
      "176-15",
      "176-64",
      "179-87",
      "18-64",
      "18-65",
      "180-57",
      "182-88",
      "183-100",
      "184-159",
      "189-72",
      "191-65",
      "191-85",
      "192-121",
      "192-177",
      "196-154",
      "199-30",
      "199-31",
      "199-67",
      "1A-189",
      "1A-192",
      "1A-211",
      "20-75",
      "200-22",
      "21-121",
      "226-46",
      "229-117",
      "230-71",
      "234-178",
      "236-95",
      "252-172",
      "260-46",
      "260-76",
      "265B-26",
      "265B-28",
      "265B-61",
      "265C-25",
      "267E-234",
      "268B-15",
      "273-2",
      "273-20",
      "34-8",
      "70-91",
      "70-92",
      "74-1",
      "8-88",
      "81-100",
      "83-80",
      "84-101",
      "84-91",
      "90-155",
      "90-162",
      "92-88",
      "93-78"
    ]
  },
  {
    "exact_match": 1.0,
    "result_match_rate": 1.0,
    "precision": 1.0,
    "recall": 1.0,
    "f1_score": 1.0,
    "generated_count": 57,
    "ground_truth_count": 57,
    "correct_count": 57,
    "query": "find all parcels that have no more than 2 competing restaurants within 800 meters.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": true,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\n# Define restaurant POI codes\nrestaurant_codes = ['R', 'R1', 'R2', 'R3', 'R4', 'R5']\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Filter for restaurants\nrestaurants = poi_proj[poi_proj['business_type'].astype(str).str.startswith('restaurant')]\n# Function to count nearby restaurants\ndef count_nearby_restaurants(parcel_geom, all_restaurants, buffer_distance=800):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    nearby_restaurants = all_restaurants[all_restaurants.geometry.intersects(buffered_geom)]\n    return len(nearby_restaurants)\n# Calculate restaurant count for each parcel\nparcels_proj = parcels_proj.assign(restaurant_count=parcels_proj.geometry.apply(\n    lambda geom: count_nearby_restaurants(geom, restaurants, buffer_distance=800)\n))\n# Filter for parcels with no more than 2 competing restaurants\nresult_parcels = parcels_proj[parcels_proj['restaurant_count'] <= 2]\n# Sort by parcel ID\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(result_ids)",
    "generated_ids": [
      "242-33",
      "242-34",
      "242-36",
      "242-38",
      "242A-100",
      "242A-102",
      "242A-105",
      "242A-107",
      "242A-109",
      "242A-110",
      "242A-111",
      "242A-112",
      "242A-113",
      "242A-115",
      "242A-116",
      "242A-126",
      "242A-127",
      "242A-131",
      "242A-148",
      "242A-158",
      "242A-159",
      "242A-160",
      "242A-161",
      "242A-162",
      "242A-59",
      "242A-68",
      "242A-72",
      "242A-73",
      "242A-75",
      "242A-91",
      "242A-99",
      "242B-999",
      "243-1",
      "266-1",
      "266-10",
      "266-12",
      "266-13",
      "266-14",
      "266-15",
      "266-16",
      "266-17",
      "266-18",
      "266-19",
      "266-2",
      "266-20",
      "266-21",
      "266-3",
      "266-35",
      "266-36",
      "266-37",
      "266-38",
      "266-4",
      "266-5",
      "266-6",
      "266-7",
      "266-8",
      "266-9"
    ]
  },
  {
    "query": "find the top 20 parcels in cambridge with the most diverse mix of residential and commercial land uses within 500 meters.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define project CRS for Cambridge\ncambridge_crs = 26986\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Filter for residential parcels\nresidential_codes = [\n    '101', '1014', '102', '1024', '1025', '103', '104', '109', '1094', \n    '1095', '1098', '121', '970', '9700', '971', '9710', '972', '9720', \n    '942', '9420', '943', '9430', '944', '9440', '946', '9460', '947', \n    '9470', '948', '9480', '150', '1500', '151', '1510', '152', '1520', \n    '153', '1530', '154', '1540', '155', '1550', '156', '1560', '157', \n    '1570', '158', '1580', '160', '1600', '161', '1610', '162', '1620', \n    '9701', '9702', '9703', '9704', '9705', '9706', '9707', '9708', '9709'\n]\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_codes)]\n# Filter for commercial parcels\ncommercial_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', '330', '332', \n    '334', '340', '341', '343', '345', '346', '353', '362', '375', '404', \n    '406', '0340', '0406', '0405', '0410', '0420', '0430', '0440', '0450'\n]\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_codes)]\n# Function to calculate land use diversity\ndef land_use_diversity(parcel_geom, poi_geoms, buffer_distance=500):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    # Filter POI within buffer\n    poi_within_buffer = poi_geoms[poi_geoms.geometry.apply(lambda x: buffered_geom.contains(x))]\n    \n    # Count unique business types\n    if not poi_within_buffer.empty:\n        business_types = poi_within_buffer['business_type'].dropna().unique()\n        diversity_score = len(business_types)\n    else:\n        diversity_score = 0\n    \n    return diversity_score\n# Calculate diversity for each residential parcel\nresidential_parcels.loc[:, 'diversity'] = [\n    land_use_diversity(row.geometry, poi_proj.geometry) for idx, row in residential_parcels.iterrows()\n]\n# Sort by diversity (higher is better)\ndiverse_residential = residential_parcels.sort_values('diversity', ascending=False)\n# Get top 20\ntop20_diverse = diverse_residential.head(20)\n# Convert back to original CRS\ntop20_ids = top20_diverse['ml'].tolist()\n# Print results\nprint(f\"Top 20 parcels with diverse land use (IDs): {top20_ids}\")"
  },
  {
    "query": "find the top 20 commercial parcels in areas with the highest percentage of residents with advanced degrees.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels[parcels['use_code'].astype(str).isin(commercial_use_codes)].copy()\n# Project to metric CRS for accurate buffering\ncommercial_parcels_proj = commercial_parcels.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Sort by advanced degree percentage (higher is better)\ncensus_sorted = census_proj.sort_values('pct_adv_deg', ascending=False)\n# Define function to get parcels in same area as given parcel\ndef get_parcels_in_same_area(parcel_geom, parcel_id, buffer_distance=100):  # 100m buffer\n    # Get the tract for the given parcel\n    tract = commercial_parcels_proj[commercial_parcels_proj['ml'] == parcel_id]['tract'].values[0]\n    \n    # Get all parcels in the same tract\n    same_tract_parcels = commercial_parcels_proj[commercial_parcels_proj['tract'] == tract].copy()\n    \n    # Create buffered geometry\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    \n    # Filter by area (within buffer)\n    same_area_parcels = same_tract_parcels[same_tract_parcels.geometry.intersects(buffered_geom)].copy()\n    \n    return same_area_parcels\n# Find top 20 parcels from top census areas\ntop_parcels = []\nfor idx, row in census_sorted.iterrows():\n    parcel_id = row['ml']\n    if parcel_id in commercial_parcels_proj['ml'].values:\n        # Get parcels in same area\n        area_parcels = get_parcels_in_same_area(row['geometry'], parcel_id)\n        # Add to list with area ID\n        top_parcels.append((parcel_id, area_parcels))\n    if len(top_parcels) >= 20:\n        break\n# Sort by advanced degree percentage\ntop_parcels.sort(key=lambda x: x[1]['pct_adv_deg'].mean(), ascending=False)\n# Get final parcel IDs\nfinal_ids = [x[0] for x in top_parcels]\n# Print results\nprint(f"
  },
  {
    "query": "\u201cfind the top 20 parcels with the highest consumer spending in surrounding areas.\u201d",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\nspend_data = pd.read_csv('../data/cambridge_spend_processed.csv')\n# Convert to projected CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\ncensus_proj = census.to_crs(epsg=26986)\n# Merge spending data with parcels\nparcels_with_spend = parcels_proj.merge(\n    spend_data,\n    left_on='ml',\n    right_on='parcel_id',\n    how='left'\n)\n# Fill NaN values in spending with 0\nparcels_with_spend['total_spend'] = parcels_with_spend['total_spend'].fillna(0)\n# Sort by spending (higher is better)\nparcels_by_spend = parcels_with_spend.sort_values('total_spend', ascending=False)\n# Get top 20 parcels by spending\ntop_spend_parcels = parcels_by_spend.head(20)\n# Convert back to original CRS\ntop_spend_parcels = top_spend_parcels.to_crs(parcels.crs)\n# Output results\ntop_ids = top_spend_parcels['ml'].tolist()\nprint(top_ids)"
  },
  {
    "query": "find vacant commercial parcels larger than 3000 square feet that are within 800 meters of a subway station.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Filter for vacant commercial parcels larger than 3000 sq ft\nvacant_commercial = parcels_proj[\n    (parcels_proj['use_code'].astype(str).str.startswith(('340', '343', '345', '346', '353', '362', '375'))) &\n    (parcels_proj['land_area'] > 3000)\n].copy()\n# Filter subway stations from POI data\nsubway_stations = poi_proj[poi_proj['poi_type'] == 'subway_station'].copy()\n# Calculate 800m buffer around subway stations\nsubway_buffers = [geom.buffer(800) for geom in subway_stations.geometry]\nsubway_union_buffer = gpd.GeoSeries(subway_buffers).unary_union\n# Filter for parcels within 800m of subway stations\nnear_subway = vacant_commercial[vacant_commercial.geometry.intersects(subway_union_buffer)].copy()\n# Sort by parcel ID (ml column)\nresult_ids = near_subway['ml'].sort_values().tolist()\n# Print results\nprint(result_ids)"
  },
  {
    "exact_match": 0.0,
    "result_match_rate": 0.043010752688172046,
    "precision": 0.043010752688172046,
    "recall": 1.0,
    "f1_score": 0.08247422680412372,
    "generated_count": 186,
    "ground_truth_count": 8,
    "correct_count": 8,
    "query": "find commercial parcels zoned for retail use with fewer than 3 competing retail businesses within 300 meters.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": true,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Filter retail businesses from POI data\nretail_poi = poi[poi['business_type'].isin(['retail', 'restaurant'])].copy()\n# Function to count nearby retail businesses\ndef count_nearby_retail(parcel_geom, retail_geoms, buffer_distance=300):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    count = sum(1 for geom in retail_geoms if geom is not None and buffered_geom.contains(geom))\n    return count\n# Get retail POI geometries\nretail_poi_geoms = retail_poi['geometry'].tolist()\n# Calculate retail business count for each parcel\nretail_parcels.loc[:, 'nearby_retail'] = retail_parcels.geometry.apply(\n    lambda geom: count_nearby_retail(geom, retail_poi_geoms)\n)\n# Filter for parcels with fewer than 3 competing retail businesses\nresult_parcels = retail_parcels[retail_parcels['nearby_retail'] < 3].copy()\n# Sort by parcel ID (ml)\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(result_ids)",
    "generated_ids": [
      "100-62",
      "102-46",
      "105-68",
      "105-82",
      "106-109",
      "106-124",
      "107-117",
      "107-9",
      "108-54",
      "109-50",
      "110-91",
      "114A-120",
      "116-12",
      "116-94",
      "119-90",
      "120-48",
      "122-12",
      "125-73",
      "126-27",
      "128-63",
      "128-72",
      "133-12",
      "133-48",
      "133-52",
      "134-33",
      "136-15",
      "139-83",
      "140-148",
      "141-80",
      "150-114",
      "152-25",
      "154-111",
      "154-89",
      "154-97",
      "155-42",
      "156-25",
      "157-26",
      "159-2",
      "16-11",
      "160-63",
      "160-66",
      "160-76",
      "160-83",
      "160-84",
      "160-85",
      "162-18",
      "162-19",
      "162-26",
      "162-29",
      "162-54",
      "166-106",
      "166-13",
      "169-46",
      "169-47",
      "169-67",
      "169-68",
      "169-7",
      "169-86",
      "173-65",
      "174-27",
      "174-30",
      "174-33",
      "174-36",
      "174-37",
      "174-73",
      "175-37",
      "175-75",
      "175-84",
      "176-15",
      "176-64",
      "178-79",
      "179-75",
      "179-87",
      "18-64",
      "18-65",
      "180-57",
      "182-88",
      "182-89",
      "182-90",
      "183-100",
      "184-109",
      "184-159",
      "184-193",
      "189-4",
      "189-72",
      "191-65",
      "191-85",
      "192-121",
      "192-177",
      "195-59",
      "196-123",
      "196-154",
      "199-30",
      "199-31",
      "199-67",
      "199-90",
      "1A-189",
      "1A-192",
      "1A-211",
      "20-75",
      "20-82",
      "20-83",
      "200-22",
      "200-79",
      "21-121",
      "21-16",
      "226-46",
      "228-33",
      "228-55",
      "229-117",
      "229-131",
      "23-156",
      "230-116",
      "230-41",
      "230-71",
      "230-97",
      "231-27",
      "233-147",
      "233-175",
      "234-178",
      "234-193",
      "236-146",
      "236-84",
      "236-95",
      "252-158",
      "252-172",
      "254-76",
      "254-78",
      "254-82",
      "255-21",
      "260-46",
      "260-76",
      "261-112",
      "261-6",
      "261-7",
      "265A-35",
      "265A-46",
      "265B-26",
      "265B-28",
      "265B-61",
      "265C-25",
      "267D-259",
      "267E-234",
      "268B-15",
      "271-32",
      "273-2",
      "273-20",
      "34-8",
      "36-137",
      "42-81",
      "42-91",
      "69-162",
      "70-91",
      "70-92",
      "74-1",
      "74-6",
      "74-8",
      "75-128",
      "79-22",
      "8-88",
      "81-100",
      "82-31",
      "83-15",
      "83-80",
      "83-90",
      "83-98",
      "83-99",
      "84-101",
      "84-12",
      "84-91",
      "85-66",
      "86-84",
      "88-48",
      "90-125",
      "90-127",
      "90-155",
      "90-162",
      "91-191",
      "91-52",
      "92-88",
      "93-76",
      "93-78",
      "93-79",
      "93-80",
      "96-152",
      "97-111"
    ]
  },
  {
    "query": "find the top 20 commercial parcels within 1km of massachusetts avenue, prioritizing areas with higher consumer spending.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\nimport pandas as pd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\nspend_data = pd.read_csv('../data/cambridge_spend_processed.csv')\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels[parcels['use_code'].astype(str).isin(commercial_use_codes)].copy()\n# Set CRS for accurate distance measurement\ncommercial_parcels = commercial_parcels.to_crs(epsg=26986)\n# Define Massachusetts Avenue location\nmass_ave_geom = gpd.GeoSeries([\n    # Approximate line for Massachusetts Avenue\n    # Start point\n    (-71.1056, 42.3676), \n    # End point\n    (-71.0942, 42.3655)\n]).set_crs(epsg=4326).to_crs(epsg=26986)\n# Create 1km buffer around Massachusetts Avenue\nmass_ave_buffer = mass_ave_geom.buffer(1000).iloc[0]\n# Filter parcels within 1km of Massachusetts Avenue\nparcels_near_mass_ave = commercial_parcels[commercial_parcels.geometry.intersects(mass_ave_buffer)].copy()\n# Merge with spending data\nparcels_near_mass_ave = parcels_near_mass_ave.merge(\n    spend_data,\n    left_on='ml',\n    right_on='ml',\n    how='left'\n)\n# Merge with census data for additional spending metrics\nparcels_near_mass_ave = parcels_near_mass_ave.merge(\n    census,\n    left_on='census_tract',\n    right_on='tract',\n    how='left'\n)\n# Prioritize by spending (higher is better)\n# If there's no direct spending data, use alternative metrics\nif 'total_spend' in parcels_near_mass_ave.columns:\n    parcels_near_mass_ave = parcels_near_mass_ave.sort_values('total_spend', ascending=False)\nelif 'avg_spend' in parcels_near_mass_ave.columns:\n    parcels_near_mass_ave = parcels_near_mass_ave.sort_values('avg_spend', ascending=False)\nelse:\n    # If no spending data, prioritize by income\n    if 'median_income' in parcels_near_mass_ave.columns:\n        parcels_near_mass_ave = parcels_near_mass_ave.sort_values('median_income', ascending=False)\n    elif 'avg_income' in parcels_near_mass_ave.columns:\n        parcels_near_mass_ave = parcels_near_mass_ave.sort_values('avg_income', ascending=False)\n# Select top 20\ntop_parcels = parcels_near_mass_ave.head(20)\n# Convert back to original CRS\ntop_parcels = top_parcels.to_crs(parcels.crs)\n# Output results\ntop_ids = top_parcels['ml'].tolist()\nprint(top_ids)"
  },
  {
    "query": "find commercial parcels larger than 8000 square feet in census tracts with at least 90% of residents aged 18-64.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels[parcels['use_code'].astype(str).isin(commercial_use_codes)].copy()\n# Filter for parcels larger than 8000 sq ft\nlarge_commercial_parcels = commercial_parcels[commercial_parcels['land_area'] > 8000].copy()\n# Project to metric CRS for accurate spatial analysis\ncensus_proj = census.to_crs(epsg=26986)\nlarge_commercial_parcels_proj = large_commercial_parcels.to_crs(epsg=26986)\n# Define age group filter (18-64 years)\nage_group_filter = (census_proj['pct_age_18_64'] >= 0.90)\n# Select relevant census tracts\ntracts_meeting_age_criteria = census_proj[age_group_filter]['tract'].unique()\n# Filter by tract\nresult_parcels = large_commercial_parcels_proj[large_commercial_parcels_proj['tract'].isin(tracts_meeting_age_criteria)].copy()\n# Sort by parcel ID (ml)\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f"
  },
  {
    "query": "find commercial parcels that are between 5000-10000 square feet, within 500 meters of a subway station, and have no more than 1 competitor within 500 meters.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define subway station locations\nsubway_stations = [\n    (-71.1189, 42.3736),  # Harvard Square\n    (-71.1032, 42.3656),  # Central Square\n    (-71.0865, 42.3625),  # Kendall/MIT\n    (-71.1226, 42.3782),  # Porter Square\n    (-71.1429, 42.3954)   # Alewife\n]\nsubway_gdf = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy([lon], [lat])[0] for lon, lat in subway_stations],\n    crs=parcels.crs\n)\n# Project to metric CRS for accurate distance measurement\nparcels_proj = parcels.to_crs(epsg=26986)\nsubway_gdf_proj = subway_gdf.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Filter for commercial parcels (use specific codes for commercial)\ncommercial_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_codes)].copy()\n# Filter by size (5000-10000 sq ft)\nsize_filtered_parcels = commercial_parcels[\n    (commercial_parcels['land_area'] >= 5000) & \n    (commercial_parcels['land_area'] <= 10000)\n].copy()\n# Filter by proximity to subway stations (within 500m)\n# Use buffered subway stations for proximity filtering\nsubway_buffers = [geom.buffer(500) for geom in subway_gdf_proj.geometry]\nsubway_union_buffer = gpd.GeoSeries(subway_buffers).unary_union\n# Find parcels within 500m of subway stations\nparcels_near_subway = size_filtered_parcels[\n    size_filtered_parcels.geometry.intersects(subway_union_buffer)\n].copy()\n# Filter by competitor count (no more than 1 within 500m)\ndef count_competitors(parcel_geom, parcel_id, poi_geoms, buffer_distance=500):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    # Count competitors (businesses of the same type)\n    # Get parcel use code for this parcel\n    use_code = parcels_proj.loc[parcels_proj['ml'] == parcel_id, 'use_code'].values[0]\n    # Filter POI by business type (competitors)\n    if pd.isna(use_code):\n        return 0  # If no use code, assume no competitors\n    poi_of_type = poi_geoms[poi_geoms['business_type'] == use_code]\n    # Count competitors within buffer\n    count = poi_of_type[poi_of_type.geometry.intersects(buffered_geom)].shape[0]\n    return count\n# Calculate competitor count for each parcel\npoi_proj_geoms = poi_proj['geometry'].tolist()\ncompetitor_counts = []\nfor idx, row in parcels_near_subway.iterrows():\n    count = count_competitors(row['geometry'], row['ml'], poi_proj_geoms)\n    competitor_counts.append(count)\nparcels_near_subway.loc[:, 'competitor_count'] = competitor_counts\n# Filter for parcels with no more than 1 competitor\nfinal_parcels = parcels_near_subway[parcels_near_subway['competitor_count'] <= 1].copy()\n# Sort by parcel ID (ml)\nfinal_parcels = final_parcels.sort_values('ml')\n# Convert back to original CRS\nfinal_parcels = final_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(result_ids)"
  },
  {
    "query": "find parcels that are zoned for mixed-use, within 400 meters of public transportation, and at least 200 meters away from industrial areas.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\n# Filter for mixed-use parcels (commercial + residential)\nmixed_use_codes = ['340', '343', '345', '346', '353', '362', '375', '404', '406', '0340', '0343', '0345', '0346']\nmixed_use_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(mixed_use_codes)].copy()\n# Filter for public transportation (subway stations and major bus stops)\nsubway_stations = poi_proj[poi_proj['poi_type'] == 'subway_station']\n# Major bus stops (defined as bus stops with high traffic)\nmajor_bus_stops = poi_proj[poi_proj['poi_type'] == 'bus_stop'].nlargest(10, 'traffic_volume')\n# Combine transit points\ntransit_points = pd.concat([subway_stations, major_bus_stops])\ntransit_points = transit_points.drop_duplicates()\ntransit_points_proj = transit_points.to_crs(cambridge_crs)\n# 400m buffer around public transportation\ntransit_buffer = [geom.buffer(400) for geom in transit_points_proj.geometry]\ntransit_union_buffer = gpd.GeoSeries(transit_buffer).unary_union\n# Filter for parcels within 400m of public transportation\nparcels_near_transit = mixed_use_parcels[mixed_use_parcels.geometry.intersects(transit_union_buffer)].copy()\n# Filter for industrial areas (specific use codes)\nindustrial_codes = ['300', '302', '316', '323', '324', '325', '326', '327', '330', '332', '334', '3400']\n# Identify industrial parcels\nindustrial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(industrial_codes)].copy()\n# 200m buffer around industrial areas\nindustrial_buffers = [geom.buffer(200) for geom in industrial_parcels.geometry]\nindustrial_union_buffer = gpd.GeoSeries(industrial_buffers).unary_union\n# Filter for parcels at least 200m away from industrial areas\nfinal_parcels = parcels_near_transit[~parcels_near_transit.geometry.intersects(industrial_union_buffer)].copy()\n# Sort by parcel ID (ml column)\nfinal_parcels = final_parcels.sort_values('ml')\n# Convert back to original CRS\nfinal_parcels = final_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} parcels meeting all criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"
  },
  {
    "query": "find retail parcels between 2000-5000 square feet within 500m of a residential area, prioritizing locations with high foot traffic and in census tracts with median income above $30,000.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Filter by size (2000-5000 sq ft)\nretail_parcels = retail_parcels[(retail_parcels['land_area'] >= 2000) & (retail_parcels['land_area'] <= 5000)]\n# Filter for residential areas within 500m\nresidential_codes = ['101', '1014', '102', '1024', '104', '109', '1094', '1095', '1098', '200', '2000', '201', '202', '203', '204', '205', '206', '207', '8']\n# Identify residential parcels\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_codes)].copy()\n# Create 500m buffer around residential areas\nresidential_buffers = [geom.buffer(500) for geom in residential_parcels.geometry]\n# Combine buffers into a single geometry\nunion_buffer = gpd.GeoSeries(residential_buffers).unary_union\n# Filter retail parcels by proximity to residential areas\nnear_residential = retail_parcels[retail_parcels.geometry.intersects(union_buffer)].copy()\n# Join with census data to get income\nnear_residential = near_residential.merge(\n    census,\n    left_on='ml',\n    right_on='ml',\n    how='left'\n)\n# Filter for areas with median income above $30,000\nif 'median_income' in near_residential.columns:\n    income_filtered = near_residential[near_residential['median_income'] > 30000].copy()\nelse:\n    income_filtered = near_residential.copy()\n# Prioritize by foot traffic (if available)\nif 'foot_traffic' in poi.columns:\n    # Spatial join with POI to estimate foot traffic\n    poi_proj = poi.to_crs(parcels_proj.crs)\n    # Calculate foot traffic within 100m\n    def calculate_foot_traffic(parcel_geom):\n        buffer = parcel_geom.buffer(100)\n        return poi_proj[poi_proj.geometry.intersects(buffer)].foot_traffic.sum()\n    income_filtered.loc[:, 'foot_traffic'] = income_filtered.geometry.apply(calculate_foot_traffic)\n    # Sort by foot traffic (higher is better)\n    income_filtered = income_filtered.sort_values('foot_traffic', ascending=False)\n# Sort by parcel ID for consistency\nfinal_ids = income_filtered['ml'].tolist()\nprint(final_ids)"
  },
  {
    "query": "find office parcels larger than 5000 square feet with at least 2 parking spaces, prioritizing those in areas with high educational attainment.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Filter for office parcels (ml codes for office)\noffice_ml_codes = ['340', '341', '343', '345', '346', '353', '362']\noffice_parcels = parcels_proj[parcels_proj['ml'].astype(str).str.startswith(tuple(office_ml_codes))]\n# Filter for parcels larger than 5000 sq ft\nlarge_office_parcels = office_parcels[office_parcels['land_area'] > 5000]\n# Filter for parcels with at least 2 parking spaces\n# POI data has parking space information, so we can use that\n# First, we need to find the parking space data from POI\n# Filter for parking-related POI\nparking_poi = poi_proj[poi_proj['business_type'].isin(['parking_lot', 'parking_garage'])]\n# Function to count parking spaces for a given parcel\ndef count_parking_spaces(parcel_id, poi_geoms):\n    # Get POI for this parcel\n    parcel_poi = poi_geoms[poi_geoms['parcel_id'] == parcel_id]\n    if parcel_poi.empty:\n        return 0\n    # Estimate parking spaces based on POI type\n    total_spaces = 0\n    for _, row in parcel_poi.iterrows():\n        if row['business_type'] == 'parking_lot':\n            total_spaces += row['estimated_spaces']\n        elif row['business_type'] == 'parking_garage':\n            total_spaces += row['estimated_spaces']\n    return total_spaces\n# Get parking space data for each large office parcel\n# First, get POI geometries\npoi_geoms = parking_poi[['parcel_id', 'business_type', 'estimated_spaces']].copy()\n# Calculate parking spaces for each large office parcel\nlarge_parcels_with_parking = []\nfor parcel_id in large_office_parcels['ml']:\n    spaces = count_parking_spaces(parcel_id, poi_geoms)\n    if spaces >= 2:\n        large_parcels_with_parking.append(parcel_id)\n# Sort by parcel ID for consistency\nlarge_parcels_with_parking.sort()\n# Convert back to original CRS\nfinal_parcels = large_office_parcels[large_office_parcels['ml'].isin(large_parcels_with_parking)].copy()\nfinal_parcels = final_parcels.to_crs(parcels.crs)\n# Print results\nresult_ids = final_parcels['ml'].tolist()\nprint(f\"Found {len(final_parcels)} parcels meeting all criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"
  },
  {
    "query": "find parcels that are either commercial places within 100m of harvard square or residential larger than 5000 square feet and within 200m of 50 restaurants.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define Harvard Square location\nharvard_square = gpd.GeoDataFrame(\n    geometry=[gpd.points_from_xy([-71.1189, 42.3736])],\n    crs=parcels.crs\n)\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\nharvard_square_proj = harvard_square.to_crs(epsg=26986)\n# Filter commercial parcels\ncommercial_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', '330', \n    '332', '334', '340', '341', '343', '345', '346', '353', '362',\n    '375', '404', '406', '0340', '0406', '0122', '0114'\n]\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_codes)].copy()\n# Filter restaurants from POI data\nrestaurant_types = ['restaurant', 'fast_food', 'cafe', 'diner']\nrestaurants = poi[poi['business_type'].isin(restaurant_types)].copy()\n# Get 50 restaurants near Harvard Square\nrestaurants_near_harvard = restaurants[restaurants.geometry.distance(harvard_square_proj.geometry.iloc[0]) <= 200].copy()\n# Ensure we have at least 50 restaurants\nif len(restaurants) >= 50:\n    # Get 50 closest restaurants\n    restaurants_near_harvard = restaurants.iloc[restaurants.nsmallest(50, 'distance').index].copy()\nelse:\n    # If less than 50, take all\n    restaurants_near_harvard = restaurants.copy()\n# Filter residential parcels larger than 5000 sq ft\nresidential_codes = [\n    '101', '1014', '102', '1024', '104', '109', '1094', '1095', '1096', '1098',\n    '111', '112', '113', '114', '121', '970', '9700', '9701', '9702', '9703',\n    '9704', '9705', '9706', '9707', '9708', '971', '972', '974', '975', '976'\n]\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_codes)].copy()\nlarge_residential = residential_parcels[residential_parcels['land_area'] > 5000].copy()\n# Get 200m buffer around restaurants\nrestaurant_buffers = [geom.buffer(200) for geom in restaurants_near_harvard.geometry]\nunion_buffer = gpd.GeoSeries(restaurant_buffers).unary_union\n# Filter large residential within 200m of restaurants\nlarge_res_near_restaurants = large_residential[large_residential.geometry.intersects(union_buffer)].copy()\n# Combine criteria\nresult_parcels = pd.concat([commercial_parcels, large_res_near_restaurants])\n# Sort by ml (parcel ID)\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels matching criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"
  },
  {
    "query": "find parcels that are zoned for retail and within 300m of a subway station and not within 100m of a competitor.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\nspend = pd.read_csv('../data/cambridge_spend_processed.csv')\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Project to metric CRS for accurate buffering\nparcels_proj = parcels.to_crs(epsg=26986)\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Filter subway stations\nsubway_stations = poi[poi['poi_type'] == 'subway_station'].copy()\nsubway_stations_proj = subway_stations.to_crs(epsg=26986)\n# Condition 1: Within 300m of subway station\nretail_near_subway = retail_parcels[retail_parcels.geometry.distance(subway_stations_proj.unary_union) <= 300].copy()\n# Filter retail businesses from POI data\nretail_business_ids = poi[poi['poi_type'] == 'business']['place_id'].tolist()\n# Condition 2: Not within 100m of a competitor\ndef has_nearby_competitors(parcel_geom, parcel_id, buffer_distance=100):\n    # Get retail business ID for this parcel\n    business_id = parcel_id  # Assuming parcel_id corresponds to business_id in POI\n    # Buffer for competitor search\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    # Find nearby retail businesses\n    nearby_retail = poi[(poi['poi_type'] == 'business') & (poi['place_id'] != business_id) & (poi['geometry'].intersects(buffered_geom))].copy()\n    # If there are any nearby retail, this parcel has competitors\n    return len(nearby_retail) > 0\n# Filter out parcels with competitors\nretail_no_competitors = []\nfor idx, row in retail_near_subway.iterrows():\n    if not has_nearby_competitors(row.geometry, row['ml']):\n        retail_no_competitors.append(row['ml'])\n# Sort by parcel ID\nretail_no_competitors.sort()\n# Print results\nprint(f\"Found {len(retail_no_competitors)} parcels meeting all criteria\")\nprint(f\"Parcel IDs: {retail_no_competitors}\")"
  },
  {
    "query": "find parcels that are either office space larger than 10,000 sq ft or retail space within 500m of high-density residential areas.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# CONDITION 1: Office space larger than 10,000 sq ft\n# Define office use codes\noffice_use_codes = ['340', '343', '345', '346', '0340', '404', '406']\n# Filter for office parcels\noffice_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(office_use_codes)].copy()\n# Filter by size\nlarge_office = office_parcels[office_parcels['land_area'] > 10000].copy()\n# CONDITION 2: Retail space within 500m of high-density residential areas\n# Define retail use codes\nretail_use_codes = ['323', '324', '325', '326', '327', '330']\n# Filter for retail parcels\nretail_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(retail_use_codes)].copy()\n# Define high-density residential use codes\nhigh_density_res_codes = ['111', '112', '114', '0111', '0112']\n# Filter for high-density residential parcels\nhigh_density_res = parcels_proj[parcels_proj['use_code'].astype(str).isin(high_density_res_codes)].copy()\n# Find retail near high-density residential\n# Create 500m buffer around high-density residential\nhigh_density_buffers = [geom.buffer(500) for geom in high_density_res.geometry]\nhigh_density_union_buffer = gpd.GeoSeries(high_density_buffers).unary_union\n# Filter retail by proximity to high-density residential\nretail_near_high_density = retail_parcels[retail_parcels.geometry.intersects(high_density_union_buffer)].copy()\n# COMBINE CONDITIONS (OR)\n# Add a flag to identify which condition each parcel meets\nlarge_office.loc[:, 'condition'] = 'large_office'\nretail_near_high_density.loc[:, 'condition'] = 'retail_near_high_density'\n# Concatenate results from both conditions\ncombined_results = pd.concat([large_office, retail_near_high_density])\n# Remove any duplicates (parcels that meet both conditions)\ncombined_results = combined_results.drop_duplicates('ml')\n# Sort by parcel ID\ncombined_results = combined_results.sort_values('ml')\n# Convert back to original CRS\ncombined_results = combined_results.to_crs(parcels.crs)\n# Output results\nresult_ids = combined_results['ml'].tolist()\nprint(f\"Found {len(combined_results)} parcels meeting either condition\")\nprint(f\"Parcel IDs: {result_ids}\")"
  },
  {
    "query": "find commercial parcels that, if larger than 5000 sq ft, must be within 400m of public transit, or if smaller, must be within 200m of residential areas.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Define commercial use codes\ncommercial_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', \n    '330', '332', '334', '340', '341', '343', '345', '346',\n    '353', '362', '375', '404', '406', '0340', '0406'\n]\n# Filter for commercial parcels\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_use_codes)].copy()\n# Filter POI for transit-related businesses\ntransit_poi_types = ['bus', 'subway', 'train', 'transportation_service']\ntransit_poi = poi_proj[poi_proj['business_type'].isin(transit_poi_types)].copy()\n# Filter for residential areas in census data\nresidential_census = census_proj[census_proj['land_use'].astype(str).isin(['101', '1014', '102', '104', '105', '109', '1094', '1095', '1096', '1098', '111', '112', '113', '114', '970'])].copy()\n# Define condition for large commercial parcels (>5000 sq ft)\nlarge_parcel_condition = (commercial_parcels['land_area'] > 5000)\n# Find large parcels within 400m of transit\nlarge_near_transit = []\nfor idx, parcel in commercial_parcels[large_parcel_condition].iterrows():\n    # Get parcel geometry\n    geom = parcel.geometry\n    # Find nearby transit POI within 400m\n    nearby_transit = transit_poi[transit_poi.geometry.distance(geom) <= 400]\n    if not nearby_transit.empty:\n        large_near_transit.append(parcel['ml'])\n# Define condition for small commercial parcels (<=5000 sq ft)\nsmall_parcel_condition = (commercial_parcels['land_area'] <= 5000)\n# Find small parcels within 200m of residential areas\nsmall_near_residential = []\nfor idx, parcel in commercial_parcels[small_parcel_condition].iterrows():\n    # Get parcel geometry\n    geom = parcel.geometry\n    # Find nearby residential areas within 200m\n    nearby_residential = residential_census[residential_census.geometry.distance(geom) <= 200]\n    if not nearby_residential.empty:\n        small_near_residential.append(parcel['ml'])\n# Combine results\nresult_ids = set(large_near_transit) | set(small_near_residential)\n# Sort by parcel ID\nresult_ids = sorted(result_ids)\n# Convert back to original CRS\nresult_ids = [int(id) for id in result_ids]\n# Print results\nprint(f\"Found {len(result_ids)} parcels meeting criteria:\")\nprint(f\"Parcel IDs: {result_ids}\")"
  },
  {
    "query": "find parcels that are: if zoned for commercial, must be larger than 8000 sq ft; if zoned for residential, must have less than 2 similar properties within 1000m",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define projected CRS for Cambridge, MA\ncambridge_crs = 26986\n# Project to accurate CRS\nparcels_proj = parcels.to_crs(cambridge_crs)\npoi_proj = poi.to_crs(cambridge_crs)\ncensus_proj = census.to_crs(cambridge_crs)\n# Filter commercial parcels (retail, office, etc.)\ncommercial_codes = ['323', '324', '325', '326', '327', '330', '332', '334', '340', '341', '343', '345', '346', '353', '362', '375']\ncommercial_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(commercial_codes)].copy()\n# Filter residential parcels (one and two family homes)\nresidential_codes = ['101', '1014', '102', '1028', '104', '109', '1094', '1095', '1098', '105', '1054', '1055', '1096', '1097']\nresidential_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(residential_codes)].copy()\n# CONDITION 1: Commercial parcels larger than 8000 sq ft\nlarge_commercial = commercial_parcels[commercial_parcels['land_area'] > 8000].copy()\n# CONDITION 2: Residential parcels with less than 2 similar properties within 1000m\n# Function to count similar properties within 1000m\ndef count_similar_properties(parcel_geom, parcel_code, all_parcels, buffer_distance=1000):\n    # Get property type for this parcel\n    prop_type = str(parcel_code)\n    \n    # Find similar properties (same type)\n    similar_parcels = all_parcels[all_parcels['use_code'].astype(str) == prop_type].copy()\n    \n    # Calculate buffer\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    \n    # Count similar properties within buffer (excluding the parcel itself)\n    similar_within_buffer = similar_parcels[similar_parcels.geometry.intersects(buffered_geom)].copy()\n    \n    # Subtract 1 to exclude the parcel itself\n    count = len(similar_within_buffer) - 1\n    return max(0, count)  # Ensure count is not negative\n# Calculate similar property count for each residential parcel\nresidential_parcels.loc[:, 'similar_count'] = [\n    count_similar_properties(row.geometry, row['use_code'], residential_parcels)\n    for idx, row in residential_parcels.iterrows()\n]\n# Filter for residential parcels with less than 2 similar properties\nresidential_low_density = residential_parcels[residential_parcels['similar_count'] < 2].copy()\n# Combine results\nresult_parcels = pd.concat([large_commercial, residential_low_density])\n# Sort by parcel ID (ml column)\nresult_parcels = result_parcels.sort_values('ml')\n# Convert back to original CRS\nresult_parcels = result_parcels.to_crs(parcels.crs)\n# Output results\nresult_ids = result_parcels['ml'].tolist()\nprint(f\"Found {len(result_parcels)} parcels meeting criteria\")\nprint(f\"Parcel IDs: {result_ids}\")"
  },
  {
    "query": "find mixed-use parcels that, if north of massachusetts avenue, must have retail on the ground floor, otherwise must have at least 3000 sq ft of commercial space.",
    "method": "fine-tuned-rag",
    "model": "ft:gpt-4o-mini-2024-07-18:mit:spatial-agent-20250505-021001:BTjW7EkG",
    "success": false,
    "code": "import geopandas as gpd\n# Load data\nparcels = gpd.read_file('../data/cambridge_parcels.geojson')\npoi = gpd.read_file('../data/cambridge_poi_processed.geojson')\ncensus = gpd.read_file('../data/cambridge_census_cambridge_pct.geojson')\n# Define retail business types\nretail_business_types = [\n    'restaurant', 'cafe', 'grocery', 'supermarket', 'clothing_store',\n    'department_store', 'convenience_store', 'furniture_store', 'hardware_store',\n    'electronics_store', 'toy_store', 'book_store', 'jewelry_store', 'department_store'\n]\n# Project to metric CRS for accurate analysis\nparcels_proj = parcels.to_crs(epsg=26986)\npoi_proj = poi.to_crs(epsg=26986)\n# Define Massachusetts Avenue\nmass_ave = gpd.GeoSeries([\n    # Approximate line for Massachusetts Avenue\n    # This line is not perfectly accurate but serves as a reasonable approximation\n    # for the purpose of this analysis\n    gpd.points_from_xy([-71.1056, -71.1045, -71.1034, -71.1023], [42.3656, 42.3651, 42.3645, 42.364]) \n]).unary_union\nmass_ave_line = gpd.GeoSeries(mass_ave).to_crs(epsg=26986)\n# Define mixed-use codes\nmixed_use_codes = [\n    '300', '302', '316', '323', '324', '325', '326', '327', '330', '332', \n    '334', '340', '341', '343', '345', '346', '353', '362', '375', '404'\n]\n# Filter for mixed-use parcels\nmixed_use_parcels = parcels_proj[parcels_proj['use_code'].astype(str).isin(mixed_use_codes)].copy()\n# Condition 1: If north of Massachusetts Avenue, must have retail on ground floor\n# Define north of Massachusetts Avenue\nnorth_of_mass_ave = mixed_use_parcels[mixed_use_parcels.geometry.centroid.y > mass_ave_line.iloc[0].y].copy()\n# Filter retail POI\nretail_poi = poi_proj[poi_proj['business_type'].isin(retail_business_types)]\n# Function to check if parcel has retail on ground floor\ndef has_retail_on_ground_floor(parcel_geom, retail_poi_geoms, buffer_distance=50):\n    buffered_geom = parcel_geom.buffer(buffer_distance)\n    for poi_geom in retail_poi_geoms:\n        if poi_geom is not None and buffered_geom.contains(poi_geom):\n            return True\n    return False\n# Get retail POI geometries\nretail_poi_geoms = retail_poi['geometry'].tolist()\n# Filter north of Mass Ave parcels that have retail on ground floor\nnorth_with_retail = []\nfor idx, row in north_of_mass_ave.iterrows():\n    if has_retail_on_ground_floor(row['geometry'], retail_poi_geoms):\n        north_with_retail.append(row['ml'])\n# Condition 2: Otherwise must have at least 3000 sq ft of commercial space\n# For mixed-use codes, commercial space can be estimated from total area\n# Assuming a portion of the area is commercial, we can use a rough estimate\n# For example, if the parcel is 40% commercial, then 3000 sq ft of commercial space would be\n# on a 7500 sq ft parcel (0.4 * 7500 = 3000)\n# So we can filter by total area\nsouth_of_mass_ave = mixed_use_parcels[mixed_use_parcels.geometry.centroid.y <= mass_ave_line.iloc[0].y].copy()\n# Estimate commercial space based on total area\n# For simplicity, assume 40% of mixed-use parcels are commercial\nsouth_with_space = south_of_mass_ave[south_of_mass_ave['land_area'] * 0.4 >= 3000].copy()\n# Combine results\nfinal_ids = north_with_retail + south_with_space['ml'].tolist()\n# Sort by parcel ID\nfinal_ids = sorted(final_ids)\n# Convert back to original CRS\nparcels_final = mixed_use_parcels[mixed_use_parcels['ml'].isin(final_ids)].to_crs(parcels.crs)\n# Output results\nprint(f\"Found {len(final_ids)} mixed-use parcels meeting criteria\")\nprint(f\"Parcel IDs: {final_ids}\")"
  }
]